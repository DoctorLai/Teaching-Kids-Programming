1
00:00:00,000 --> 00:00:00,766
哎大家好

2
00:00:00,766 --> 00:00:03,433
今天我们来讲第42课: 组合数学

3
00:00:03,433 --> 00:00:06,166
那就是 计算一个组合数的三种算法

4
00:00:06,166 --> 00:00:07,233
这个是比较经典的

5
00:00:07,233 --> 00:00:08,333
就是 怎么说呢

6
00:00:08,333 --> 00:00:09,966
通过这个计算这个组合数

7
00:00:09,966 --> 00:00:11,866
我们可以延伸出几种算法吧

8
00:00:11,866 --> 00:00:15,666
这个内容我们在上周给孩子讲过

9
00:00:15,666 --> 00:00:17,733
所以你应该也能听得懂 ;)

10
00:00:17,866 --> 00:00:19,800
组合数学就是那个排列组合 是吧

11
00:00:19,800 --> 00:00:22,066
排列就是有顺序的

12
00:00:22,066 --> 00:00:24,433
这个你选的这个这个东西是有顺序

13
00:00:24,433 --> 00:00:26,300
比如说三个苹果挑两个

14
00:00:26,300 --> 00:00:27,533
然后来排列, 对吧

15
00:00:27,533 --> 00:00:29,666
那就12-21, 对吧

16
00:00:29,833 --> 00:00:31,333
13-31

17
00:00:32,100 --> 00:00:33,933
然后是23-32是吧

18
00:00:33,933 --> 00:00:35,000
这个你分三组吗

19
00:00:35,000 --> 00:00:38,733
12和21是那个不一样的, 就有顺序

20
00:00:38,900 --> 00:00:39,600
分成三组

21
00:00:39,600 --> 00:00:42,700
那如果没有顺序的话 那就叫组合吗

22
00:00:42,700 --> 00:00:45,300
比如说三个苹果挑两个那就是12

23
00:00:45,833 --> 00:00:47,933
13-23对吧

24
00:00:48,066 --> 00:00:50,833
是不是 那排列和组合有什么关系呢?

25
00:00:50,833 --> 00:00:52,733
那我是不是可以这么理解?

26
00:00:52,733 --> 00:00:53,700
就是我排列

27
00:00:53,900 --> 00:00:56,433
是组合之后再加一个全排列

28
00:00:56,433 --> 00:00:59,200
就是我三个苹果挑两个苹果的排列

29
00:00:59,200 --> 00:01:01,800
是不是我先三个苹果挑两个的组合

30
00:01:02,200 --> 00:01:04,500
那我挑完两个苹果之后

31
00:01:04,500 --> 00:01:07,333
是不是两个苹果再进行全排列 对吧

32
00:01:07,333 --> 00:01:08,599
全排列 我们讲过吗

33
00:01:08,600 --> 00:01:10,500
就是P(N, N) 是吧

34
00:01:10,500 --> 00:01:14,066
P(N, N) 这个实际上多少种呢?

35
00:01:14,066 --> 00:01:15,100
是N阶乘 (N!) 嘛 

36
00:01:15,133 --> 00:01:15,833
可以这么理解

37
00:01:15,833 --> 00:01:18,066
比如说我3个苹果有多少种排法呢?

38
00:01:18,066 --> 00:01:18,599
有6种

39
00:01:18,700 --> 00:01:21,266
第一个苹果我可以有三种选择

40
00:01:21,533 --> 00:01:23,433
第二个苹果我可以有两种选择

41
00:01:23,800 --> 00:01:25,700
第三个苹果只有一种选择, 对吧

42
00:01:25,700 --> 00:01:28,466
这叫 P(N, N) 那我刚才讲说

43
00:01:28,466 --> 00:01:31,433
P(N, M) N个苹果挑M个

44
00:01:31,433 --> 00:01:31,700
是不是

45
00:01:31,700 --> 00:01:34,900
我首先 先把它选出来就是没有顺序了

46
00:01:34,900 --> 00:01:36,133
这个是不是没有顺序了

47
00:01:36,466 --> 00:01:37,800
没有顺序之后选出来

48
00:01:37,800 --> 00:01:39,700
我再进行M个排列

49
00:01:39,700 --> 00:01:43,533
对吧 所以我们之前也学过这个

50
00:01:43,600 --> 00:01:46,600
这个数学公式 C(N, M)

51
00:01:47,266 --> 00:01:49,933
C(N, M) 是等于N阶乘除以

52
00:01:50,733 --> 00:01:53,466
(N减M)阶乘 是吧

53
00:01:53,466 --> 00:01:55,100
然后再除以一个

54
00:01:55,266 --> 00:01:55,933
除一个什么呢?

55
00:01:55,933 --> 00:01:58,866
N阶乘, 这个是, 这是后面的

56
00:02:00,000 --> 00:02:02,533
然后那个 P(N, M) 就是

57
00:02:03,033 --> 00:02:03,800
就是 怎么了

58
00:02:03,800 --> 00:02:05,833
就是没有, 因为它要乘以这N阶乘吗

59
00:02:05,833 --> 00:02:08,200
是吧 所以就后面这个没有 对不对

60
00:02:08,266 --> 00:02:10,233
这是我们复习一下 简单复习一下

61
00:02:10,233 --> 00:02:11,866
那这个组合

62
00:02:11,866 --> 00:02:13,466
我们今天主要讲的是这个组合

63
00:02:13,466 --> 00:02:14,933
组合就是选嘛

64
00:02:14,933 --> 00:02:16,966
选3个苹果选两个苹果

65
00:02:16,966 --> 00:02:18,166
3个苹果选两个苹果

66
00:02:18,166 --> 00:02:20,266
是不是跟3个苹果选一个苹果是一样(数目)

67
00:02:20,266 --> 00:02:20,866
对吧

68
00:02:20,866 --> 00:02:23,633
你想, 我3个苹果选, 3个苹果选两个

69
00:02:23,800 --> 00:02:25,633
实际上是不是这边这一组是吧

70
00:02:25,633 --> 00:02:29,266
嗯12-13, 那这边就是2对吧

71
00:02:29,333 --> 00:02:31,666
23这个就1你每次选两个苹果

72
00:02:31,666 --> 00:02:33,200
那剩下的是不是也就一组

73
00:02:33,466 --> 00:02:37,266
所以我们就可以得到C(N, M)个苹果选M个

74
00:02:37,266 --> 00:02:38,466
实际上是相当于

75
00:02:38,833 --> 00:02:41,400
N个苹果选(N-M)个对吧

76
00:02:41,433 --> 00:02:42,966
那我们今天再来讲一个

77
00:02:43,166 --> 00:02:44,599
最有名的这个递推公式

78
00:02:44,599 --> 00:02:46,399
就是N个苹果选M个苹果

79
00:02:46,399 --> 00:02:48,066
实际上相当于什么呢

80
00:02:48,199 --> 00:02:50,033
就是我可以这么理解

81
00:02:50,033 --> 00:02:51,499
比如说我有好多个苹果

82
00:02:51,499 --> 00:02:53,833
嗯我画一个就是这边好多苹果

83
00:02:54,266 --> 00:02:54,799
这边好多苹果

84
00:02:55,333 --> 00:02:56,799
这边有N个

85
00:02:57,899 --> 00:02:59,499
对那我要选M个吗

86
00:02:59,500 --> 00:03:00,633
我要选M个

87
00:03:00,899 --> 00:03:02,866
这看不太清楚 我这边把它移过来

88
00:03:02,866 --> 00:03:03,666
好

89
00:03:03,999 --> 00:03:05,466
那我首先我看第一个好了

90
00:03:06,099 --> 00:03:07,933
那第一个苹果 我有两种选择吗

91
00:03:07,933 --> 00:03:09,899
我要么选它 要么不选 对不对

92
00:03:09,933 --> 00:03:10,766
那我选它

93
00:03:10,766 --> 00:03:13,266
我是不是还有M-1个苹果要选

94
00:03:13,733 --> 00:03:15,299
我如果不选的话

95
00:03:15,299 --> 00:03:17,666
我是不是还有M个苹果要选

96
00:03:17,799 --> 00:03:21,533
那都是在(N-1)个苹果里面选 是不是

97
00:03:21,533 --> 00:03:22,766
所以可以这么理解

98
00:03:23,066 --> 00:03:25,399
我选了它我就还有 M-1 个

99
00:03:25,699 --> 00:03:27,199
如果我不选它

100
00:03:27,699 --> 00:03:29,166
就还有M个对吧

101
00:03:29,166 --> 00:03:31,233
就是你想啊 这个 N-1

102
00:03:31,233 --> 00:03:33,433
因为我第一个苹果我可以有两种选择

103
00:03:33,433 --> 00:03:34,166
选或者不选

104
00:03:34,166 --> 00:03:35,733
那我剩下就是 N-1 个苹果

105
00:03:35,733 --> 00:03:37,833
那如果选的话就还有 M-1 个(要选)

106
00:03:37,833 --> 00:03:40,499
如果不选的话就还有 M 个(要选)

107
00:03:40,566 --> 00:03:43,033
一些边界条件就是0的话

108
00:03:43,033 --> 00:03:45,366
我N个苹果选0个就一种

109
00:03:45,633 --> 00:03:47,433
我N个苹果选N个

110
00:03:48,066 --> 00:03:49,100
就一种, 对吧?

111
00:03:49,166 --> 00:03:52,800
当然如果这个M大于N的话

112
00:03:52,800 --> 00:03:53,600
比如说

113
00:03:53,766 --> 00:03:55,700
三个苹果你要选100个是不可能的

114
00:03:55,700 --> 00:03:56,800
所以就返回0, 对吧?

115
00:03:56,866 --> 00:03:58,566
有一个这个 Pascal Triangle

116
00:03:58,566 --> 00:03:59,600
就是这样的

117
00:04:04,266 --> 00:04:05,566
这个我不知道给你讲过没有

118
00:04:05,566 --> 00:04:06,633
但我给小孩子讲过

119
00:04:06,633 --> 00:04:09,000
这个我就给它画一个很简单的这个图

120
00:04:09,466 --> 00:04:10,400
三角形你看到

121
00:04:10,400 --> 00:04:12,400
这个三角形堆的 边界都是1吗

122
00:04:12,400 --> 00:04:14,000
是吧 边界都1

123
00:04:14,000 --> 00:04:15,166
然后你这个任何一个数字

124
00:04:15,166 --> 00:04:16,800
是不是相当于它肩上两个数字之和

125
00:04:16,800 --> 00:04:18,466
这3等于1加2

126
00:04:18,466 --> 00:04:20,266
三等于二加一, 6等于这个

127
00:04:20,266 --> 00:04:21,566
这个实际上就是这个公式

128
00:04:21,566 --> 00:04:22,800
可以理解成这个公式

129
00:04:22,800 --> 00:04:25,700
你看我6实际上就等于

130
00:04:26,166 --> 00:04:29,233
我计算机里面它这个数组

131
00:04:29,233 --> 00:04:29,800
矩形吗

132
00:04:29,800 --> 00:04:32,533
正规的, 我这么给它往左移一下

133
00:04:32,666 --> 00:04:34,966
你看这个6是不是等于上面这个

134
00:04:35,000 --> 00:04:38,066
再加这左边这个, 就是它肩上两个吗

135
00:04:38,133 --> 00:04:39,233
现在是第N行

136
00:04:39,233 --> 00:04:42,066
那N减一行就是上面那个

137
00:04:42,166 --> 00:04:44,366
M就是它上面这个值

138
00:04:44,433 --> 00:04:47,433
M减1就是它上面左边这个值

139
00:04:47,866 --> 00:04:49,833
对吧, 所以它实际上是这么一个

140
00:04:49,833 --> 00:04:51,099
叫做 Pascal Triangle

141
00:04:51,099 --> 00:04:53,099
这中文里面还有一种说法

142
00:04:53,099 --> 00:04:54,499
叫做杨辉三角形

143
00:04:54,499 --> 00:04:55,899
有兴趣可以去 Google 一下

144
00:04:55,933 --> 00:04:58,499
你看我们现在已经有这个公式了

145
00:04:58,500 --> 00:04:59,433
是吧, 递推公式

146
00:04:59,433 --> 00:05:01,466
那我们就实际上是可以给它实现一下

147
00:05:01,466 --> 00:05:02,866
我有这公式可以算了

148
00:05:03,000 --> 00:05:04,800
那我就可以去用 Python

149
00:05:05,233 --> 00:05:06,233
代码去实现一下

150
00:05:06,233 --> 00:05:09,933
就是def定义函数 就C好了

151
00:05:10,400 --> 00:05:12,700
 C(N, M)

152
00:05:13,033 --> 00:05:14,966
对吧 那如果N

153
00:05:15,100 --> 00:05:19,233
M==0 对吧 或者 N==M

154
00:05:19,500 --> 00:05:21,266
或者就这两种情况

155
00:05:21,266 --> 00:05:22,766
那么应该它是返回

156
00:05:23,566 --> 00:05:25,133
返回1对吧

157
00:05:25,733 --> 00:05:30,433
然后如果M大于N的话那就返回0

158
00:05:30,433 --> 00:05:31,233
那

159
00:05:31,333 --> 00:05:34,033
那其它情况就是用递归的方式去实现

160
00:05:34,033 --> 00:05:36,066
就C(N减1)上面那个公式 对吧

161
00:05:36,500 --> 00:05:39,633
加上C(N减1, M) 对吧

162
00:05:40,100 --> 00:05:40,433
就

163
00:05:40,433 --> 00:05:42,533
就有点像那个之前讲的那个 Fibonacci

164
00:05:42,533 --> 00:05:43,233
斐波那契额数列

165
00:05:43,233 --> 00:05:44,466
就是递归

166
00:05:44,766 --> 00:05:47,633
递归, 就是我要计算这个 C(N,）

167
00:05:47,633 --> 00:05:49,366
我是不是要计算这两个值

168
00:05:49,500 --> 00:05:50,766
那就是一棵树一样

169
00:05:50,766 --> 00:05:52,866
它是把它分成两个, 两个

170
00:05:52,866 --> 00:05:54,766
那这时候我们是需要记录一下

171
00:05:54,766 --> 00:05:55,933
这个中间的值

172
00:05:55,933 --> 00:05:58,033
你可以想象就是我一棵树

173
00:05:58,266 --> 00:05:59,533
对我一个树, 对吧

174
00:05:59,533 --> 00:06:01,700
我这 C(N, M) 然后我是分成两叉

175
00:06:01,700 --> 00:06:03,666
然后再分成两叉再分成两叉

176
00:06:03,666 --> 00:06:05,733
就每个节点它都会展开

177
00:06:05,833 --> 00:06:08,666
那实际上我有可能我这个节点在这里

178
00:06:08,666 --> 00:06:11,466
然后有可能它在其它节点出现过

179
00:06:12,533 --> 00:06:14,066
那如果我这个已经计算过了

180
00:06:14,066 --> 00:06:15,500
我这边花了比如说5分钟

181
00:06:15,500 --> 00:06:17,500
计算的这么一个 C(N, )

182
00:06:17,633 --> 00:06:19,133
什么东西这个值在这里

183
00:06:19,166 --> 00:06:21,033
那我等会在计算这里的时候

184
00:06:21,033 --> 00:06:22,900
我是不需要再重新计算

185
00:06:22,900 --> 00:06:24,333
因为它值是一样的吗 对吧

186
00:06:24,333 --> 00:06:26,533
N和M确定的话, 它 C(N, M) 值是一样的

187
00:06:26,733 --> 00:06:29,466
那我就说 我在计算这个 C(N, M)

188
00:06:29,500 --> 00:06:31,500
计算完之后我就给它记忆一下

189
00:06:31,500 --> 00:06:32,333
记录一下

190
00:06:32,333 --> 00:06:33,433
这个之前讲过

191
00:06:33,433 --> 00:06:34,666
这个 Fibonacci 数列

192
00:06:34,766 --> 00:06:37,500
这时候讲过这个记忆, 所以

193
00:06:37,500 --> 00:06:39,700
最简单的方法就是这边加上一个 @cache

194
00:06:39,866 --> 00:06:42,033
我计算过这个C(N, M) 值

195
00:06:42,066 --> 00:06:43,600
就N和M的任意的值

196
00:06:43,600 --> 00:06:45,033
那我第一次看过

197
00:06:45,033 --> 00:06:47,466
我如果没有计算过, 我就计算一下

198
00:06:47,466 --> 00:06:49,433
计算完之后把它写在一个本子上面

199
00:06:49,633 --> 00:06:50,999
记录一下就是

200
00:06:51,200 --> 00:06:53,133
这个 cache 一般是哈稀表

201
00:06:53,133 --> 00:06:54,266
然后你就可以

202
00:06:54,366 --> 00:06:56,033
下次再需要用到的时候

203
00:06:56,033 --> 00:06:57,466
就不需要再计算

204
00:06:57,466 --> 00:06:59,233
对不对 这就是记忆 对吧

205
00:06:59,233 --> 00:07:01,666
你没有必要是 傻傻的再去算一遍 对吧

206
00:07:01,666 --> 00:07:03,133
这个就会加快计算速度

207
00:07:03,133 --> 00:07:04,433
那如果你要自己实现的话

208
00:07:04,433 --> 00:07:05,266
我们再解释一下

209
00:07:05,266 --> 00:07:06,366
就是用个 memo

210
00:07:06,366 --> 00:07:07,466
就是哈稀表

211
00:07:07,633 --> 00:07:09,833
那我这边可以这么写, 如果N

212
00:07:10,533 --> 00:07:12,766
(N, M) in memo 的话

213
00:07:12,766 --> 00:07:17,199
那我以前见过就 return memo[(N, M)]

214
00:07:17,233 --> 00:07:18,799
memo[(N, M)]

215
00:07:18,866 --> 00:07:21,066
然后这时候返回的时候 我这边

216
00:07:21,400 --> 00:07:24,633
就给它这样子 memo[(N, M)]

217
00:07:26,033 --> 00:07:29,000
嗯就把它记录下来再返回

218
00:07:29,166 --> 00:07:29,366
对吧

219
00:07:29,366 --> 00:07:30,966
这个实际上你可以理解成两个步骤

220
00:07:30,966 --> 00:07:31,766
ans = 它

221
00:07:31,766 --> 00:07:34,466
然后再 return answer 这是一样的

222
00:07:34,466 --> 00:07:36,233
这种方法叫做

223
00:07:36,500 --> 00:07:39,500
Top Down Dynamic Programming 由上至下 动态规划

224
00:07:39,566 --> 00:07:41,833
DP 动态规划 我们以前讲过

225
00:07:41,899 --> 00:07:42,999
什么叫动态规划?

226
00:07:42,999 --> 00:07:44,999
就是(比如), 你给小孩子

227
00:07:45,033 --> 00:07:45,966
3个棒棒糖

228
00:07:46,100 --> 00:07:48,033
然后五分钟之后再给TA一个棒棒糖

229
00:07:48,033 --> 00:07:49,666
TA会告诉你说它有4个

230
00:07:49,666 --> 00:07:51,433
但TA不是从一开始再往后数

231
00:07:51,433 --> 00:07:53,700
因为TA, 之前, 你给TA 3个的时候

232
00:07:53,700 --> 00:07:55,766
TA已经有印象 我已经有三个了

233
00:07:55,766 --> 00:07:56,900
再给我一个棒棒糖

234
00:07:56,900 --> 00:07:58,466
我就是简单的3加一

235
00:07:58,466 --> 00:07:59,266
这等于四 对不对

236
00:07:59,266 --> 00:08:02,066
这个是最简单的解释方法

237
00:08:02,066 --> 00:08:03,633
这个这里面也是一样

238
00:08:03,700 --> 00:08:07,233
那这个 这是一种方法组合数学

239
00:08:07,300 --> 00:08:08,633
那组合数学就很有用

240
00:08:08,766 --> 00:08:11,300
然后比如说, 这个sublist是这个连续的

241
00:08:11,300 --> 00:08:12,433
就这子串(好像翻译成子列表合适一点)吗

242
00:08:12,566 --> 00:08:14,266
可以12和123

243
00:08:14,533 --> 00:08:17,066
然后234,456,789

244
00:08:17,166 --> 00:08:18,666
就是它只要连续的吧

245
00:08:18,666 --> 00:08:19,733
那这有多少种呢

246
00:08:19,933 --> 00:08:20,466
怎么去数呢

247
00:08:20,466 --> 00:08:21,700
你怎么去计算呢?

248
00:08:21,700 --> 00:08:22,700
实际上这个很简单

249
00:08:22,700 --> 00:08:24,933
你看我这个假设我这是有N个吧

250
00:08:24,933 --> 00:08:25,733
长度是N吗

251
00:08:25,733 --> 00:08:27,500
好吧 那我多少个子串呢?

252
00:08:27,500 --> 00:08:29,533
我是不是有两种情况 1种是子串

253
00:08:29,700 --> 00:08:31,333
它长度为1对吧

254
00:08:31,333 --> 00:08:33,733
那长度为1就是 C(N, 1) 对吧

255
00:08:33,766 --> 00:08:36,533
N个字符串我取一个 是不是

256
00:08:36,833 --> 00:08:38,266
那如果不是长度为1

257
00:08:38,266 --> 00:08:39,533
我是不是可以取一个左边(开始的索引)

258
00:08:39,533 --> 00:08:40,466
取一个右边(结束的索引)

259
00:08:40,900 --> 00:08:43,466
那我就是 C(N, 2) 对吧

260
00:08:43,833 --> 00:08:45,666
那这它实际上的子串

261
00:08:45,666 --> 00:08:46,900
就是这两个数相加

262
00:08:46,900 --> 00:08:48,533
对吧 就是很好理解 对吧

263
00:08:48,666 --> 00:08:49,999
然后这是第一种方法

264
00:08:50,000 --> 00:08:52,466
第二种方法 就是我 Bottom Up

265
00:08:52,466 --> 00:08:53,466
刚才讲的是 Top Down

266
00:08:53,466 --> 00:08:56,400
现在是 Bottom Up 就是 从底往上算

267
00:08:56,566 --> 00:08:57,933
刚才我们是 C(N,)

268
00:08:57,966 --> 00:08:58,633
比如说C(N, M)

269
00:08:58,633 --> 00:09:00,366
然后我要展开

270
00:09:00,366 --> 00:09:02,100
我这个数要展开两棵树

271
00:09:02,300 --> 00:09:04,366
一个是 C(N-1,)

272
00:09:04,566 --> 00:09:06,633
C(N-1, M-1) 然后这个是

273
00:09:07,566 --> 00:09:09,566
C(N-1, M) 是吧

274
00:09:09,733 --> 00:09:11,866
然后这里面 再展开两棵嘛

275
00:09:11,866 --> 00:09:13,500
是吧 这个是什么呢?

276
00:09:13,700 --> 00:09:16,833
C(N-2, M)

277
00:09:17,666 --> 00:09:19,133
C(N-2, M-2) 是吧

278
00:09:19,133 --> 00:09:20,366
然后在右边

279
00:09:20,466 --> 00:09:21,066
你可以理解吧

280
00:09:21,066 --> 00:09:23,433
就是每个分支展开两个

281
00:09:23,733 --> 00:09:25,166
这个就从上面我要算这个

282
00:09:25,166 --> 00:09:26,233
因为我要算这个值

283
00:09:26,233 --> 00:09:28,033
所以我必须要算下面两个值

284
00:09:28,133 --> 00:09:29,133
因为我要算这个值

285
00:09:29,133 --> 00:09:31,100
我就要再算下面两个

286
00:09:31,100 --> 00:09:32,466
它就从上面往下

287
00:09:32,466 --> 00:09:33,133
这叫 Top Down

288
00:09:33,133 --> 00:09:34,300
Bottom Up 就是反过来

289
00:09:34,300 --> 00:09:35,966
我就是到最后面

290
00:09:35,966 --> 00:09:38,433
然后我计算我知道这两个值

291
00:09:38,433 --> 00:09:39,266
然后我往上推

292
00:09:39,266 --> 00:09:41,300
往上推就是这个方向会反过来吗

293
00:09:41,300 --> 00:09:42,100
对吧

294
00:09:43,033 --> 00:09:45,233
那这个时候就用那个叫做

295
00:09:45,233 --> 00:09:46,266
数组的方式

296
00:09:46,266 --> 00:09:48,733
用数组的方式去记录, 这个 cache

297
00:09:48,733 --> 00:09:51,733
刚才那 cache 是计算机替我们去想吗

298
00:09:51,733 --> 00:09:53,166
现在我们是说自己想

299
00:09:53,233 --> 00:09:55,333
自己想的话我我就直接

300
00:09:55,333 --> 00:09:56,300
直接抄代码了

301
00:09:56,400 --> 00:09:59,866
我就不写了, 这个比较容易写错啊

302
00:09:59,933 --> 00:10:01,133
这个你看, 它就比较麻烦吗

303
00:10:01,266 --> 00:10:02,033
你看这个一样吗

304
00:10:02,033 --> 00:10:03,133
这3个边界条件

305
00:10:03,133 --> 00:10:04,733
那我这时候我就是要创建一个

306
00:10:04,733 --> 00:10:06,000
这个 Pascal Triangle

307
00:10:06,133 --> 00:10:07,400
杨辉三角形是吧

308
00:10:08,433 --> 00:10:13,000
14641 对我实际上就是要这个是

309
00:10:14,066 --> 00:10:16,033
就是左边这个列数是r

310
00:10:16,033 --> 00:10:17,633
加一个就是0到r

311
00:10:17,633 --> 00:10:19,333
然后这个行数就是0到N

312
00:10:19,333 --> 00:10:20,133
0到N

313
00:10:20,233 --> 00:10:22,833
我这个边界我要先要给它填的1吗

314
00:10:22,933 --> 00:10:24,566
对吧 这个边界我要先给它填

315
00:10:24,733 --> 00:10:27,133
这个就是边界填成1这个是 a[i][0]

316
00:10:27,233 --> 00:10:28,433
a[i][0]就是左边这个

317
00:10:28,633 --> 00:10:29,899
然后 a[0][i]

318
00:10:30,066 --> 00:10:31,133
a[0][i] 上边界第一行

319
00:10:31,166 --> 00:10:32,400
a[i][i] 就是这个右边这个 Boundary

320
00:10:32,433 --> 00:10:34,733
我在这个每从第2行开始

321
00:10:34,766 --> 00:10:36,333
从这一行开始, 然后

322
00:10:36,600 --> 00:10:37,600
依次往下计算

323
00:10:37,600 --> 00:10:39,200
就是我要算这个值 的时候是我

324
00:10:39,200 --> 00:10:40,633
可我可以取这个

325
00:10:41,133 --> 00:10:43,600
也上面和左边的这个值, 就是一样吗

326
00:10:43,600 --> 00:10:47,500
对吧然后再返回A[负1], -1就是最后一个

327
00:10:47,600 --> 00:10:49,833
-1就是最后一个元素吗

328
00:10:49,833 --> 00:10:51,933
对吧 A[负1]-1因为它是个二维数组

329
00:10:51,933 --> 00:10:53,433
A负1-1实际上就

330
00:10:53,600 --> 00:10:56,500
相当于你你要求的这个 [n][r]

331
00:10:56,500 --> 00:10:59,100
实际上是相当于 a[n][r]

332
00:10:59,333 --> 00:11:00,133
它没有递归

333
00:11:00,133 --> 00:11:01,333
它不需要自己调用自己

334
00:11:01,333 --> 00:11:02,266
虽然 时间

335
00:11:02,433 --> 00:11:04,866
和空间复杂度跟刚才那个(Top Down算法)是一样的

336
00:11:04,866 --> 00:11:06,733
就是都是N乘以R

337
00:11:06,733 --> 00:11:08,833
因为它有N乘以R个状态吗

338
00:11:08,833 --> 00:11:10,999
你要计算的值是N乘以R个

339
00:11:10,999 --> 00:11:13,166
你最多就计算N乘以R个, 对吧

340
00:11:13,166 --> 00:11:14,566
这个是空间复杂度

341
00:11:14,566 --> 00:11:16,233
时间复杂度都是两个

342
00:11:16,233 --> 00:11:16,966
两个循环

343
00:11:16,999 --> 00:11:18,799
但是这里面它没有自己调用自己

344
00:11:18,799 --> 00:11:22,266
它理论上它实现的话它会比较

345
00:11:22,366 --> 00:11:22,899
快一点

346
00:11:22,899 --> 00:11:24,599
就practically speaking这个

347
00:11:24,733 --> 00:11:27,466
这个 implementation/实现 它会快一点, 这个是

348
00:11:27,566 --> 00:11:29,633
就是非递归的方式

349
00:11:29,766 --> 00:11:31,699
那你可以想想我比如说我这个6

350
00:11:31,799 --> 00:11:34,366
我是不是要计算, 只需要上面两个值

351
00:11:34,366 --> 00:11:36,799
我根本就不需要前面的值是吧

352
00:11:37,033 --> 00:11:37,866
我计算这个4

353
00:11:37,866 --> 00:11:39,166
我是不是只需要这两个值

354
00:11:39,166 --> 00:11:41,466
我不需要前面三行的值对吧

355
00:11:41,466 --> 00:11:43,166
以此类推我再再多1行吗

356
00:11:43,166 --> 00:11:46,266
1,5,10,10,5,1是不是?

357
00:11:46,833 --> 00:11:48,999
我要计算这个10是不是只需要

358
00:11:49,166 --> 00:11:49,966
这一行的数据

359
00:11:49,966 --> 00:11:51,766
我不需要这边的数据了

360
00:11:51,766 --> 00:11:54,299
那我就没必要去存储这个2维的空间(数组)

361
00:11:54,366 --> 00:11:56,733
另外一种方法就是 把它

362
00:11:57,200 --> 00:11:59,600
压缩 把空间给压缩到 那个

363
00:11:59,833 --> 00:12:01,733
压缩到那个1维里面

364
00:12:01,733 --> 00:12:03,133
我再贴一下这代码

365
00:12:03,333 --> 00:12:05,000
你看这个前面是一样

366
00:12:05,000 --> 00:12:06,966
那这压缩到一维的话就是

367
00:12:07,133 --> 00:12:08,866
我只需要开这么大的空间

368
00:12:08,866 --> 00:12:11,400
然后 然后这个

369
00:12:11,800 --> 00:12:14,666
这个 a[i] = 1 实际上就是相当于我每次1行

370
00:12:14,666 --> 00:12:17,166
我先把最右边的1给设置了

371
00:12:17,166 --> 00:12:18,666
然后 我要怎么计算呢

372
00:12:18,666 --> 00:12:20,333
我要从右边往左边算

373
00:12:20,333 --> 00:12:22,200
为什么不能从左边往右边算呢?

374
00:12:22,200 --> 00:12:24,033
因为它会值会覆盖掉

375
00:12:24,166 --> 00:12:25,933
所以我就说我从这边算

376
00:12:25,933 --> 00:12:27,666
你看这本来现在是1,4,6,4,1

377
00:12:27,666 --> 00:12:29,000
假设现在这个状态

378
00:12:29,333 --> 00:12:29,466
对吧

379
00:12:29,466 --> 00:12:31,466
然后下一个状态是不是我要把这个

380
00:12:31,600 --> 00:12:32,933
后面添个1

381
00:12:33,166 --> 00:12:34,200
添个1对吧?

382
00:12:34,200 --> 00:12:35,366
添个1然后呢?

383
00:12:35,366 --> 00:12:36,566
这个值是等于这个值

384
00:12:36,566 --> 00:12:38,933
再加它就是等于5 对吧?

385
00:12:38,933 --> 00:12:40,200
这个值是等于这个值

386
00:12:40,200 --> 00:12:41,933
再加它是不是等于10

387
00:12:42,133 --> 00:12:43,633
然后这个值 (6) 是不是等于这个值 (6)

388
00:12:43,633 --> 00:12:45,333
再加它 (4) 是不是还是等于10

389
00:12:45,366 --> 00:12:46,733
这个值 (4) 是不是等于这个值 (4)

390
00:12:46,733 --> 00:12:48,433
再加它 (1) 就等于5, 对吧?

391
00:12:49,033 --> 00:12:50,533
是不是, 刚才是不是1

392
00:12:51,066 --> 00:12:52,366
是不是, 我看一下啊

393
00:12:53,833 --> 00:12:54,666
对吧, 对吧

394
00:12:54,666 --> 00:12:56,933
所以你看, 如果你从左边往右边的话

395
00:12:56,933 --> 00:12:57,800
它会有什么问题呢?

396
00:12:57,800 --> 00:13:00,533
你看我们试一下, 从左边往右边的话

397
00:13:00,566 --> 00:13:02,533
就是我这边加个1, 从左边往这边

398
00:13:02,533 --> 00:13:03,633
这边就是5

399
00:13:03,833 --> 00:13:06,233
然后这时候这是11, 就不对了吧, 是不是

400
00:13:06,233 --> 00:13:08,233
所以这时候是必须要从右边往左边

401
00:13:08,233 --> 00:13:09,933
所以它这个就是这边

402
00:13:09,933 --> 00:13:13,466
从右边就是i减1实际上就是这个值

403
00:13:13,666 --> 00:13:14,733
这个1我们设了吗

404
00:13:14,733 --> 00:13:16,433
它要从这个直往左边推

405
00:13:16,600 --> 00:13:18,333
等于它再加上它本身嘛

406
00:13:18,333 --> 00:13:19,266
就刚才我演示的

407
00:13:19,266 --> 00:13:21,266
那就等于相当于这个最右边的就是 a[i]

408
00:13:21,266 --> 00:13:23,466
那这种这个算法是最

409
00:13:23,866 --> 00:13:26,266
这个同样算法来说实现是最快的

410
00:13:26,266 --> 00:13:27,666
当然这个

411
00:13:27,833 --> 00:13:29,933
组合数还有其它的数学公式

412
00:13:30,033 --> 00:13:31,333
可能会更快一点

413
00:13:31,333 --> 00:13:33,366
但这就是我讲说这个数学公式

414
00:13:33,366 --> 00:13:35,200
刚才讲的那个C(N, M)=C(N-1,M)+C(N-1,M-1)

415
00:13:35,200 --> 00:13:36,133
就是这种

416
00:13:36,133 --> 00:13:38,400
就这个值等于上面两个值这种公式

417
00:13:38,400 --> 00:13:39,333
递推公式就是这个

418
00:13:39,333 --> 00:13:40,733
苹果可以选或者不选

419
00:13:40,933 --> 00:13:42,266
这个逻辑

420
00:13:42,400 --> 00:13:44,633
这种情况下面它是最快(优)因为它

421
00:13:45,200 --> 00:13:46,566
时间复杂度是一样的

422
00:13:46,566 --> 00:13:48,866
但是空间复杂度它只要用1维吗对吧

423
00:13:49,033 --> 00:13:49,766
它只要用一维

424
00:13:49,766 --> 00:13:51,166
所以它是最快/优的

425
00:13:51,300 --> 00:13:53,000
这个实际上它还是可以优化的

426
00:13:53,000 --> 00:13:54,766
因为 为什么呢, 我就不展开了

427
00:13:54,766 --> 00:13:56,600
因为时间关系, 这里面

428
00:13:56,933 --> 00:13:58,000
它N个嘛

429
00:13:58,000 --> 00:14:00,133
但实际上我是可以存成R

430
00:14:00,133 --> 00:14:01,366
N是大于R的对不对

431
00:14:01,366 --> 00:14:03,100
我实际上是可以用R

432
00:14:03,133 --> 00:14:03,866
用R的话

433
00:14:03,866 --> 00:14:06,400
你就得必须判断边界条件

434
00:14:06,400 --> 00:14:07,800
这边就写的会比较

435
00:14:07,866 --> 00:14:08,866
不是那么优美

436
00:14:08,866 --> 00:14:10,766
所以我们就把它尽可能1维的时候

437
00:14:10,766 --> 00:14:11,933
就把这个N给

438
00:14:12,166 --> 00:14:15,300
这个数组给N 比较大的这个方式去

439
00:14:15,366 --> 00:14:15,799
创建

440
00:14:15,799 --> 00:14:17,599
这样我就不用判断这个边界条件

441
00:14:17,599 --> 00:14:18,533
因为有可能

442
00:14:18,999 --> 00:14:22,366
你用r的话你这边a[i]的话它会越界

443
00:14:22,466 --> 00:14:24,399
今天就讲的这个 Combinations

444
00:14:24,399 --> 00:14:25,566
就是求组合数

445
00:14:25,566 --> 00:14:28,066
组合数就是N个苹果取M个

446
00:14:28,399 --> 00:14:31,466
然后那个的方法, 那计算它那个方法

447
00:14:31,466 --> 00:14:34,499
那在Python里面实际上有一个 from math

448
00:14:34,566 --> 00:14:37,733
你是可以 import 这个 comb, perm

449
00:14:37,766 --> 00:14:40,766
comb它实际上比如comb(3,2) 它就是相当等于

450
00:14:41,033 --> 00:14:42,799
等于3, 对吧

451
00:14:42,799 --> 00:14:44,999
然后perm(3,2)=6

452
00:14:45,699 --> 00:14:46,799
就是等于6

453
00:14:46,799 --> 00:14:48,099
就是它提供了这函数

454
00:14:48,099 --> 00:14:49,366
我们就不用去实现

455
00:14:49,366 --> 00:14:49,999
这个是这样

456
00:14:49,999 --> 00:14:52,633
那还有一个类似的就是 from itertools

457
00:14:53,233 --> 00:14:54,966
import combinations

458
00:14:55,699 --> 00:14:56,766
这我们以后会讲

459
00:14:56,766 --> 00:14:59,699
它是实际上是返回 combinations

460
00:14:59,699 --> 00:15:02,166
它这个和 permutations 这两个函数是返回

461
00:15:02,233 --> 00:15:04,899
那个实际上的组合

462
00:15:04,899 --> 00:15:06,966
它会列出这个组合或者排列

463
00:15:06,966 --> 00:15:08,133
但是它是

464
00:15:08,133 --> 00:15:09,599
不是说给定一个这个数

465
00:15:09,599 --> 00:15:11,433
比如说我举个简单例子

466
00:15:11,433 --> 00:15:14,166
combination([1,2,3],2)

467
00:15:14,166 --> 00:15:15,366
然后取两个

468
00:15:15,366 --> 00:15:17,933
那它实际上是一个 iterator

469
00:15:18,033 --> 00:15:19,733
迭代器 我把它转换列表

470
00:15:19,733 --> 00:15:20,899
它实际上是会等于

471
00:15:20,899 --> 00:15:21,733
等于什么呢

472
00:15:21,733 --> 00:15:22,933
等于(1,2)

473
00:15:23,133 --> 00:15:24,433
(1,3)这样子

474
00:15:24,433 --> 00:15:25,499
它实际上是相当于

475
00:15:25,599 --> 00:15:27,366
告诉你怎么组合了是吧

476
00:15:27,566 --> 00:15:29,699
这个然后排列也是一样的道理

477
00:15:29,699 --> 00:15:31,666
对哎 我们今天讲的就这个吧

478
00:15:31,766 --> 00:15:33,433
然后 有什么问题吗?

479
00:15:33,433 --> 00:15:36,566
嗯 没有 好 嗯 今天就这样 嗯 拜拜

