1
00:00:00,700 --> 00:00:01,733
大家好

2
00:00:01,733 --> 00:00:04,533
我们今天来讲一个矩阵转置的问题

3
00:00:04,533 --> 00:00:06,333
矩阵就是 Matrix

4
00:00:06,333 --> 00:00:06,900
这个矩阵

5
00:00:06,900 --> 00:00:08,733
就是跟那个数学里面的矩阵一样

6
00:00:08,733 --> 00:00:09,866
数学里面的矩阵

7
00:00:09,866 --> 00:00:10,766
就是两个竖号吗

8
00:00:10,766 --> 00:00:13,333
然后我们在那个Python里面

9
00:00:13,466 --> 00:00:14,666
是用一个多维数组

10
00:00:14,666 --> 00:00:16,566
就二维的数组来表示

11
00:00:16,766 --> 00:00:18,999
就是每个数组元素里面

12
00:00:18,999 --> 00:00:20,366
它就是一个一维的数组

13
00:00:20,399 --> 00:00:24,166
就是[1,2,3] 然后[4,5,6]对吧

14
00:00:24,299 --> 00:00:26,099
这个是2乘以3的矩阵

15
00:00:26,099 --> 00:00:27,633
就两行三列对吧

16
00:00:27,633 --> 00:00:30,399
那这个第一行就是

17
00:00:30,399 --> 00:00:32,833
数组的第一维的第一个元素

18
00:00:33,099 --> 00:00:34,933
那数组的第一维的第二个元素是

19
00:00:34,933 --> 00:00:35,766
就是第二行

20
00:00:35,799 --> 00:00:37,799
那比如说我们要访问这个5

21
00:00:37,799 --> 00:00:40,366
这个就是第二行的第二列

22
00:00:40,366 --> 00:00:41,166
那就是 a

23
00:00:41,366 --> 00:00:43,899
比如说这个 Matrix 是 m 的话

24
00:00:44,033 --> 00:00:47,899
就是 m[1][1] 就是第二行的第二列对吧

25
00:00:47,899 --> 00:00:48,533
如果说 我要访问

26
00:00:48,533 --> 00:00:50,999
这个6 就是第二行的第三列

27
00:00:50,999 --> 00:00:53,033
那第二行的第三列就是

28
00:00:53,366 --> 00:00:54,166
第二行第三列

29
00:00:54,166 --> 00:00:56,299
就是 m[1][2] 对吧

30
00:00:56,299 --> 00:00:57,999
我们数组下标是从0开始

31
00:00:57,999 --> 00:00:58,999
0就是第一个

32
00:00:58,999 --> 00:01:00,933
1就是第二个 以此类推

33
00:01:01,066 --> 00:01:02,633
我们假设 今天这个

34
00:01:02,766 --> 00:01:05,066
讲的这个数组转置的这个

35
00:01:05,299 --> 00:01:06,433
矩阵是规整的

36
00:01:06,599 --> 00:01:06,966
非规则的

37
00:01:06,966 --> 00:01:09,533
就比如说 你比如说第一行

38
00:01:09,633 --> 00:01:10,633
可能[1,2]这样

39
00:01:10,633 --> 00:01:11,333
[4,5,6]这样

40
00:01:11,333 --> 00:01:11,899
这样就不对了

41
00:01:11,899 --> 00:01:13,633
因为那缺了一个对吧

42
00:01:13,966 --> 00:01:16,466
这个因为在多维数组里面Python

43
00:01:16,466 --> 00:01:17,366
Python里面 多维数组

44
00:01:17,366 --> 00:01:20,466
那每行的这个是可以不一样的

45
00:01:20,466 --> 00:01:21,366
你可以这样表示

46
00:01:21,366 --> 00:01:23,933
但是在数学里面是不是没有意义的

47
00:01:23,933 --> 00:01:26,299
然后我们今天看这个Transpose

48
00:01:26,333 --> 00:01:28,899
Transpose是转置这 转置你看

49
00:01:29,066 --> 00:01:31,433
黄色的它就是从行就变成列了对吧

50
00:01:31,433 --> 00:01:33,066
第二行就变成第二列

51
00:01:33,299 --> 00:01:35,099
第三行就变成第三列对吧

52
00:01:35,099 --> 00:01:37,866
那你可以理解成就是比如说这个

53
00:01:37,866 --> 00:01:38,766
我们举一个例子

54
00:01:38,766 --> 00:01:39,733
这个18对吧

55
00:01:39,733 --> 00:01:42,166
18是从第3行的第一列

56
00:01:42,566 --> 00:01:44,633
第三行的第一列变成第一列的第三行

57
00:01:44,633 --> 00:01:44,966
对不对

58
00:01:44,966 --> 00:01:47,299
那这个-7是第三行的第二列

59
00:01:47,299 --> 00:01:49,833
变成第二列的第二行的第三列

60
00:01:50,000 --> 00:01:50,900
行和列就互换

61
00:01:50,900 --> 00:01:51,866
互换了一下是吧

62
00:01:51,999 --> 00:01:53,466
然后你看一下这个 Input

63
00:01:53,466 --> 00:01:56,099
然后你要 Output 的就是它转置之后的

64
00:01:56,199 --> 00:01:58,166
那你看现在是3乘以3对不对

65
00:01:58,166 --> 00:02:01,566
3乘以3那返回就3*3比如说是3行

66
00:02:01,566 --> 00:02:03,399
如果是不是行和列不一样的话

67
00:02:03,399 --> 00:02:04,599
比如说是3行

68
00:02:04,833 --> 00:02:05,633
三行两列

69
00:02:05,633 --> 00:02:07,866
那么它转置之后变成就是三列两行

70
00:02:08,033 --> 00:02:10,733
第一个事情要做的就是把它的行和列

71
00:02:10,899 --> 00:02:12,099
给它获取出来对吧

72
00:02:12,099 --> 00:02:14,433
行就是 len(A)

73
00:02:14,433 --> 00:02:16,999
列就是 len(A[0])

74
00:02:16,999 --> 00:02:19,033
取第一行来说吧

75
00:02:19,133 --> 00:02:21,999
那我们加一个判断 如果 rows 等于0的话

76
00:02:22,233 --> 00:02:24,433
就返回 a 好了

77
00:02:24,433 --> 00:02:26,433
if cols == 0

78
00:02:26,433 --> 00:02:27,833
就 return A

79
00:02:27,999 --> 00:02:31,166
rows == 0 是空的话 我们也可以写成 not rows

80
00:02:31,299 --> 00:02:33,166
为什么要获取这个行和列呢

81
00:02:33,166 --> 00:02:34,966
因为我获取这个行和列之后

82
00:02:34,966 --> 00:02:36,499
我就可以

83
00:02:36,799 --> 00:02:39,399
现在是 rows 乘以 cols 是吧

84
00:02:39,466 --> 00:02:42,233
我要把它变成 cols 乘以 rows 是吧

85
00:02:42,233 --> 00:02:44,266
那结果就是 反过来吗 对吧

86
00:02:44,399 --> 00:02:46,666
我比如说 ans 就等于

87
00:02:46,899 --> 00:02:48,366
create matrix

88
00:02:48,566 --> 00:02:50,833
然后是 cols * rows

89
00:02:50,833 --> 00:02:53,466
就是乘以 rows 是吧就是

90
00:02:53,799 --> 00:02:55,666
cols 行 rows 列

91
00:02:55,666 --> 00:02:58,833
初始化为0 那乘以0 乘以多少

92
00:02:59,633 --> 00:03:02,233
这里面是怎么写的这是列列就是 rows

93
00:03:02,666 --> 00:03:04,566
for _ in range

94
00:03:05,033 --> 00:03:07,166
for _ in range(cols)

95
00:03:07,466 --> 00:03:10,099
这里面指定的就是多少行

96
00:03:10,099 --> 00:03:11,833
多少行现在是变成cols

97
00:03:11,933 --> 00:03:14,266
原来三行两列就变成三列两行了对

98
00:03:14,266 --> 00:03:16,366
就这个意思 ans 现在我在遍例

99
00:03:16,366 --> 00:03:18,433
for r in range(rows)

100
00:03:18,766 --> 00:03:21,566
遍例原来的这个数组 A 的这个行

101
00:03:21,566 --> 00:03:23,533
for c in range(cols)

102
00:03:23,599 --> 00:03:26,033
for c in range(cols)

103
00:03:26,200 --> 00:03:26,833
for c in range(cols)

104
00:03:27,200 --> 00:03:29,566
然后我现在这个数组是ans

105
00:03:29,733 --> 00:03:32,233
设定现在的ans的这个 cr

106
00:03:32,233 --> 00:03:33,766
要等于原来的这个

107
00:03:33,966 --> 00:03:35,699
a 的这个 rc

108
00:03:35,733 --> 00:03:36,533
对吧

109
00:03:37,833 --> 00:03:40,799
原来的位置是[r][c] 第r行第c列

110
00:03:40,966 --> 00:03:43,200
现在要把它填到 第c行第r列

111
00:03:43,666 --> 00:03:45,233
第c行第r列

112
00:03:45,366 --> 00:03:46,633
然后我就 return ans

113
00:03:46,833 --> 00:03:47,533
这样应该是可以

114
00:03:47,533 --> 00:03:49,233
我们跑一下测试用例看看

115
00:03:49,233 --> 00:03:51,966
这测试用例过了 挺好

116
00:03:52,099 --> 00:03:53,333
哎这样子过了吧

117
00:03:53,333 --> 00:03:55,866
你看这样子过了 这个总体来说

118
00:03:55,866 --> 00:03:58,033
最精髓的一行就是这个对吧

119
00:03:58,200 --> 00:04:01,033
这13-14行就是遍例

120
00:04:01,033 --> 00:04:03,033
R就是这个行的这个坐标

121
00:04:03,500 --> 00:04:05,000
第几行第几列

122
00:04:05,000 --> 00:04:07,100
然后那原来的元素就是 A[r][c]

123
00:04:07,100 --> 00:04:08,466
A[r][c] 就是原来的这个元素

124
00:04:08,466 --> 00:04:09,700
那我要把它放到哪里呢

125
00:04:09,700 --> 00:04:10,866
变成 [c][r]

126
00:04:11,400 --> 00:04:13,566
对就大体是这样的 对然后嗯

127
00:04:13,633 --> 00:04:15,833
这个的时间复杂度就是  O(R*C)

128
00:04:15,833 --> 00:04:17,166
对吧 O(R*C)

129
00:04:17,166 --> 00:04:19,833
因为我们要遍例每个元素吗

130
00:04:19,899 --> 00:04:22,233
然后其实这个Python里面哈有一个比较

131
00:04:22,366 --> 00:04:25,200
投机取巧的方法 就其实就是叫做 zip

132
00:04:25,233 --> 00:04:27,200
我下面这个都不用了

133
00:04:27,466 --> 00:04:28,833
哎这样子过你看我们今天讲了

134
00:04:28,833 --> 00:04:29,966
其实讲了一堆废话

135
00:04:29,966 --> 00:04:31,833
其实这主要是这个 zip

136
00:04:31,966 --> 00:04:33,766
这 zip 什么意思呢我们

137
00:04:33,866 --> 00:04:36,200
我举个例子 很好理解

138
00:04:36,200 --> 00:04:38,800
就比如说 a 是等于[1,2,3]是吧

139
00:04:38,966 --> 00:04:39,900
b 是等于

140
00:04:40,733 --> 00:04:42,566
[4,5,6] 对

141
00:04:42,566 --> 00:04:45,400
zip 就是 拉链 对吧

142
00:04:45,400 --> 00:04:48,700
左边是[1,2,3]右边是[4,5,6]

143
00:04:48,700 --> 00:04:51,100
那合起来是什么 zip(a, b)

144
00:04:51,266 --> 00:04:52,966
那就变成[(1,4),(2,5),(3,6)]

145
00:04:52,966 --> 00:04:54,199
这个看的不太很清楚

146
00:04:54,200 --> 00:04:57,466
[(1,4),(2,5),(3,6)] 你看吧1,4 我一边取一个吗

147
00:04:57,466 --> 00:05:00,566
拉链左边右边(2,5),(3,6)

148
00:05:00,800 --> 00:05:02,933
那如果说我这边多一个元素的话

149
00:05:02,933 --> 00:05:04,366
它实际上是会按短的

150
00:05:04,366 --> 00:05:05,466
那多的就不要了吗

151
00:05:05,466 --> 00:05:06,766
就没有了吗对吧

152
00:05:06,966 --> 00:05:10,733
那你如果你要多的话它还有一个叫做 zip_longest

153
00:05:10,733 --> 00:05:12,300
(7, None) 多的按空填成 Tuple, 需要 from itertools import zip_longest

154
00:05:12,433 --> 00:05:15,600
星号 *a 是把它最外面的那个去掉

155
00:05:15,866 --> 00:05:17,800
它这个zip是一个返回一个迭代器

156
00:05:17,800 --> 00:05:18,366
Iterator

157
00:05:18,366 --> 00:05:21,966
就去掉最后面那个[1,2,3][4,5,6] 对

158
00:05:22,166 --> 00:05:23,299
那就 [(1,4), (2,5), (3,6)]

159
00:05:23,433 --> 00:05:25,833
刚才那个没有没有加新号的话

160
00:05:25,833 --> 00:05:27,033
实际上是多了

161
00:05:27,033 --> 00:05:29,066
多加了一层括号

162
00:05:29,066 --> 00:05:30,266
那我加了一个星号

163
00:05:30,266 --> 00:05:32,166
是把最外面的那括号给展开

164
00:05:32,300 --> 00:05:34,166
所以实际上就相当于[1,2,3][4,5,6]

165
00:05:34,200 --> 00:05:37,066
那这个就是用这个zip方法

166
00:05:37,233 --> 00:05:37,600
行

167
00:05:37,600 --> 00:05:39,533
那我们今天就讲到这 有什么问题吗

168
00:05:39,533 --> 00:05:41,966
嗯 没有 好 嗯 拜拜 拜拜

