1
00:00:00,566 --> 00:00:01,800
哎大家好

2
00:00:01,800 --> 00:00:04,600
今天我们讲第17课 深度优先

3
00:00:04,733 --> 00:00:06,433
我们在前面几节课里面

4
00:00:06,433 --> 00:00:08,333
有一节课讲到广度优先

5
00:00:08,333 --> 00:00:10,433
广度优先就是那个 BFS

6
00:00:10,633 --> 00:00:11,800
Breadth First Search

7
00:00:12,766 --> 00:00:15,666
然后 今天讲深度优先 DFS

8
00:00:16,033 --> 00:00:17,166
Depth First Search

9
00:00:17,833 --> 00:00:21,033
这个其实从字面上理解 BFS 就是

10
00:00:21,433 --> 00:00:22,266
Breadth 就是

11
00:00:22,266 --> 00:00:23,999
宽度吗 宽度优先

12
00:00:24,266 --> 00:00:25,966
Depth 就是深度优先

13
00:00:26,166 --> 00:00:27,633
然后我们之前

14
00:00:27,666 --> 00:00:29,066
就是讲一颗树

15
00:00:29,066 --> 00:00:30,466
比如说这颗树 这样子

16
00:00:30,466 --> 00:00:31,266
1

17
00:00:31,566 --> 00:00:32,233
二叉树吗

18
00:00:32,233 --> 00:00:35,199
二叉树就是一个节点

19
00:00:35,199 --> 00:00:37,366
最多有两个孩子对吧

20
00:00:37,366 --> 00:00:40,499
0 或者1个孩子或者0个孩子都可以

21
00:00:40,499 --> 00:00:42,066
然后没有孩子的就是

22
00:00:42,866 --> 00:00:45,466
叶子节点对吧 有孩子的就是

23
00:00:46,066 --> 00:00:46,699
父母节点

24
00:00:46,699 --> 00:00:47,933
然后没有父母节点呢

25
00:00:47,933 --> 00:00:49,866
就是这个1 就是根节点 叫 root

26
00:00:49,866 --> 00:00:52,299
你可以理解成 这棵树是倒着生长

27
00:00:52,299 --> 00:00:54,066
你看这是往这个方向看

28
00:00:54,299 --> 00:00:56,233
倒着生长 这个是树根

29
00:00:56,266 --> 00:00:57,133
然后这个是

30
00:00:57,666 --> 00:00:59,466
树枝 然后这个是节点

31
00:01:00,299 --> 00:01:02,099
然后这个是叶子节点 对吧

32
00:01:02,300 --> 00:01:02,966
广度优先

33
00:01:02,966 --> 00:01:06,700
我们当时讲 BFS 就是1 这个层次吗

34
00:01:06,700 --> 00:01:10,066
1 23 345 这样的顺序 是不是

35
00:01:10,566 --> 00:01:13,533
然后深度优先 它就不是这样 它就是1

36
00:01:13,933 --> 00:01:15,400
就是默认来说是指

37
00:01:15,533 --> 00:01:18,133
先往左叉树上面走

38
00:01:18,133 --> 00:01:18,766
走不动了

39
00:01:18,766 --> 00:01:20,700
然后我们就再回退 再回右叉树走

40
00:01:20,700 --> 00:01:23,033
所以它就1能往左走 对吧

41
00:01:23,233 --> 00:01:24,866
然后3走不动了 是吧

42
00:01:25,100 --> 00:01:27,133
然后回来往4走

43
00:01:27,600 --> 00:01:32,300
这有访问过 访问过 然后3 5 这样123435对吧

44
00:01:32,300 --> 00:01:34,166
如果这边有一颗树是

45
00:01:34,566 --> 00:01:35,500
比如说9

46
00:01:35,600 --> 00:01:37,200
然后这边再来一个10

47
00:01:37,800 --> 00:01:39,766
对吧然后 这边这个11

48
00:01:40,533 --> 00:01:41,700
然后这边一个12

49
00:01:41,733 --> 00:01:43,633
那么它的顺序就是1

50
00:01:44,133 --> 00:01:49,566
234 对吧 然后 3,9,10,11,12,5

51
00:01:50,100 --> 00:01:51,533
这就是深度优先吗

52
00:01:51,533 --> 00:01:52,333
对么

53
00:01:52,433 --> 00:01:54,866
广度优先和深度优先就是用于

54
00:01:54,866 --> 00:01:55,700
搜索比较多

55
00:01:55,700 --> 00:01:57,400
它们是一个搜索的这个

56
00:01:57,800 --> 00:01:59,300
这个方式吗

57
00:01:59,633 --> 00:02:02,466
那我们回顾一下这个广度优先

58
00:02:02,466 --> 00:02:03,733
就是你这样层数

59
00:02:04,300 --> 00:02:05,100
这么走

60
00:02:05,333 --> 00:02:08,133
那么它每次都是把这一层的节点

61
00:02:08,133 --> 00:02:08,733
先访问完

62
00:02:08,733 --> 00:02:10,200
再访问下一层的节点

63
00:02:10,333 --> 00:02:12,433
那么这时候我如果访问到这个

64
00:02:12,600 --> 00:02:13,466
这个节点的时候

65
00:02:13,466 --> 00:02:15,833
那么它肯定是从根节点到它

66
00:02:16,266 --> 00:02:18,333
最短距离对不对

67
00:02:18,333 --> 00:02:20,133
可以这么理解吧 因为我是一层一层吗

68
00:02:20,133 --> 00:02:21,233
我就相当于说

69
00:02:21,500 --> 00:02:24,100
我1的时候我层数为1

70
00:02:24,100 --> 00:02:26,033
我就往这个2 3走

71
00:02:26,300 --> 00:02:28,900
然后2 3都节点距离都完了吗

72
00:02:28,900 --> 00:02:30,666
它距离是从小到大

73
00:02:30,833 --> 00:02:33,000
对吧 然后这 distance 是2

74
00:02:33,466 --> 00:02:34,233
2吗对吧

75
00:02:34,233 --> 00:02:35,700
那我访问到这个节点

76
00:02:35,700 --> 00:02:36,966
我一旦访问到这个节点

77
00:02:36,966 --> 00:02:39,133
那么这个节点就是从

78
00:02:39,600 --> 00:02:41,500
根结点到它的最短距离

79
00:02:41,500 --> 00:02:42,700
但深度优先不一定吧

80
00:02:42,700 --> 00:02:45,133
如果我比如说 我这边有个3对吧

81
00:02:45,133 --> 00:02:46,400
我要访问到3, 1

82
00:02:46,466 --> 00:02:48,233
那我深度优先我很快就访问到3

83
00:02:48,233 --> 00:02:50,100
但是这时候3并不是最短距离

84
00:02:50,100 --> 00:02:51,200
因为这边你看

85
00:02:51,400 --> 00:02:52,466
右叉数上面有个3

86
00:02:52,466 --> 00:02:54,100
它的距离更短 比这边更短

87
00:02:54,766 --> 00:02:57,366
对不对 那如果是广度优先就是123

88
00:02:57,366 --> 00:02:59,400
我这个是我就立马找到最短的这个3

89
00:02:59,633 --> 00:03:00,666
但如果是深度优先

90
00:03:00,666 --> 00:03:02,400
我会找到比较长的那个3

91
00:03:02,433 --> 00:03:04,666
对吧 就是有个区别就是 它的

92
00:03:04,933 --> 00:03:06,000
顺序不一样

93
00:03:06,233 --> 00:03:07,266
那我们今天就是

94
00:03:07,466 --> 00:03:10,333
深度优先我们就来刷一题

95
00:03:10,333 --> 00:03:11,666
然后我们就可以理解一下

96
00:03:11,666 --> 00:03:12,499
什么叫深度优先

97
00:03:12,599 --> 00:03:13,733
一般来说是我们

98
00:03:13,733 --> 00:03:15,466
我能往一个方向走

99
00:03:15,466 --> 00:03:16,933
就一直往那走

100
00:03:16,933 --> 00:03:18,099
直到撞墙

101
00:03:18,299 --> 00:03:20,699
或者没有什么办法 继续往前走

102
00:03:20,699 --> 00:03:23,099
然后我再回退 再找别的

103
00:03:23,299 --> 00:03:26,499
再回去 找别的出路

104
00:03:27,133 --> 00:03:29,333
对吧 我们来看一下这题

105
00:03:29,799 --> 00:03:31,499
这题就是跳跃游戏

106
00:03:31,499 --> 00:03:33,166
它就是说我给一个数组

107
00:03:33,166 --> 00:03:34,333
给一个数组这个

108
00:03:34,399 --> 00:03:36,699
这个数组 那么我的开始位置是 第五个

109
00:03:36,699 --> 00:03:39,533
就是其实是第六个01234

110
00:03:39,999 --> 00:03:43,699
345012345就在1的这个位置对吧

111
00:03:44,833 --> 00:03:47,266
然后我们要跳到它的

112
00:03:47,933 --> 00:03:50,633
它就问能不能跳到0的位置

113
00:03:50,633 --> 00:03:52,099
对吧 就是你在

114
00:03:52,199 --> 00:03:53,333
比如说在5的位置

115
00:03:53,333 --> 00:03:55,533
你可以往前跳1格或往后跳一个

116
00:03:55,599 --> 00:03:58,666
如果你在4的位置 在第一个4对吧

117
00:03:58,666 --> 00:04:02,133
你可以往前跳4格 或者往后跳4格

118
00:04:03,333 --> 00:04:04,399
然后出界

119
00:04:04,466 --> 00:04:05,399
出界当然不行吗

120
00:04:05,399 --> 00:04:08,033
你看嘛它是说 when you are at index i 对吧

121
00:04:08,033 --> 00:04:10,133
你在 index i 的时候你可以

122
00:04:10,466 --> 00:04:11,899
你可以往前跳到 i

123
00:04:12,999 --> 00:04:16,599
i 加 arr[i] 它的值 或者是往后退

124
00:04:16,599 --> 00:04:18,699
对吧 但你看看能不能够往前

125
00:04:19,166 --> 00:04:22,833
就是能不能找到这个任何一个 index

126
00:04:22,833 --> 00:04:25,466
它没有说是哪个目标 任何一个 index

127
00:04:25,599 --> 00:04:26,533
是0吗 对吧

128
00:04:26,533 --> 00:04:28,466
那这题是可以用广度优先

129
00:04:28,466 --> 00:04:29,266
可以用深度优先

130
00:04:29,266 --> 00:04:30,566
那我们今天用广度优先

131
00:04:30,799 --> 00:04:32,533
下节课我们来讲深度优先

132
00:04:32,933 --> 00:04:34,233
你看

133
00:04:34,699 --> 00:04:35,999
它就说这个是 True 吗

134
00:04:35,999 --> 00:04:37,233
为什么呢 因为你看

135
00:04:37,599 --> 00:04:39,666
all possible ways to reach index 3

136
00:04:39,866 --> 00:04:42,166
zero one two three 就 0 是 index 3

137
00:04:42,299 --> 00:04:44,466
那就是 index 5到 index 4吗

138
00:04:44,466 --> 00:04:45,266
比如说你1

139
00:04:45,266 --> 00:04:46,099
你可以往后退一格

140
00:04:46,099 --> 00:04:48,899
就在这3 跑到3 那你可以走3步

141
00:04:48,899 --> 00:04:50,699
你可以往左边 或 往右边走

142
00:04:50,999 --> 00:04:52,566
那你可以往左边走 就是

143
00:04:53,033 --> 00:04:55,533
跑到2的位置 然后再往前走两步 对吧

144
00:04:55,566 --> 00:04:56,566
嗯是不是

145
00:04:56,566 --> 00:04:58,433
那我这时候我就深度优先

146
00:04:58,433 --> 00:04:59,966
一般 DFS 我就该这么写

147
00:04:59,966 --> 00:05:02,133
def DFS

148
00:05:02,133 --> 00:05:03,233
我需要一个参数是

149
00:05:03,233 --> 00:05:04,699
现在 在哪一个 index

150
00:05:04,699 --> 00:05:07,099
那我就哪一个 index 就是比如说 我们 i

151
00:05:07,099 --> 00:05:09,799
这里有个问题 就是我往前跳一格

152
00:05:09,800 --> 00:05:11,500
等我往后再跳回这格的话

153
00:05:11,500 --> 00:05:12,600
我们需要判断是不是

154
00:05:12,600 --> 00:05:13,700
已经重复走了

155
00:05:13,700 --> 00:05:14,900
对不对 是不是

156
00:05:14,900 --> 00:05:15,833
你想

157
00:05:15,833 --> 00:05:17,700
我如果往前走一步 再往后走一步

158
00:05:17,700 --> 00:05:18,500
如果

159
00:05:18,733 --> 00:05:19,466
往后走一步

160
00:05:19,466 --> 00:05:20,933
再往前走一步 再往后走一步

161
00:05:20,933 --> 00:05:22,100
它就循环了吗

162
00:05:22,100 --> 00:05:22,766
那我走过了

163
00:05:22,766 --> 00:05:24,600
我是不是不需要再走

164
00:05:25,166 --> 00:05:27,233
对 那我就要用 那个

165
00:05:27,333 --> 00:05:28,899
哈稀表 我们之前讲过吗

166
00:05:28,899 --> 00:05:30,599
seen 就是那个 set 对吧

167
00:05:30,633 --> 00:05:32,366
set 就是

168
00:05:32,666 --> 00:05:33,733
我们就先 seen

169
00:05:33,733 --> 00:05:35,266
然后默认它是一个 set

170
00:05:35,266 --> 00:05:38,399
那你看我这 i index 如果 i index 小于0

171
00:05:38,899 --> 00:05:40,399
就是跳出左边边界了

172
00:05:40,433 --> 00:05:43,866
或者跳出右边边界就是 len(arr)

173
00:05:44,099 --> 00:05:45,666
那么我就返回 False

174
00:05:46,166 --> 00:05:46,966
不能这么跳

175
00:05:47,299 --> 00:05:48,533
那如果没有, 在边界里面

176
00:05:48,533 --> 00:05:49,999
我要判断它是不是已经

177
00:05:50,366 --> 00:05:52,233
是0吗 那我就可以判断如果

178
00:05:52,966 --> 00:05:55,466
arr[i] 它等于0了 那我就返回 True 是不是

179
00:05:57,199 --> 00:05:59,066
那如果不返回 True 那我还同时

180
00:05:59,066 --> 00:06:00,699
同时我还要判断说如果 i

181
00:06:01,266 --> 00:06:03,099
已经走过了吗 对吧

182
00:06:03,366 --> 00:06:04,833
就以前走过了 那我还

183
00:06:05,133 --> 00:06:06,466
我就返回 False 对不对

184
00:06:06,766 --> 00:06:07,833
那否则的话 我

185
00:06:07,833 --> 00:06:09,766
我现在已经在 i 的我是不是要记录

186
00:06:09,766 --> 00:06:11,400
记录一下 seen.add(i)

187
00:06:11,400 --> 00:06:14,233
我已经访问过这个位置

188
00:06:14,233 --> 00:06:16,233
我先把它记到这个本子里面

189
00:06:16,233 --> 00:06:17,700
这个seen就是个本子

190
00:06:17,700 --> 00:06:19,333
然后我这时候回调 DFS

191
00:06:19,333 --> 00:06:21,333
DFS 就是我们调用的这个

192
00:06:21,500 --> 00:06:23,266
这个 DFS 这个

193
00:06:23,433 --> 00:06:25,266
递归函数 我调用本身吗

194
00:06:25,266 --> 00:06:27,400
对吧 那这时候我要调用什么了 i

195
00:06:28,366 --> 00:06:32,033
减去 往左走就 arr[i] 嘛 对吧

196
00:06:32,400 --> 00:06:34,833
那这时候 我还是看到这个seen 给它 就是

197
00:06:35,333 --> 00:06:39,466
哪里走过了 或者 i 加 arr[i], seen

198
00:06:40,266 --> 00:06:41,766
然后 我这时候我

199
00:06:42,200 --> 00:06:45,000
调用了它就是 从start的位置开始

200
00:06:45,000 --> 00:06:45,933
刚开始这个

201
00:06:46,400 --> 00:06:48,300
seen是一个空的本子 对吧

202
00:06:48,366 --> 00:06:49,866
这样子

203
00:06:50,266 --> 00:06:51,066
这样子

204
00:06:51,333 --> 00:06:53,833
我们先试一下 跑一下看对不对

205
00:06:54,199 --> 00:06:54,866
哎过了

206
00:06:54,866 --> 00:06:57,066
你看就过了 这个是 这样子

207
00:06:57,199 --> 00:06:58,899
关键就是 在这里调用

208
00:06:58,966 --> 00:07:02,466
DFS 就是 我在第i个位置的时候

209
00:07:02,466 --> 00:07:03,899
我现在是在 i 的位置

210
00:07:03,900 --> 00:07:05,666
我在 这个i的位置 我是不是有两条路

211
00:07:05,666 --> 00:07:06,966
比如说是在这里

212
00:07:07,133 --> 00:07:09,266
就是我现在在第i个位置 对不对

213
00:07:09,333 --> 00:07:10,166
它下一步

214
00:07:10,233 --> 00:07:12,133
它的节点 其实上就是二叉树

215
00:07:12,133 --> 00:07:13,799
它可以往左走对吧

216
00:07:14,033 --> 00:07:16,366
它的左节点 就 i 减去

217
00:07:16,833 --> 00:07:17,999
arr[i]

218
00:07:18,066 --> 00:07:20,633
对吧 它的那个位置吗 我就可以往左跳

219
00:07:20,766 --> 00:07:21,666
就是往左跳

220
00:07:21,966 --> 00:07:23,033
那往右跳呢

221
00:07:23,366 --> 00:07:26,366
就是每个节点都可以展开两个吗

222
00:07:26,433 --> 00:07:28,566
对吧每个节点都可以展开两个 arr[i]

223
00:07:28,866 --> 00:07:30,266
这个是往右跳对吧

224
00:07:30,433 --> 00:07:31,599
当然 我们要判断重复

225
00:07:31,599 --> 00:07:33,166
因为如果你不判断重复的话

226
00:07:33,166 --> 00:07:33,799
都是1的话

227
00:07:33,799 --> 00:07:34,633
你往右跳

228
00:07:34,633 --> 00:07:36,033
然后你又可以往左跳

229
00:07:36,199 --> 00:07:37,433
你可以想象 比如说我

230
00:07:37,533 --> 00:07:39,733
我是一个这么样的数组 就是 arr

231
00:07:39,733 --> 00:07:41,399
arr 等于每个都是1 好了

232
00:07:41,399 --> 00:07:42,199
对吧

233
00:07:42,366 --> 00:07:44,399
那我比如说 我告诉你 我说要从

234
00:07:44,533 --> 00:07:45,499
这格开始跳

235
00:07:45,533 --> 00:07:46,599
第三格开始跳

236
00:07:46,599 --> 00:07:48,199
那么我可以往右跳到1

237
00:07:48,199 --> 00:07:49,133
又可以往左跳

238
00:07:49,399 --> 00:07:51,333
又跳到1 又往右跳, 跳到1

239
00:07:51,533 --> 00:07:54,033
这里面要控制这个的就是 set, seen

240
00:07:54,033 --> 00:07:55,099
就一个 set

241
00:07:55,233 --> 00:07:57,499
你可以认为是一个 checklist

242
00:07:57,500 --> 00:08:00,500
打勾嘛 check list 哈稀表

243
00:08:00,666 --> 00:08:01,499
一个记事本

244
00:08:01,533 --> 00:08:02,066
我访问了

245
00:08:02,066 --> 00:08:03,699
过了这个位置 我就把它打个勾

246
00:08:03,699 --> 00:08:05,099
哦我这个位置已经访问过了

247
00:08:05,099 --> 00:08:06,733
下回我就知道

248
00:08:06,933 --> 00:08:09,233
你下回你看吧 这个 i in seen

249
00:08:09,233 --> 00:08:11,533
我们就知道访问过 我们就返回 False 对吧

250
00:08:11,533 --> 00:08:13,033
那这时候你看它两个节点

251
00:08:13,299 --> 00:08:14,533
那它什么时候会结束呢

252
00:08:14,533 --> 00:08:17,766
它跑出边界的时候 它就告诉你说 False

253
00:08:17,933 --> 00:08:21,366
对吧 或者达到目的是0就返回True

254
00:08:21,633 --> 00:08:22,933
或者已经跑过了

255
00:08:23,433 --> 00:08:24,199
这点很重要

256
00:08:24,199 --> 00:08:25,833
如果我不加这个的话就

257
00:08:25,966 --> 00:08:28,033
就会一直出错吗

258
00:08:28,033 --> 00:08:29,166
因为死循环

259
00:08:29,566 --> 00:08:30,966
对吧 我如果不加这个 seen

260
00:08:30,966 --> 00:08:32,699
你看它就会说 Time Limited

261
00:08:33,833 --> 00:08:35,866
因为它就刚才那个过程吗

262
00:08:35,866 --> 00:08:37,166
就是不停的在(来回)跳

263
00:08:37,166 --> 00:08:38,366
你看吧它 它就说

264
00:08:38,666 --> 00:08:40,266
已经超过了最大的

265
00:08:40,266 --> 00:08:41,266
递归深度吗

266
00:08:41,266 --> 00:08:42,899
那这时候我们其实还可以记忆

267
00:08:42,899 --> 00:08:43,833
就是说如果

268
00:08:44,066 --> 00:08:45,666
之前 我们已经知道说

269
00:08:45,666 --> 00:08:47,266
跳到第五格的时候

270
00:08:47,433 --> 00:08:49,799
在第五格已经不可能

271
00:08:49,800 --> 00:08:51,566
找到终点 或者 已经可以找到终点

272
00:08:51,566 --> 00:08:53,300
那我下回再回来的时候

273
00:08:53,300 --> 00:08:54,266
我是不是可以说

274
00:08:54,433 --> 00:08:56,833
就不用再重新去算了 对不对

275
00:08:57,533 --> 00:08:58,799
是不是这样因为它有可能

276
00:08:58,933 --> 00:09:01,733
重复嘛 就是我现在要访问第五格

277
00:09:02,266 --> 00:09:04,033
我访问 等我算出来结果

278
00:09:04,033 --> 00:09:06,233
第五格我可以访问或者不可以访问

279
00:09:06,366 --> 00:09:09,066
一会之后 我可能通过别的节点

280
00:09:09,266 --> 00:09:09,933
比如第6格

281
00:09:09,933 --> 00:09:12,000
第7格 第8格 都会跑到第5格

282
00:09:12,000 --> 00:09:13,733
那么 这时候 我不用再重复去走

283
00:09:13,733 --> 00:09:14,833
第5格走过的路

284
00:09:14,833 --> 00:09:15,533
对不对

285
00:09:15,533 --> 00:09:17,533
那这时候我就可以有一个记忆

286
00:09:17,633 --> 00:09:18,666
记忆的 memo

287
00:09:18,666 --> 00:09:20,533
我把它改成一个 memo

288
00:09:20,833 --> 00:09:23,433
然后我可以给它一个这个 dictionary 的

289
00:09:23,466 --> 00:09:26,166
字典 key value pairs 这种

290
00:09:26,433 --> 00:09:27,666
然后我可以在这里面加

291
00:09:28,766 --> 00:09:30,233
我可以在这里面加 我可以说

292
00:09:30,433 --> 00:09:32,100
如果 i in memo

293
00:09:32,533 --> 00:09:35,266
那我就跟 return 我已经访问过了

294
00:09:35,933 --> 00:09:36,366
memo 吗

295
00:09:36,366 --> 00:09:38,333
就是像记事本一样 我就把它返回结果

296
00:09:38,333 --> 00:09:40,933
然后这时候 我在这里面 我要说

297
00:09:41,366 --> 00:09:42,833
memo i 等于它

298
00:09:42,833 --> 00:09:43,600
然后我

299
00:09:43,600 --> 00:09:45,566
我记下来嘛 这个结果先记下来

300
00:09:45,566 --> 00:09:47,133
然后我再 return 这个 memo[i]

301
00:09:47,733 --> 00:09:48,533
是吧

302
00:09:48,566 --> 00:09:51,600
在理论上应该会比这个443毫秒要快吗

303
00:09:51,600 --> 00:09:54,600
理论上啊, 不一定

304
00:09:54,833 --> 00:09:55,666
哎

305
00:09:56,033 --> 00:09:57,533
哎呦哎呦 不对

306
00:09:57,533 --> 00:10:00,166
更慢了好吧 好吧 这个可能是

307
00:10:00,500 --> 00:10:01,666
跟测试用例有关

308
00:10:01,666 --> 00:10:02,133
不一定

309
00:10:02,133 --> 00:10:04,266
你看它 它会跳跃的 所以不一定

310
00:10:04,266 --> 00:10:06,100
但是 这个实际上是一个优化了

311
00:10:06,266 --> 00:10:08,933
在这里 它的测试数据可能不太明显

312
00:10:09,233 --> 00:10:10,066
看不太出来

313
00:10:10,466 --> 00:10:11,266
嗯

314
00:10:11,466 --> 00:10:14,166
这个就是深度优先吧 这个深度优先

315
00:10:14,300 --> 00:10:16,666
我们一般是用递归的方式去

316
00:10:16,666 --> 00:10:18,666
去实现就比较简单

317
00:10:18,666 --> 00:10:19,700
它这实际上也可以

318
00:10:19,700 --> 00:10:21,033
用堆栈

319
00:10:21,766 --> 00:10:23,933
就递归 它会有一个堆栈对吧

320
00:10:23,933 --> 00:10:26,033
然后你这个堆栈 你可以自己维护

321
00:10:26,033 --> 00:10:27,233
像那个广度优先

322
00:10:27,233 --> 00:10:28,766
你创建一个队列

323
00:10:28,766 --> 00:10:30,900
或者堆栈 对吧 你队列是广度优先

324
00:10:30,900 --> 00:10:33,566
如果你堆栈的话 你就是相当于有点像

325
00:10:33,866 --> 00:10:35,400
这个深度优先了

326
00:10:35,400 --> 00:10:37,166
那我们这时候是用递归

327
00:10:37,166 --> 00:10:38,366
就是我们自己

328
00:10:38,466 --> 00:10:41,266
你看吧我这里定义了一个 DFS 函数

329
00:10:41,266 --> 00:10:43,033
我调用这个 DFS 函数

330
00:10:43,033 --> 00:10:44,433
因为计算机已经知道了

331
00:10:44,433 --> 00:10:45,333
我要调用自己

332
00:10:45,566 --> 00:10:46,233
自己调用自己

333
00:10:46,233 --> 00:10:48,033
我们在第一节课里面讲过递归

334
00:10:48,133 --> 00:10:49,433
递归就自己调用自己

335
00:10:49,433 --> 00:10:51,066
我们算那个

336
00:10:51,200 --> 00:10:52,633
阶乘对吧 记得不

337
00:10:52,666 --> 00:10:54,766
F(N) 等于 F(N) 

338
00:10:54,800 --> 00:10:56,500
F(N-1)*N 嘛对吧

339
00:10:56,800 --> 00:10:58,900
这个就是 可以往左走

340
00:10:58,900 --> 00:11:01,333
每个节点 我就是往左走 或者 往右跳

341
00:11:01,500 --> 00:11:03,700
往左跳 或者 往右跳 对不对

342
00:11:04,100 --> 00:11:05,333
那这里它有个好处

343
00:11:05,333 --> 00:11:07,033
就是说如果往左跳的话

344
00:11:07,066 --> 00:11:08,600
已经返回是 True 的话

345
00:11:08,700 --> 00:11:10,366
如果这一次 True 的话

346
00:11:10,366 --> 00:11:12,766
那计算机它就不用去往右跳了

347
00:11:13,133 --> 00:11:15,633
就是说 OR 吗 这个我们讲过 OR

348
00:11:15,800 --> 00:11:18,633
两者只要有一个是为真 为 True 的话

349
00:11:18,633 --> 00:11:20,333
就是返回 True

350
00:11:20,333 --> 00:11:22,800
AND 就是两者必须要都是 TRUE 的时候才是 TRUE

351
00:11:22,800 --> 00:11:24,500
对不对

352
00:11:24,500 --> 00:11:26,200
OR就是两个只要有一个是True

353
00:11:26,200 --> 00:11:29,000
那么我在这里边的时候 我要往左跳

354
00:11:29,300 --> 00:11:32,766
就能够 我知道往左跳 就能够

355
00:11:32,766 --> 00:11:33,900
返回到目的地

356
00:11:34,566 --> 00:11:36,366
那我就不用往再往右跳了吧

357
00:11:36,366 --> 00:11:37,900
对吧因为我往左跳已经可以

358
00:11:37,900 --> 00:11:39,266
它只要返回对和不对

359
00:11:39,266 --> 00:11:40,066
对不对那

360
00:11:40,966 --> 00:11:42,200
基本上这个就是讲深度优先

361
00:11:42,200 --> 00:11:43,566
来我们看一下之前

362
00:11:43,966 --> 00:11:45,066
给小孩子讲

363
00:11:45,066 --> 00:11:46,866
就是讲同样一节课的这个

364
00:11:47,366 --> 00:11:49,000
这个深度优先

365
00:11:49,000 --> 00:11:51,266
基本上是一样的写法吧

366
00:11:51,266 --> 00:11:52,466
有点不太一样这个

367
00:11:52,466 --> 00:11:54,366
但是基本上原理都是一样对吧

368
00:11:54,366 --> 00:11:56,933
这个是有一个 for 循环 往左跳往右跳

369
00:11:57,200 --> 00:11:58,700
实际上都是差不多

370
00:11:58,700 --> 00:12:00,333
但是你看吧 这个是 DFS

371
00:12:00,566 --> 00:12:02,333
我们这时候用一个 seen

372
00:12:02,800 --> 00:12:04,066
加上然后退出

373
00:12:04,066 --> 00:12:05,833
我们实际上是在这里面

374
00:12:06,066 --> 00:12:07,866
只是一次性用的 所以就

375
00:12:08,000 --> 00:12:10,133
嗯就无所谓了 在这里面

376
00:12:10,433 --> 00:12:12,933
行今天就讲这 有什么问题吗

377
00:12:12,933 --> 00:12:14,833
没有

378
00:12:14,833 --> 00:12:17,099
今天就这样 拜拜 拜拜

