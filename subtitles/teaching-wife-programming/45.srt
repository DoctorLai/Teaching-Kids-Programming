1
00:00:00,400 --> 00:00:01,200
Hi! 大家好

2
00:00:01,200 --> 00:00:04,900
今天我们来刷一题 1926题 Leetcode 1926题

3
00:00:05,166 --> 00:00:06,433
给定一个迷宫

4
00:00:06,433 --> 00:00:08,833
然后我们要找出这个离

5
00:00:09,066 --> 00:00:11,200
离入口最近的那个出口

6
00:00:11,500 --> 00:00:13,866
是吧 就是给定一个迷宫 你看这有墙

7
00:00:13,866 --> 00:00:15,200
有空的这个格子

8
00:00:15,300 --> 00:00:15,766
然后给

9
00:00:15,833 --> 00:00:18,466
给它最近的要找出它最近的那个出口

10
00:00:18,533 --> 00:00:19,833
你看 它有3个出口

11
00:00:19,833 --> 00:00:21,600
这边一个 两个 三个

12
00:00:21,900 --> 00:00:24,133
然后我们比如说要找最近的出口

13
00:00:24,133 --> 00:00:25,833
那它就是这个吧

14
00:00:26,200 --> 00:00:28,366
最上面那个 那它就是返回

15
00:00:28,633 --> 00:00:30,100
距离为1 对吧

16
00:00:30,366 --> 00:00:31,566
那如果是

17
00:00:31,566 --> 00:00:33,533
比如说这个, 这个它实际上有2个出口

18
00:00:33,533 --> 00:00:35,966
但是你的入口是跟出口一样

19
00:00:35,966 --> 00:00:37,933
那你就不能往回走嘛, 对吧

20
00:00:37,933 --> 00:00:40,233
你给一个入口, 你不能认为它是个出口

21
00:00:40,233 --> 00:00:41,133
那它只能

22
00:00:41,366 --> 00:00:44,000
找出最右边那个出口, 就是一二对吧

23
00:00:44,033 --> 00:00:45,400
那如果没有

24
00:00:45,766 --> 00:00:46,700
没有出口的话

25
00:00:46,700 --> 00:00:48,400
比如说你只给了一个入口

26
00:00:48,400 --> 00:00:49,300
你没有出口的话

27
00:00:49,300 --> 00:00:50,700
那么这时候就返回-1

28
00:00:50,766 --> 00:00:52,366
对吧, 这就是说一个迷宫嘛

29
00:00:52,366 --> 00:00:53,233
迷宫有墙

30
00:00:53,700 --> 00:00:55,800
有空的格子

31
00:00:56,133 --> 00:00:57,900
然后我们要找出离

32
00:00:57,966 --> 00:01:00,533
给定这个入口最近的那个出口

33
00:01:00,566 --> 00:01:02,900
对吧, 就这么一个简单的题目

34
00:01:03,500 --> 00:01:04,533
那我们这个题目

35
00:01:04,566 --> 00:01:06,700
实际上是可以把它认为是一个图

36
00:01:06,800 --> 00:01:08,266
一个无向图

37
00:01:08,466 --> 00:01:11,466
无向无权图就 怎么说呢

38
00:01:11,466 --> 00:01:13,100
就是你想我这一步

39
00:01:13,100 --> 00:01:14,766
我给定一个这个格子

40
00:01:14,766 --> 00:01:17,066
每个格子都是可以认为是一个节点

41
00:01:17,366 --> 00:01:20,700
那它可以有最多有4个

42
00:01:20,700 --> 00:01:22,166
邻居邻居节点对吧

43
00:01:22,166 --> 00:01:24,499
它理论上来说它是不是可以走4

44
00:01:24,500 --> 00:01:25,100
四个方向

45
00:01:25,100 --> 00:01:26,033
上下左右

46
00:01:26,133 --> 00:01:26,966
只要不是墙的话

47
00:01:26,966 --> 00:01:29,100
那我每走上下左右

48
00:01:29,100 --> 00:01:31,800
那它的上下左右四个点的那个

49
00:01:31,900 --> 00:01:33,333
距离都是1嘛

50
00:01:33,333 --> 00:01:34,666
对吧, 就是我走

51
00:01:34,666 --> 00:01:36,733
我走到上面跟走到下面它的Cost

52
00:01:36,733 --> 00:01:38,333
它的那个 distance 都是1

53
00:01:38,366 --> 00:01:39,966
那这个就是无权图

54
00:01:39,966 --> 00:01:40,600
无权图

55
00:01:40,600 --> 00:01:43,533
我们之前讲, 在那个图的那一节讲过

56
00:01:43,533 --> 00:01:45,500
就什么是有权图, 什么是无权图

57
00:01:45,633 --> 00:01:48,500
然后这样的话我们就可以

58
00:01:48,500 --> 00:01:51,100
再把它认为是一个图的问题

59
00:01:51,100 --> 00:01:53,700
那图的问题里面要找最短路径, 对吧

60
00:01:53,700 --> 00:01:54,533
找最短路径呢

61
00:01:54,533 --> 00:01:56,333
我们首先想到的就是那个

62
00:01:56,333 --> 00:01:57,333
广度优先算法

63
00:01:57,333 --> 00:02:00,033
因为广度优先算法那就是按层来

64
00:02:00,333 --> 00:02:01,166
走嘛, 对吧

65
00:02:01,166 --> 00:02:02,866
比如说我这边画个图

66
00:02:02,866 --> 00:02:04,533
就是这边比如这个一个节点然后

67
00:02:04,633 --> 00:02:06,333
每个格子它有4个嘛

68
00:02:06,333 --> 00:02:07,700
有最多有4个嘛

69
00:02:07,700 --> 00:02:09,766
它就是相当一棵四叉树, 对吧

70
00:02:10,033 --> 00:02:11,133
上下左右对吧

71
00:02:11,133 --> 00:02:12,233
然后我每个

72
00:02:12,433 --> 00:02:14,600
每个节点它都有4个节点

73
00:02:14,666 --> 00:02:17,333
然后比如说这里面这个是出口了

74
00:02:17,333 --> 00:02:19,266
我这个是入口, 那我就按 Breadth First Search

75
00:02:19,300 --> 00:02:22,366
就是广度优先就是按层来走

76
00:02:22,366 --> 00:02:23,533
我找到第一个出口

77
00:02:23,533 --> 00:02:25,200
那它肯定就是最短的对吧

78
00:02:25,300 --> 00:02:27,000
我们当时讲过这个二叉树的

79
00:02:27,000 --> 00:02:27,800
Breadth First Search (BFS)

80
00:02:28,133 --> 00:02:29,600
这四叉树也是一样

81
00:02:29,600 --> 00:02:31,133
那这里面图它有个问题

82
00:02:31,133 --> 00:02:33,700
就是说我访问过我就不能再访问了

83
00:02:33,700 --> 00:02:36,000
就是说比如说我这个节点我往这走

84
00:02:36,466 --> 00:02:38,133
我走到上对吧

85
00:02:38,266 --> 00:02:39,866
那我要走到下就不行了

86
00:02:39,866 --> 00:02:42,066
因为我已经访问过这个节点了对不对

87
00:02:42,100 --> 00:02:43,333
那我就不能再走了对吧

88
00:02:43,333 --> 00:02:46,533
你不能说来回走, 那来回走它就

89
00:02:46,600 --> 00:02:47,900
没法结束对不对

90
00:02:47,900 --> 00:02:49,266
我往左趟一格

91
00:02:49,266 --> 00:02:51,333
然后再往右走, 再往左走, 往左往右走

92
00:02:51,333 --> 00:02:52,100
那它就会

93
00:02:52,100 --> 00:02:54,666
死循环, 就没法弄, 对吧

94
00:02:54,800 --> 00:02:55,600
这个是

95
00:02:55,900 --> 00:02:58,666
需要注意的, 我们这节课讲 Breadth First Search

96
00:02:58,666 --> 00:02:59,466
下一节课我们

97
00:02:59,500 --> 00:03:01,966
考虑一下那个深度优先算法 Depth First Search

98
00:03:02,300 --> 00:03:03,466
能不能解决这个问题

99
00:03:03,466 --> 00:03:04,366
然后在下一节课

100
00:03:04,366 --> 00:03:06,200
我们会讲那个迭代的

101
00:03:06,200 --> 00:03:07,966
Iterative Deepening Search 迭代深度搜索

102
00:03:07,966 --> 00:03:10,433
这个也可以来解决这个问题

103
00:03:10,433 --> 00:03:11,966
我们就分三节课来把这

104
00:03:11,966 --> 00:03:13,833
这把这题给刷了啊

105
00:03:13,966 --> 00:03:16,300
那我们先讲这个 Breadth First Search 因为是比较

106
00:03:16,400 --> 00:03:18,833
比较直观的一个方法吧

107
00:03:18,833 --> 00:03:20,333
我们来先刷这个题

108
00:03:20,433 --> 00:03:21,600
我们看这个题目

109
00:03:21,600 --> 00:03:23,366
它给定的是这个Maze

110
00:03:23,366 --> 00:03:24,733
然后给定个 Entrance 对吧

111
00:03:24,733 --> 00:03:27,033
首先要一个函数来判断它是不是

112
00:03:27,333 --> 00:03:28,866
我们需要的出口, 对不对

113
00:03:29,000 --> 00:03:30,200
我们给定这个

114
00:03:30,400 --> 00:03:33,333
坐标, 行数, 列数, 对不对

115
00:03:33,366 --> 00:03:37,100
我们首先需要它的那个Maze的这个

116
00:03:37,566 --> 00:03:39,300
宽度和高度对吧

117
00:03:39,300 --> 00:03:42,400
那我们就是 rows 等于 len(maze)

118
00:03:42,833 --> 00:03:44,133
它的行数

119
00:03:44,400 --> 00:03:47,566
column是等于lens maze的第一行的个数

120
00:03:47,566 --> 00:03:48,400
就是列数

121
00:03:48,600 --> 00:03:49,100
那当然

122
00:03:49,100 --> 00:03:51,733
这个我们要假定它已经是大于0了

123
00:03:51,733 --> 00:03:53,433
等于0 给定一个空的这个Maze

124
00:03:53,433 --> 00:03:54,533
没有什么意义

125
00:03:55,300 --> 00:03:58,500
assert cols 大于 0

126
00:03:58,933 --> 00:04:00,400
那这时候我们 rows 和 columns

127
00:04:00,400 --> 00:04:02,800
那我们就可以看到如果r等于0 对吧

128
00:04:02,800 --> 00:04:06,500
它等于0就是第一行或者是 r 等于

129
00:04:07,233 --> 00:04:09,000
rows - 1 就最后一行

130
00:04:09,200 --> 00:04:13,800
或者是 c 等于 0 或者是 c 等于 cols 减1

131
00:04:13,800 --> 00:04:16,300
这样的话我就返回

132
00:04:16,300 --> 00:04:17,200
我需要返回

133
00:04:17,533 --> 00:04:18,033
返回什么呢

134
00:04:18,033 --> 00:04:19,166
我不能返回 True 吗

135
00:04:19,166 --> 00:04:21,200
我要判断它是不是空的格子 是不是

136
00:04:22,233 --> 00:04:24,800
maze[r][c] 等于 等于空吗

137
00:04:24,800 --> 00:04:26,733
空它是按点号来算的, 是吧

138
00:04:26,933 --> 00:04:28,133
否则的话就是 False

139
00:04:28,200 --> 00:04:28,600
那这个

140
00:04:28,600 --> 00:04:30,300
实际上我们是可以把它缓存一下

141
00:04:30,366 --> 00:04:31,633
不用每次都去

142
00:04:31,833 --> 00:04:33,733
每次都去算

143
00:04:33,800 --> 00:04:35,766
嗯, 那我们就加一个 cache 好了

144
00:04:37,600 --> 00:04:38,400
@cache

145
00:04:38,400 --> 00:04:39,766
这是"记住"

146
00:04:39,766 --> 00:04:42,233
记住它, 就是像一个记事本一样

147
00:04:42,233 --> 00:04:43,833
我们算过这个值

148
00:04:43,833 --> 00:04:46,200
那么下次就查表就好了, 不用再算

149
00:04:47,066 --> 00:04:50,766
然后我们现在要来一个 seen table 就是set (哈稀集合)

150
00:04:51,133 --> 00:04:53,633
就是看它是不是能够

151
00:04:53,633 --> 00:04:54,966
这个这个访问过吗

152
00:04:54,966 --> 00:04:57,166
访问过我们就就不再访问对吧

153
00:04:57,166 --> 00:04:58,866
这个然后我们有一个q

154
00:04:59,366 --> 00:05:02,233
Q就是队列 First In First Out

155
00:05:02,233 --> 00:05:03,200
就是先进先出

156
00:05:03,200 --> 00:05:04,800
在实现这个 Breadth First Search

157
00:05:04,800 --> 00:05:07,600
必须要用到的这个数据结构

158
00:05:07,600 --> 00:05:12,133
就 队列队列 就是 deque, double-ended queue (双头队列)

159
00:05:12,466 --> 00:05:13,466
然后我们

160
00:05:13,633 --> 00:05:16,133
刚开始要把它的 Entrance 给放进去, 是不是

161
00:05:16,566 --> 00:05:18,066
Entrance 对不对就是Entrance

162
00:05:19,166 --> 00:05:21,566
然后它的距离刚开始0

163
00:05:21,566 --> 00:05:23,466
这里面这里面上面有个问题

164
00:05:23,466 --> 00:05:24,366
是什么问题呢

165
00:05:24,500 --> 00:05:27,866
这这个是 isExit 只是判断它是否是那个

166
00:05:28,166 --> 00:05:29,300
出口

167
00:05:29,300 --> 00:05:31,200
但它如果等于入口的话怎么办呢

168
00:05:31,200 --> 00:05:32,166
我们刚才说过

169
00:05:32,166 --> 00:05:34,700
如果是入口的话它就不能说是 Exit 嘛

170
00:05:34,700 --> 00:05:35,466
对吧

171
00:05:35,466 --> 00:05:37,400
所以我们这个我们可以先不管它

172
00:05:37,400 --> 00:05:37,766
不考虑

173
00:05:37,766 --> 00:05:40,500
等会我们在里面实现一下这个逻辑

174
00:05:41,100 --> 00:05:43,666
while q 对吧, 我们首先 r, c

175
00:05:44,333 --> 00:05:46,500
这里面 r, c 它有3个值

176
00:05:46,500 --> 00:05:47,766
第一个值是一个 tuple

177
00:05:47,766 --> 00:05:48,466
就是元组(Tuple)

178
00:05:48,466 --> 00:05:51,366
然后第二个值是distance等于q点 popleft

179
00:05:51,366 --> 00:05:51,933
我们讲过啊

180
00:05:51,933 --> 00:05:54,400
就是从队列里面找出最左边的那个

181
00:05:54,400 --> 00:05:56,100
把那个最左边的出队列

182
00:05:56,666 --> 00:05:58,600
那这时候, 如果我们看如果

183
00:05:58,933 --> 00:06:01,966
这个 r, c 是不是不等于

184
00:06:02,100 --> 00:06:03,566
不等于这个入口是吧

185
00:06:03,566 --> 00:06:04,500
不等于入口

186
00:06:04,533 --> 00:06:05,966
这个入口应该它是一个 List

187
00:06:05,966 --> 00:06:08,333
我们把它变成 元组 (Tuple) 才能比较啊 Entrance

188
00:06:09,066 --> 00:06:11,166
然后并且它是个 Exit 是吧

189
00:06:11,166 --> 00:06:12,533
如果它我们找到了吗

190
00:06:12,533 --> 00:06:13,600
比如说它是个 Exit

191
00:06:13,933 --> 00:06:16,500
那么我就返回它现在的距离d吗, 对吧

192
00:06:16,766 --> 00:06:17,366
否则的话

193
00:06:17,366 --> 00:06:19,500
我第一件事情我是不是要把它给呢

194
00:06:19,933 --> 00:06:22,266
判断一下如果r, c在

195
00:06:22,366 --> 00:06:25,133
我们以前走过这个格那我们就要

196
00:06:25,300 --> 00:06:27,333
我们就要continue哈

197
00:06:27,333 --> 00:06:29,833
否则的话, 就把它加到这个

198
00:06:29,866 --> 00:06:31,066
加到这个 hash set 里面来

199
00:06:31,133 --> 00:06:32,766
把它加到这个

200
00:06:32,800 --> 00:06:34,533
访问的过的这个列表里面

201
00:06:34,533 --> 00:06:36,100
以后就不用再访问了嘛, 对吧

202
00:06:36,100 --> 00:06:37,233
然后我们要访问

203
00:06:37,666 --> 00:06:38,600
它的邻居

204
00:06:38,600 --> 00:06:39,900
邻居它就4个格子嘛

205
00:06:39,900 --> 00:06:40,966
上下左右, 是吧

206
00:06:40,966 --> 00:06:43,366
那我们先这样 dr, dc in

207
00:06:44,400 --> 00:06:47,000
(1, 0), (0, 1)

208
00:06:48,100 --> 00:06:49,233
(-1, 0)

209
00:06:50,066 --> 00:06:53,800
(0, -1) 这个就是四个格的这个方位

210
00:06:53,800 --> 00:06:55,166
偏差坐标嘛 对吧

211
00:06:55,166 --> 00:06:56,666
你可以想象, 就是四个值嘛

212
00:06:56,666 --> 00:06:59,900
(1, 0), (0, 1), (-1, 0), (0, -1) 它就是上下左右, 对吧

213
00:06:59,900 --> 00:07:03,166
然后我们 nr, nc 是等于 dr加r

214
00:07:03,600 --> 00:07:06,666
dc加c, 这个就是说 nr 是等于 dr加r

215
00:07:06,800 --> 00:07:08,033
nc 等于 dc 加 c

216
00:07:08,566 --> 00:07:09,866
那这个它可能会出界

217
00:07:09,966 --> 00:07:11,366
会出界我们就不管它吧

218
00:07:11,366 --> 00:07:12,866
我们首先要判断出界0小于

219
00:07:12,866 --> 00:07:14,633
0小于等于nr 小于 rows

220
00:07:15,000 --> 00:07:18,666
and 0小于等于 nc 小于columns是吧

221
00:07:18,666 --> 00:07:19,800
这时候如果它不出去

222
00:07:19,800 --> 00:07:21,966
并且它必须是要

223
00:07:21,966 --> 00:07:23,700
我写到下一行

224
00:07:24,433 --> 00:07:25,400
并且

225
00:07:26,466 --> 00:07:27,166


226
00:07:27,166 --> 00:07:28,433
能写到下一行吗

227
00:07:29,466 --> 00:07:34,100
并且是什么呢 maze[nr][nc] 必须要等于

228
00:07:35,266 --> 00:07:38,233
等于空格子你才能往下走, 是吧

229
00:07:38,233 --> 00:07:39,366
才能往那一格走

230
00:07:39,366 --> 00:07:42,633
那这时候是怎么走呢, 是等于

231
00:07:42,800 --> 00:07:44,600
往下走就是

232
00:07:45,400 --> 00:07:47,566
q点 append

233
00:07:48,366 --> 00:07:49,633
(nr, nc)

234
00:07:49,733 --> 00:07:52,633
然后它的distance要加1, 是不是

235
00:07:53,866 --> 00:07:54,666
对不对

236
00:07:54,666 --> 00:07:57,733
然后如果找不到 return False

237
00:07:57,933 --> 00:07:59,400
这边有个小问题

238
00:07:59,400 --> 00:08:00,400
有一个什么小问题呢

239
00:08:00,400 --> 00:08:02,033
我这边我

240
00:08:02,533 --> 00:08:03,400
可以在这里判断

241
00:08:03,400 --> 00:08:04,266
但是最好

242
00:08:04,266 --> 00:08:06,733
最好是在, 这里面有个小区别

243
00:08:06,733 --> 00:08:08,100
就是这个判断它重复

244
00:08:08,100 --> 00:08:09,033
可以是在

245
00:08:09,133 --> 00:08:11,366
展开的时候

246
00:08:11,366 --> 00:08:12,933
可以在出队列的时候

247
00:08:13,366 --> 00:08:15,300
判断也可以在入队列的时候判断

248
00:08:15,300 --> 00:08:17,433
但最好是在入队列的时候判断

249
00:08:17,500 --> 00:08:19,300
如果, 所以我这边再加一个

250
00:08:19,333 --> 00:08:20,766
我给它移到这里来

251
00:08:21,500 --> 00:08:24,333
if (nr, nc) not in seen:

252
00:08:25,233 --> 00:08:25,966
not in seen 对吧

253
00:08:25,966 --> 00:08:28,500
那我这时候我就把它, 入到这里面来了

254
00:08:28,500 --> 00:08:31,533
seen.add((nr, nc))

255
00:08:31,833 --> 00:08:33,766
这里面有点小区别啊

256
00:08:34,700 --> 00:08:36,633
就是我在入队列之前

257
00:08:36,633 --> 00:08:38,166
我检查它有没有访问过

258
00:08:38,166 --> 00:08:40,133
或者是说我不管先入队列

259
00:08:40,133 --> 00:08:41,733
然后再出队列的时候判断呢

260
00:08:41,866 --> 00:08:42,700
是否是重复

261
00:08:42,700 --> 00:08:43,666
但是一般来说

262
00:08:43,666 --> 00:08:46,633
对 Breadth First Search 一般是最好是在这里面加

263
00:08:46,633 --> 00:08:48,633
会有点细小的差别

264
00:08:48,700 --> 00:08:51,200
那这样的话, 应该就没有问题吧

265
00:08:51,200 --> 00:08:54,400
我们再检查一下 跑一下

266
00:08:54,733 --> 00:08:56,766
那刚才讲到这个 Exit 的时候

267
00:08:56,966 --> 00:08:58,100
是不是 Entrance

268
00:08:58,100 --> 00:08:58,733
我们在这里判断

269
00:08:58,733 --> 00:08:59,400
判断了嘛

270
00:08:59,400 --> 00:09:01,366
对吧, 就不给它移到这里面来了

271
00:09:01,433 --> 00:09:03,299
如果并且是 Exit, return d 

272
00:09:03,333 --> 00:09:04,899
如果找到我们这个节点的话

273
00:09:04,900 --> 00:09:05,800
我们就把它返回

274
00:09:05,800 --> 00:09:06,266
否则的话

275
00:09:06,266 --> 00:09:09,666
就把它的4个邻居节点都给它展开

276
00:09:09,733 --> 00:09:10,999
跑一下测试用例

277
00:09:11,833 --> 00:09:14,133
这个换行可能不是这么写

278
00:09:14,133 --> 00:09:15,266
换行怎么写呢

279
00:09:18,733 --> 00:09:21,100
加一个回退这样

280
00:09:24,233 --> 00:09:26,000
forgot a common uh

281
00:09:28,933 --> 00:09:29,733
嗯

282
00:09:31,266 --> 00:09:33,400
它为什么不, 说啥意思了

283
00:09:33,433 --> 00:09:34,666
Invalid Syntax

284
00:09:34,833 --> 00:09:37,466
对对, 它不是, 它是, 只是这里

285
00:09:38,033 --> 00:09:41,033
1加1这个这个少了一个这个对

286
00:09:43,066 --> 00:09:46,733
对, 对这样, 这样就对了, 你看

287
00:09:46,733 --> 00:09:48,533
我把它移过来一点

288
00:09:49,033 --> 00:09:49,833
是吧

289
00:09:50,633 --> 00:09:51,466
这样可以了

290
00:09:51,600 --> 00:09:52,733
是不是这样可以了

291
00:09:53,433 --> 00:09:54,833
再跑过来跑一下跑一下

292
00:09:56,933 --> 00:09:58,900
Wrong Answer, 这里面很好

293
00:09:58,900 --> 00:09:59,866
为什么是 Wrong Answer 呢

294
00:09:59,866 --> 00:10:01,700
点号 False 返回

295
00:10:01,700 --> 00:10:03,900
不是返回-1, 是应该是返回-1

296
00:10:03,900 --> 00:10:05,400
不是返回 False 这个是

297
00:10:05,500 --> 00:10:07,066
没看题呀

298
00:10:08,300 --> 00:10:10,900
就过了吗, 你看, 对吧, 过了

299
00:10:11,533 --> 00:10:14,433
过了嗯, 对大体是这样

300
00:10:14,433 --> 00:10:16,900
这里面就是很简单明了的

301
00:10:16,900 --> 00:10:18,500
这个 Breadth First Search 广度优先搜索算法

302
00:10:18,500 --> 00:10:19,933
那我们现在有一个问题

303
00:10:19,933 --> 00:10:20,633
就是你想

304
00:10:20,633 --> 00:10:23,033
我们是从入口开始找是吧

305
00:10:23,100 --> 00:10:25,400
实际上我们是可以从出口开始往回找

306
00:10:25,400 --> 00:10:25,733
一样的吧

307
00:10:25,733 --> 00:10:27,433
是吧, 你能理解吧?

308
00:10:27,433 --> 00:10:29,666
就你给定这个入口在这里

309
00:10:29,666 --> 00:10:30,700
你从入口开始找

310
00:10:30,700 --> 00:10:32,066
你也可以从出口开始找

311
00:10:32,066 --> 00:10:32,800
是不是

312
00:10:32,800 --> 00:10:35,133
我要出口开始找的话也一样

313
00:10:35,133 --> 00:10:36,700
出口再找有个好处

314
00:10:36,700 --> 00:10:37,933
就是你不用判断这个

315
00:10:37,933 --> 00:10:39,100
你只要返回找

316
00:10:39,200 --> 00:10:41,233
判断它是不是 Exit 就好了吧, 对吧

317
00:10:41,500 --> 00:10:43,400
那这时候出口找, 那我出口怎么找了

318
00:10:43,400 --> 00:10:44,700
出口有多个出口, 对不对

319
00:10:44,866 --> 00:10:45,466
那我找到

320
00:10:45,466 --> 00:10:47,933
出口把它入到这个队列里面来了对吧

321
00:10:48,033 --> 00:10:50,333
所以我们这个简单写一下这很快

322
00:10:50,666 --> 00:10:52,033
deque 我们在这里写

323
00:10:52,033 --> 00:10:55,466
然后我们就找一下这个入口吧

324
00:10:55,466 --> 00:10:59,233
出口吧 for r in range(rows)

325
00:10:59,533 --> 00:11:02,233
for c in range columns对

326
00:11:02,233 --> 00:11:03,433
然后如果

327
00:11:03,600 --> 00:11:06,333
如果 isExit 是吧 if isExit(nr, nc)

328
00:11:06,700 --> 00:11:09,133
并且, 并且这个r c

329
00:11:09,933 --> 00:11:11,233
不等于这个 Entrance 对吧

330
00:11:11,233 --> 00:11:14,333
你的你的出口不能是 Entrance 是不是

331
00:11:15,233 --> 00:11:16,866
这个是它给的不是 Tuple

332
00:11:16,866 --> 00:11:18,900
所以我们要把它转成 Tuple 才能比较

333
00:11:19,066 --> 00:11:20,800
那么就 q.append

334
00:11:21,000 --> 00:11:21,933
(r, c)

335
00:11:22,866 --> 00:11:23,800
((r, c), 0) 是吧

336
00:11:24,633 --> 00:11:25,900
它是一个元组(Tuple)

337
00:11:25,900 --> 00:11:29,266
第一个元组(Tuple)的是一个另外一个元组(Tuple)

338
00:11:29,466 --> 00:11:30,600
这样就可以了

339
00:11:30,600 --> 00:11:31,733
这里面实际上我

340
00:11:31,733 --> 00:11:33,633
我这边写的这个(算法执行)效率不是很高

341
00:11:33,633 --> 00:11:34,500
因为它这个

342
00:11:34,566 --> 00:11:38,166
这个 Exit 它不可能是中间这些值吗

343
00:11:38,166 --> 00:11:40,066
中间这些肯定不是 Exit 嘛

344
00:11:40,066 --> 00:11:41,166
所以我没必要循环

345
00:11:41,166 --> 00:11:42,166
然后我就偷工减料

346
00:11:42,166 --> 00:11:45,466
就是直接遍例每一个

347
00:11:45,466 --> 00:11:47,600
遍例每一个元素 对不对

348
00:11:47,600 --> 00:11:49,566
但实际上我只要找这4个, 对吧

349
00:11:49,566 --> 00:11:50,766
就是找这4个

350
00:11:51,266 --> 00:11:53,533
它这个Maze它只有4个边界嘛

351
00:11:53,533 --> 00:11:54,966
我不用中间的不用遍例嘛

352
00:11:54,966 --> 00:11:57,133
这里面我就偷工减料这么写

353
00:11:57,133 --> 00:12:00,400
然后你看我就把这个 Exit 给它 Push 进去

354
00:12:00,600 --> 00:12:01,866
那我这时候我就要反过来

355
00:12:01,866 --> 00:12:02,800
我就是不用这么写

356
00:12:02,800 --> 00:12:04,400
我跟你说如果它等于

357
00:12:04,933 --> 00:12:06,100
等于 Entrance 吗

358
00:12:06,100 --> 00:12:06,900
是吧

359
00:12:07,266 --> 00:12:08,900
是不是反过来我从 Exit 里面找

360
00:12:08,900 --> 00:12:10,700
我看它等于 Entrance 

361
00:12:10,700 --> 00:12:13,000
这时候跑一下看看过没过

362
00:12:15,100 --> 00:12:16,066
也过了, 是吧

363
00:12:16,066 --> 00:12:17,300
这也是一种方法, 是吧

364
00:12:17,300 --> 00:12:19,600
这个对嗯

365
00:12:19,966 --> 00:12:20,400
对

366
00:12:20,400 --> 00:12:21,500
然后对今天

367
00:12:21,500 --> 00:12:22,700
我们就讲这个这题吧

368
00:12:22,700 --> 00:12:24,000
它这个就是 Breadth First Search

369
00:12:24,000 --> 00:12:27,700
总结来说就是用广度优先算法来找

370
00:12:28,100 --> 00:12:29,733
找这个无向图

371
00:12:29,800 --> 00:12:31,133
不对, 无权图

372
00:12:31,133 --> 00:12:32,900
它只是它也是个无向图

373
00:12:32,900 --> 00:12:34,266
无向图就是你a可以

374
00:12:34,566 --> 00:12:36,100
左边这个可以走到右边这个

375
00:12:36,100 --> 00:12:38,466
右边这个可以走到左边的这个无向

376
00:12:38,600 --> 00:12:39,300
无向图

377
00:12:39,366 --> 00:12:40,333
有向图它反过来

378
00:12:40,333 --> 00:12:41,966
意思就是你左边只能走到右边

379
00:12:41,966 --> 00:12:43,866
右边不能走到左边, 或者怎么样的

380
00:12:43,866 --> 00:12:44,666
这个

381
00:12:44,666 --> 00:12:46,166
就是无向图

382
00:12:46,166 --> 00:12:47,800
无向无权图

383
00:12:48,000 --> 00:12:49,666
的里面的最短路径

384
00:12:50,000 --> 00:12:51,433
就 Breadth First Search 广度优先

385
00:12:51,466 --> 00:12:54,366
它能在这个无权图里面找最短路径

386
00:12:54,366 --> 00:12:55,300
如果是有权图

387
00:12:55,300 --> 00:12:58,166
我们就得用另外一种其它的算法

388
00:12:58,166 --> 00:13:00,466
BFS就不能不能找最短路径了

389
00:13:00,466 --> 00:13:03,033
那我们还讲到就是说, 我们可以

390
00:13:03,266 --> 00:13:04,266
反过来找

391
00:13:04,333 --> 00:13:05,366
从出口开始找

392
00:13:05,366 --> 00:13:07,333
或者可以从多个入口开始找

393
00:13:07,333 --> 00:13:07,866
这没关系

394
00:13:07,866 --> 00:13:09,733
因为你想想它有多个入口的话

395
00:13:09,733 --> 00:13:11,766
它全部都 push 到这 Queue 里面

396
00:13:11,833 --> 00:13:14,166
刚开始这个队列的这个状态

397
00:13:14,166 --> 00:13:17,300
它实际上是有很多 Exit 很多出口

398
00:13:17,300 --> 00:13:18,233
那你反向找

399
00:13:18,233 --> 00:13:20,233
看谁先找到这个入口, 对不对

400
00:13:20,533 --> 00:13:21,366
那或者反过来的

401
00:13:21,366 --> 00:13:22,533
然后这里还有另外一个问题

402
00:13:22,533 --> 00:13:24,766
就是说如果我们

403
00:13:24,966 --> 00:13:26,633
访问过了这个

404
00:13:27,166 --> 00:13:31,333
这一格 我们就必须把它给添加到这个

405
00:13:31,800 --> 00:13:32,800
访问过的列表

406
00:13:32,800 --> 00:13:34,000
我们就不会重复走了

407
00:13:34,000 --> 00:13:36,366
重复走它就永远找不到, 找不到, 对吧

408
00:13:36,366 --> 00:13:38,166
你往前挪一个再往后退一个

409
00:13:38,166 --> 00:13:39,399
再往前挪一个它

410
00:13:39,466 --> 00:13:40,766
永远没法结束, 对不对

411
00:13:40,766 --> 00:13:41,600
这个就是这样

412
00:13:41,600 --> 00:13:43,366
然后找到 Breadth First Search

413
00:13:43,366 --> 00:13:44,266
找到第一个格子就能

414
00:13:44,300 --> 00:13:46,233
就能保证它是最短的路径

415
00:13:46,233 --> 00:13:47,966
这个是 Breadth First Search 这个优点

416
00:13:47,966 --> 00:13:48,866
因为它是按层来

417
00:13:48,866 --> 00:13:49,999
来走嘛, 你想想

418
00:13:50,033 --> 00:13:51,533
这个 Exit 在哪里

419
00:13:51,533 --> 00:13:53,000
我按层来走的话

420
00:13:53,333 --> 00:13:53,733
对吧

421
00:13:53,733 --> 00:13:54,566
它找到第一个, 就是它的最短路径

422
00:13:54,633 --> 00:13:55,899
它找到第一个, 就是它的最短路径

423
00:13:56,033 --> 00:13:57,066
这个可以是 Entrance 嘛

424
00:13:57,066 --> 00:13:58,366
我们假设从 Entrance 开始找

425
00:13:58,366 --> 00:13:59,533
那这个是 Exit 的话

426
00:13:59,533 --> 00:14:00,933
这边有多个 Exit 的话

427
00:14:01,266 --> 00:14:02,966
我找到第一个肯定就是它的

428
00:14:02,966 --> 00:14:03,933
最短的那个 Exit

429
00:14:04,066 --> 00:14:05,266
对吧, 那我每次

430
00:14:05,333 --> 00:14:06,500
找到它的

431
00:14:06,500 --> 00:14:07,100
neighbor的话

432
00:14:07,100 --> 00:14:08,766
我们要把这个 distance 加一嘛, 对吧

433
00:14:08,766 --> 00:14:10,066
我每走一格

434
00:14:10,100 --> 00:14:12,966
每次把这个新的这个

435
00:14:13,066 --> 00:14:15,233
邻居节点添加到这个队列里面

436
00:14:15,300 --> 00:14:16,133
多消耗了一步

437
00:14:16,133 --> 00:14:18,433
那我们就会把这个 distance 加一, 对吧

438
00:14:18,433 --> 00:14:21,233
然后把这个格子新的位置添加到里面

439
00:14:21,233 --> 00:14:23,466
那这个是 Breadth First Search

440
00:14:23,466 --> 00:14:25,500
然后基本是这样嘛, 好

441
00:14:25,500 --> 00:14:26,700
有什么问题吗?

442
00:14:26,833 --> 00:14:27,466
没有

443
00:14:27,466 --> 00:14:28,766
嗯, 好, 那就这样

444
00:14:28,766 --> 00:14:31,533
下期见, 嗯, 拜拜, 拜拜

