1
00:00:00,666 --> 00:00:03,799
哎大家好 今天我们来讲第37课

2
00:00:04,300 --> 00:00:06,300
37课 我们今天讲的还是这个

3
00:00:06,300 --> 00:00:07,733
最长递增子序列呀

4
00:00:07,733 --> 00:00:09,733
但我们今天要用二分的方法

5
00:00:09,733 --> 00:00:11,766
上周我们讲的是动态规划

6
00:00:11,933 --> 00:00:12,733
动态规划

7
00:00:12,900 --> 00:00:15,500
我们先来看一下代码

8
00:00:15,500 --> 00:00:17,266
动态规划这两种方法

9
00:00:17,266 --> 00:00:18,666
一个是非递归的方法

10
00:00:18,666 --> 00:00:19,733
一种是递归的方法

11
00:00:19,733 --> 00:00:20,866
这个要解决什么问题呢

12
00:00:20,866 --> 00:00:23,499
就是我们给定一个数组

13
00:00:23,600 --> 00:00:24,500
数组里面有很多数

14
00:00:24,500 --> 00:00:27,066
我们要找出最长递增子序列

15
00:00:27,366 --> 00:00:28,566
严格递增哈

16
00:00:28,566 --> 00:00:32,066
longest strictly increasing subsequence

17
00:00:32,066 --> 00:00:35,299
subsequence 可以不是连续的

18
00:00:35,300 --> 00:00:38,800
比如说你可以说 [10,2,3,7] 可以跳的

19
00:00:38,866 --> 00:00:39,999
那列表 SubList

20
00:00:40,000 --> 00:00:42,366
是子列表 它是连续的 比如说 [10,9,2,5]

21
00:00:42,366 --> 00:00:43,599
我们这两个概念 sublist

22
00:00:44,300 --> 00:00:46,566
然后我们用的动态规划的方法

23
00:00:46,566 --> 00:00:47,899
就是说 我们用

24
00:00:48,066 --> 00:00:51,299
用一个 dp[i] 代表说到

25
00:00:51,666 --> 00:00:55,533
index 到索引 i 位置最长的那个子序列

26
00:00:55,533 --> 00:00:57,699
递增子序列的那个长度

27
00:00:57,766 --> 00:00:58,966
那么我要判断

28
00:00:59,000 --> 00:01:01,266
我有这个 dp 这个值的时候

29
00:01:01,266 --> 00:01:04,666
我就判断如果前面有一个数比它小

30
00:01:05,100 --> 00:01:06,900
对吧 那么它就可以等于它

31
00:01:07,533 --> 00:01:11,333
就可以把前面的那个列表 dp[j]+1

32
00:01:11,366 --> 00:01:13,366
对吧 因为我发现一个数比它小

33
00:01:13,366 --> 00:01:14,499
那么我 dp

34
00:01:14,700 --> 00:01:15,733
计算 dp[i] 的时候

35
00:01:15,733 --> 00:01:18,099
是不是可以在 dp[j] 的基础上面加一

36
00:01:18,100 --> 00:01:19,266
我要取最大对不对

37
00:01:19,266 --> 00:01:21,533
然后最后面我是要求这个所有 dp

38
00:01:21,866 --> 00:01:22,799
的最大值

39
00:01:22,800 --> 00:01:26,400
因为 dp 可以到每个

40
00:01:26,700 --> 00:01:27,500
就这个最长

41
00:01:27,533 --> 00:01:29,299
递增子序列可以是任何

42
00:01:29,600 --> 00:01:31,966
任何索引为止对吧

43
00:01:31,966 --> 00:01:33,866
它不一定是要到最后面这个结尾了

44
00:01:33,866 --> 00:01:37,899
你看 这个最长子序列就是 [2,3,7,101]

45
00:01:37,900 --> 00:01:39,000
它到 倒数第二个数吗

46
00:01:39,000 --> 00:01:41,366
它没有说到最后一个数对不对

47
00:01:41,466 --> 00:01:42,899
该有可能是 到这个数 到这个数

48
00:01:42,900 --> 00:01:43,333
到这个数

49
00:01:43,333 --> 00:01:44,666
所以我们要这个

50
00:01:44,666 --> 00:01:46,266
这个 max 取最大是这个意思

51
00:01:46,266 --> 00:01:48,733
这个 default=0 如果 nums 是空的话

52
00:01:48,733 --> 00:01:49,799
我们就给它一个默认值

53
00:01:49,800 --> 00:01:51,333
那我这个递归的方法

54
00:01:51,333 --> 00:01:53,166
我用一个 @cache 的方法

55
00:01:53,200 --> 00:01:55,100
去记录中间(计算过)的这个值吗

56
00:01:55,100 --> 00:01:57,366
所以它我如果用这个 @cache 的方法

57
00:01:57,566 --> 00:02:00,933
那么它这个 f(i) 最多就有 n 种状态对吧

58
00:02:00,933 --> 00:02:02,333
你看我这边有 f

59
00:02:02,466 --> 00:02:05,066
i 到 i 从0到 n 减1就 n 种状态

60
00:02:05,066 --> 00:02:06,733
所以它最多就调用

61
00:02:07,466 --> 00:02:08,266
n 次对吧

62
00:02:08,266 --> 00:02:09,899
这个所以它每次调用 n 次

63
00:02:09,900 --> 00:02:12,400
然后每 n 次里面它

64
00:02:12,666 --> 00:02:14,566
它要再循环

65
00:02:14,933 --> 00:02:17,666
index 从那个0到 i 减一

66
00:02:17,666 --> 00:02:19,699
那么它就是 O(N平方)

67
00:02:19,700 --> 00:02:21,266
这个这个算法也是一样

68
00:02:21,266 --> 00:02:23,866
它的算法复杂度就是O(N平方)

69
00:02:23,866 --> 00:02:25,699
这个是有点慢的

70
00:02:25,700 --> 00:02:27,400
那我们今天来讲一个比较快的方法

71
00:02:27,400 --> 00:02:28,766
就是二分搜索

72
00:02:28,766 --> 00:02:31,933
二分搜索是基于这个概念

73
00:02:31,933 --> 00:02:32,499
比如说我

74
00:02:32,500 --> 00:02:33,633
我首先有个 lis

75
00:02:33,633 --> 00:02:35,099
lis, 最长递增子序列

76
00:02:35,233 --> 00:02:36,033
子序列

77
00:02:36,033 --> 00:02:39,366
我就是去建立这么一个列表

78
00:02:39,366 --> 00:02:41,233
对吧 你不是要知道长度吗

79
00:02:41,233 --> 00:02:43,566
那么我就去(尝试)建立这个列表

80
00:02:43,633 --> 00:02:45,566
那我就刚开始比如10吗

81
00:02:45,566 --> 00:02:46,500
10我就放进去吗

82
00:02:46,500 --> 00:02:49,100
我循环这个9的时候 我遍例这些数字

83
00:02:49,100 --> 00:02:50,000
我一个一个遍例

84
00:02:50,000 --> 00:02:50,600
我这个9

85
00:02:50,600 --> 00:02:53,900
我就是要去把它放到这个 lis 的位置

86
00:02:54,000 --> 00:02:54,566
那么我就

87
00:02:54,566 --> 00:02:57,566
是找 放在哪里 会不影响最长结果呢

88
00:02:57,566 --> 00:02:59,533
我肯定把这个10替换掉嘛 对吧

89
00:02:59,566 --> 00:03:01,300
你想后面大于10

90
00:03:01,300 --> 00:03:02,866
那我替换成更小的数

91
00:03:02,866 --> 00:03:04,066
那就不影响它结果

92
00:03:04,066 --> 00:03:05,399
比如说这个1

93
00:03:05,466 --> 00:03:09,133
101对吧 那我在这边给个2对吧

94
00:03:09,133 --> 00:03:11,899
那我肯定是把这个101替换掉对吧

95
00:03:12,133 --> 00:03:13,133
因为有可能你看

96
00:03:13,133 --> 00:03:15,533
我这边 如果是后面有个3对吧

97
00:03:15,666 --> 00:03:18,766
是吧 比如说 它是[1,101,23] 是不是

98
00:03:19,900 --> 00:03:21,233
然后我这个

99
00:03:21,566 --> 00:03:23,533
如果你不替换掉101的话

100
00:03:23,533 --> 00:03:25,533
你这2和3肯定没法选对不对

101
00:03:25,533 --> 00:03:27,899
那你把那2把101替换成2的话

102
00:03:27,900 --> 00:03:29,833
那它可能下面就可能是2,3吗

103
00:03:29,833 --> 00:03:30,666
对吧 可以理解

104
00:03:30,666 --> 00:03:33,566
我选择一个位置把它替换掉

105
00:03:33,566 --> 00:03:35,700
把这个大的数给替换掉 或者等于

106
00:03:35,700 --> 00:03:38,100
比如说我这边有一个

107
00:03:38,233 --> 00:03:39,499
10的话

108
00:03:39,500 --> 00:03:41,733
那么我 10也可以把10替换掉 就无所谓嘛

109
00:03:41,733 --> 00:03:42,899
对吧是吧

110
00:03:43,033 --> 00:03:46,166
那我就刚才说到哪 10然后我就把

111
00:03:46,366 --> 00:03:48,266
10替换掉 就9了对吧

112
00:03:48,366 --> 00:03:49,733
那我现在来一个2

113
00:03:50,166 --> 00:03:52,100
2的话我是不是

114
00:03:52,900 --> 00:03:55,266
也可以把9替换掉对不对

115
00:03:55,366 --> 00:03:56,466
一样的原理吗

116
00:03:56,866 --> 00:03:59,033
然后 5呢

117
00:03:59,366 --> 00:04:00,933
5的话我没法把2替换掉

118
00:04:00,933 --> 00:04:02,666
我只能放到它尾巴吧

119
00:04:02,666 --> 00:04:04,900
对吧这就是它插入的位置 那3呢

120
00:04:05,266 --> 00:04:08,433
3的话我是不是把它替换掉是吧 对吧

121
00:04:08,733 --> 00:04:11,033
对 那7放到后面吧 是吧

122
00:04:11,166 --> 00:04:12,733
那101也放后面

123
00:04:12,766 --> 00:04:14,900
只要把它比它大的我都放后面

124
00:04:14,900 --> 00:04:17,466
那18我也替换它

125
00:04:19,666 --> 00:04:22,566
101 对对对 18替换掉101 所以它的长度就是4

126
00:04:22,900 --> 00:04:27,100
对吧 2,3,7,18

127
00:04:27,233 --> 00:04:30,899
我们看一下 [2,3,7,18]

128
00:04:31,066 --> 00:04:32,300
哎但它选的是你看吧

129
00:04:32,300 --> 00:04:34,466
它选的是[2,3,7,101]是吧

130
00:04:36,100 --> 00:04:38,633
无所谓吗 它是要求长度吗

131
00:04:38,633 --> 00:04:40,533
它有可能有多种结果吗 对吧

132
00:04:40,566 --> 00:04:41,533
这里面就有多种

133
00:04:41,533 --> 00:04:44,766
你给我 [2,3,7,101] 和 [2,3,7,18] 都可以吗

134
00:04:44,900 --> 00:04:47,500
对不对 这种情况

135
00:04:47,933 --> 00:04:49,099
就是要取它的长度

136
00:04:49,100 --> 00:04:51,133
不是取它的哪一种可能吗

137
00:04:51,333 --> 00:04:52,666
那有可能相等的数字

138
00:04:52,666 --> 00:04:54,166
你就有多种可能吗

139
00:04:54,166 --> 00:04:57,300
比如说这边有个2 你可以选 这个[2,3,7,101]

140
00:04:57,300 --> 00:04:59,533
也可以选第二个[2,3,7,101] 对吧

141
00:04:59,533 --> 00:05:00,933
但是我们这里都是取长度

142
00:05:00,933 --> 00:05:03,733
所以就没有关系 我们看一下这个

143
00:05:03,933 --> 00:05:06,033
这个吧 这个例子 答案是不是4

144
00:05:06,033 --> 00:05:08,166
我们按照这种原理来算一下

145
00:05:08,233 --> 00:05:12,266
嗯比如说就这个 刚开始是

146
00:05:12,733 --> 00:05:14,866
空吗 对吧那 我刚开始就0

147
00:05:14,900 --> 00:05:17,166
然后1就放在0的后面对吧

148
00:05:17,166 --> 00:05:20,066
0的话我怎么弄呢

149
00:05:20,066 --> 00:05:21,766
我是要把就大于它

150
00:05:21,766 --> 00:05:22,966
我就是把这个0替换掉

151
00:05:22,966 --> 00:05:24,300
不是替换掉这1

152
00:05:24,300 --> 00:05:25,466
是替换掉这个0

153
00:05:25,700 --> 00:05:27,766
对吧3放在后面

154
00:05:27,966 --> 00:05:29,266
这里有个等于的问题

155
00:05:29,266 --> 00:05:30,666
等会我们可以详细说一下

156
00:05:30,666 --> 00:05:31,466
2

157
00:05:31,466 --> 00:05:32,833
2就是把这个替换掉

158
00:05:32,833 --> 00:05:35,499
然后3 那就4个 是不是

159
00:05:35,666 --> 00:05:37,633
刚开始 就是写一下 if not nums

160
00:05:37,899 --> 00:05:39,866
判断它是否会空 return 0

161
00:05:40,066 --> 00:05:41,666
那我就给个 lis 刚开始

162
00:05:41,933 --> 00:05:44,966
for i in nums 遍例这个 nums

163
00:05:44,966 --> 00:05:46,699
对我现在 我要找这个位置吗

164
00:05:46,699 --> 00:05:48,533
对吧我要找这个位置 我假设它是0

165
00:05:48,533 --> 00:05:49,633
刚开始0是吧

166
00:05:49,966 --> 00:05:51,966
while x 小于它的长度

167
00:05:51,966 --> 00:05:54,099
长度我这边记录一下

168
00:05:54,099 --> 00:05:57,166
n 等于 len(nums) 长度

169
00:05:57,733 --> 00:06:01,466
然后 while x 小于 n 对吧

170
00:06:01,766 --> 00:06:03,666
我从左边开始看吧

171
00:06:03,666 --> 00:06:04,666
我要判断什么

172
00:06:04,666 --> 00:06:05,766
如果这个

173
00:06:06,000 --> 00:06:09,100
这个lis的要小于 i 吧

174
00:06:09,100 --> 00:06:10,566
就是 i 要大于

175
00:06:10,566 --> 00:06:12,566
如果一直大于它的话 就是这 i

176
00:06:13,700 --> 00:06:16,400
i 要大于这个 lis[x] 的话

177
00:06:17,766 --> 00:06:20,300
那么我 x += 1

178
00:06:21,033 --> 00:06:24,633
然后 如果它到最末尾了

179
00:06:24,633 --> 00:06:26,833
那我就给它添加进去

180
00:06:27,033 --> 00:06:29,400
x == len(lis) 那么我就

181
00:06:29,700 --> 00:06:31,633
lis.append(i)

182
00:06:31,833 --> 00:06:32,100
是吧

183
00:06:32,100 --> 00:06:34,100
否则的话 我就把它替换掉是吧 lis

184
00:06:35,000 --> 00:06:37,000
lis[x] 等于 i 是吧

185
00:06:37,000 --> 00:06:39,166
然后我最后面要判断它这个

186
00:06:39,400 --> 00:06:40,200
len(lis) 长度

187
00:06:40,300 --> 00:06:41,700
是不是 看一下对不对

188
00:06:41,700 --> 00:06:43,100
先跑一下测试用例

189
00:06:44,100 --> 00:06:45,400
哎不对哦

190
00:06:45,900 --> 00:06:49,866
x 等下 x 等于0 while x 小于 不是小于

191
00:06:49,900 --> 00:06:51,833
是小于这里没有错

192
00:06:51,833 --> 00:06:54,066
是小于这个len(lis)

193
00:06:54,066 --> 00:06:55,466
这个其实不是这个 n

194
00:06:55,833 --> 00:06:56,733
是因为是要

195
00:06:57,100 --> 00:06:58,066
这个列表的长度

196
00:06:58,066 --> 00:06:59,333
不是整个列表长度

197
00:06:59,333 --> 00:07:01,333
这里面弄错

198
00:07:01,333 --> 00:07:02,366
4 看下对不对

199
00:07:02,433 --> 00:07:04,333
看下 跑一下 对不对 应该过了

200
00:07:04,533 --> 00:07:06,666
应该会过 哎过了吗 对吧

201
00:07:06,933 --> 00:07:07,299
是不是

202
00:07:07,300 --> 00:07:10,166
我们就讲举个例子吧 就是刚才这个

203
00:07:10,333 --> 00:07:11,166
这个

204
00:07:12,466 --> 00:07:14,100
刚才这个这什么例子呢

205
00:07:14,633 --> 00:07:16,866
这个[0,1,0,3,2,3]了对吧

206
00:07:17,033 --> 00:07:18,733
那我这个0从我就我

207
00:07:18,733 --> 00:07:20,499
比如说我现在列表是01好了

208
00:07:20,500 --> 00:07:21,566
那我这个0

209
00:07:21,900 --> 00:07:25,633
我0从第一个位置看 如果

210
00:07:25,833 --> 00:07:28,299
如果我要的这个数字大于它的话

211
00:07:28,300 --> 00:07:29,166
我就停吗

212
00:07:29,166 --> 00:07:32,333
等于它 我就不停吗 是吧 对吧

213
00:07:32,933 --> 00:07:34,966
对对对 没错

214
00:07:34,966 --> 00:07:36,533
你看0刚才看错了

215
00:07:36,533 --> 00:07:38,033
这个0相等的部分

216
00:07:38,599 --> 00:07:41,966
01的话那么0它是放到这个位置吗

217
00:07:41,966 --> 00:07:43,533
它是要把它这个位置替换呢

218
00:07:43,533 --> 00:07:44,599
还是把这个位置替换

219
00:07:44,599 --> 00:07:46,266
它应该是把这个位置替换掉

220
00:07:46,466 --> 00:07:49,133
你看它小于它i大于它吧

221
00:07:49,766 --> 00:07:50,933
它不大于它吗

222
00:07:50,933 --> 00:07:52,666
不大于它 它不停了吗 对不对

223
00:07:52,966 --> 00:07:54,599
是不是它是要停的那位置吗

224
00:07:54,599 --> 00:07:56,033
对吧如果等于它等

225
00:07:56,033 --> 00:07:57,833
如果它比如说给一个2的话

226
00:07:57,833 --> 00:07:59,833
它大于 它大于它 是不是

227
00:07:59,833 --> 00:08:01,999
那它的这个位置 它就添加到末尾

228
00:08:01,999 --> 00:08:04,433
对不对 是不是如果是相等的话

229
00:08:04,433 --> 00:08:05,799
比如我再给个1

230
00:08:06,266 --> 00:08:09,033
大于它 不大于它 我就停下来了吗

231
00:08:09,033 --> 00:08:11,666
对吧 停下来 我不就把这个替换掉

232
00:08:11,799 --> 00:08:12,599
对不对

233
00:08:12,933 --> 00:08:16,133
然后01 然后这个3的话 就是添加到末尾

234
00:08:16,199 --> 00:08:17,733
2的话 那3的话

235
00:08:17,733 --> 00:08:19,233
你看这个是013吗

236
00:08:19,233 --> 00:08:22,066
到现在我也是013 那我3的话就3大于0

237
00:08:22,199 --> 00:08:23,066
大于1

238
00:08:23,999 --> 00:08:25,966
不大于3吗 就停下来了对吧

239
00:08:25,966 --> 00:08:28,033
所以这个是对的 是相等部分是要把它

240
00:08:28,033 --> 00:08:28,833
给替换掉

241
00:08:28,999 --> 00:08:29,833
然后这样就可以

242
00:08:29,833 --> 00:08:32,333
那这里面的时间复杂度 我们分析一下

243
00:08:32,799 --> 00:08:34,999
对吧 我这里面需要O(N)是吧

244
00:08:35,366 --> 00:08:36,766
这里需要O(N)是不是

245
00:08:37,466 --> 00:08:40,166
N个数我过一遍 是不是

246
00:08:40,433 --> 00:08:42,933
那每个我是不是都要从那个 index

247
00:08:42,933 --> 00:08:44,666
是不是要从0到这个lis的

248
00:08:44,666 --> 00:08:45,666
它可能是一直在

249
00:08:45,666 --> 00:08:47,033
正在增长

250
00:08:47,466 --> 00:08:48,199
比如说

251
00:08:48,199 --> 00:08:51,533
比如说一个严格递增的就1234567是吧

252
00:08:51,533 --> 00:08:53,233
那每次我是不是都得

253
00:08:53,466 --> 00:08:55,033
刚开始这个列表是1对吧

254
00:08:55,033 --> 00:08:56,266
然后再来2对吧

255
00:08:56,266 --> 00:08:59,933
到3再到4 这个列表是不停的在增的

256
00:08:59,933 --> 00:09:02,133
那不停的增 这个 index 就是不停的增

257
00:09:02,133 --> 00:09:04,866
那实际上就相当于 for i in range(n)

258
00:09:05,333 --> 00:09:06,133
然后 for

259
00:09:06,199 --> 00:09:09,133
那二维的这个就是 for j in range(i)

260
00:09:09,133 --> 00:09:09,466
是吧

261
00:09:09,466 --> 00:09:11,533
可以这样理解 那它实际上就是O(N平方)

262
00:09:11,533 --> 00:09:11,999
对吧

263
00:09:11,999 --> 00:09:14,799
那这里面我可以用到一个二分

264
00:09:14,799 --> 00:09:15,066
为什么

265
00:09:15,066 --> 00:09:17,033
因为这个这个列表它是递增的吗

266
00:09:17,033 --> 00:09:17,733
那我递增

267
00:09:17,733 --> 00:09:20,133
我是不是可以查找 我放在哪里

268
00:09:20,133 --> 00:09:20,766
对不对

269
00:09:20,766 --> 00:09:24,199
那我正面有一个递增有个函数叫 bisect

270
00:09:24,399 --> 00:09:26,566
我就这一串我 就可以给它干掉

271
00:09:26,566 --> 00:09:28,366
我就不要我就可以直接这么写

272
00:09:28,366 --> 00:09:29,666
我不干

273
00:09:29,666 --> 00:09:30,566
我先给它注释掉

274
00:09:30,766 --> 00:09:31,966
就是这样你就可以看

275
00:09:31,966 --> 00:09:34,466
这个是O(N) 这中间这是O(N)

276
00:09:34,733 --> 00:09:36,066
9-11行是O(N)

277
00:09:36,233 --> 00:09:39,766
那我可以用一个 x 等于 bisect_left

278
00:09:39,833 --> 00:09:42,766
这个 bisect_left 左边的 我跟你讲一下

279
00:09:43,733 --> 00:09:46,166
这个lis的一定是要有序的

280
00:09:46,166 --> 00:09:49,333
那我要找这个插入的这个位置 就是 i

281
00:09:49,366 --> 00:09:50,433
那这样就可以了

282
00:09:50,466 --> 00:09:52,866
这样应该也是可以 就把它替换掉

283
00:09:52,866 --> 00:09:53,299
对

284
00:09:53,299 --> 00:09:55,399
这样就过了 对这样就过了 会快吗

285
00:09:55,399 --> 00:09:56,866
你看刚才1秒现在

286
00:09:57,033 --> 00:09:59,733
109毫秒提高了 速度10倍吗

287
00:09:59,733 --> 00:10:00,499
对不对

288
00:10:00,499 --> 00:10:02,466
是不是这个 就是这 bisect_left 那是啥意思

289
00:10:02,466 --> 00:10:04,466
就是我这个有序 我要找它

290
00:10:04,533 --> 00:10:07,533
刚才我 就这个就这段代码的意思对吧

291
00:10:07,833 --> 00:10:10,566
就这段 我要有序的 我要找插入的位置

292
00:10:10,566 --> 00:10:12,933
那这里面 bisect_left 有个

293
00:10:12,933 --> 00:10:14,133
就是相等这个问题

294
00:10:14,133 --> 00:10:16,633
我以前跟小孩子讲过就这个

295
00:10:16,633 --> 00:10:17,833
它是从这个包来的

296
00:10:17,833 --> 00:10:19,966
from bisect import bisect_left, bisect_right

297
00:10:20,033 --> 00:10:24,133
比如这个是有序a=[1,2,2,3,3,4,5],bisect_left(a, 3)

298
00:10:24,133 --> 00:10:25,566
我要把3插入到这个位置

299
00:10:25,566 --> 00:10:26,866
它就是要找到

300
00:10:27,833 --> 00:10:29,233
找到什么大于

301
00:10:30,066 --> 00:10:32,566
第一个大于等于它的位置 就放到这

302
00:10:32,566 --> 00:10:34,299
那有个 bisect_right 是要

303
00:10:35,133 --> 00:10:36,899
严格大于它的位置对吧

304
00:10:36,899 --> 00:10:37,633
就是插入它

305
00:10:37,633 --> 00:10:39,899
有点小细微 等号的区别

306
00:10:39,899 --> 00:10:41,533
你看这边讲说 就是

307
00:10:41,766 --> 00:10:43,266
这边讲的比较绕口

308
00:10:43,266 --> 00:10:44,933
就是你要插入一个点 i

309
00:10:44,933 --> 00:10:48,366
那么所有之前的元素要严格小于它

310
00:10:48,366 --> 00:10:49,866
就是我插入这个3的这个位置

311
00:10:49,866 --> 00:10:52,233
那前面这个元素要严格小于它

312
00:10:52,466 --> 00:10:55,166
对吧那这个 bisect_right 的话它是

313
00:10:55,433 --> 00:10:55,966
它是什么呢

314
00:10:55,966 --> 00:10:59,499
它是说前面的元素可以 smaller or equal to

315
00:10:59,699 --> 00:11:01,666
就是可以是等于它的

316
00:11:01,666 --> 00:11:03,666
那比如说我把这3放到这里

317
00:11:03,966 --> 00:11:06,699
那么它前面的元素是可以等于它的

318
00:11:06,699 --> 00:11:07,066
对不对

319
00:11:07,066 --> 00:11:09,833
bisect_left  bisect_right 这是二分

320
00:11:09,833 --> 00:11:13,166
但是第一个参数是代表

321
00:11:13,166 --> 00:11:13,966
就是个列表

322
00:11:13,966 --> 00:11:15,833
有序的列表 一定是要有序的

323
00:11:15,833 --> 00:11:17,833
那这个有序二分吗

324
00:11:17,833 --> 00:11:20,099
我们讲过二分它可以去不停的分

325
00:11:20,099 --> 00:11:21,133
对半分 对半分

326
00:11:21,133 --> 00:11:23,099
那它的时间复杂度是 O(LogN)

327
00:11:23,099 --> 00:11:24,233
对吧 O(LogN)

328
00:11:24,299 --> 00:11:28,033
所以这个算法 这边这个算法是 O(LogN)

329
00:11:28,266 --> 00:11:30,633
那么加起来就是 O(NLogN) 对吧

330
00:11:30,633 --> 00:11:32,833
每 N 步里面有 LogN 步

331
00:11:33,499 --> 00:11:35,066
那就 O(NLogN) 对不对

332
00:11:35,066 --> 00:11:36,433
那它这个时间复杂度

333
00:11:36,433 --> 00:11:37,566
就要比刚才那个好

334
00:11:37,566 --> 00:11:40,266
因为 log n 是小于 n 的对不对

335
00:11:41,033 --> 00:11:42,333
它的 这个时间复杂度

336
00:11:42,333 --> 00:11:43,466
是代表这个算法

337
00:11:43,466 --> 00:11:45,666
在这个数据的那个增长

338
00:11:45,966 --> 00:11:47,066
这个增长

339
00:11:47,066 --> 00:11:49,466
增长性 我们是要去描述这个增长性

340
00:11:49,466 --> 00:11:53,699
那就是 比如说 n 从10变到100

341
00:11:54,066 --> 00:11:55,666
那么它的需要的这个

342
00:11:55,766 --> 00:11:58,433
时间的这个 running time

343
00:11:58,433 --> 00:12:00,566
还有它的这个执行的这个次数

344
00:12:00,566 --> 00:12:02,533
它的一个增长的一个情况

345
00:12:02,566 --> 00:12:03,966
对吧我们今天刚才

346
00:12:03,966 --> 00:12:06,466
刚才就是花了一点时间 在讲这个

347
00:12:06,766 --> 00:12:09,166
这个 在这一步上面有点绕口

348
00:12:09,166 --> 00:12:10,533
其实可以理解吧

349
00:12:10,533 --> 00:12:11,899
刚才我们换的这个

350
00:12:11,899 --> 00:12:14,099
比如说我3来嘛[1,2,2]

351
00:12:14,766 --> 00:12:17,299
3对吧 现在列表是 比如说[1,2,3]好了

352
00:12:17,299 --> 00:12:19,266
那我叫3要过来

353
00:12:19,266 --> 00:12:20,466
我是要把这个3换掉

354
00:12:20,466 --> 00:12:22,433
不是给它放到后面来 对吧

355
00:12:22,433 --> 00:12:22,966
这个 对吧

356
00:12:22,966 --> 00:12:26,066
假设123 这3 放就是要大于它的时候

357
00:12:26,066 --> 00:12:28,299
就 stop 等于它的时候就把它换掉

358
00:12:28,566 --> 00:12:31,333
对吧 有点绕口

359
00:12:32,066 --> 00:12:34,466
行 我们今天就讲这么个问题吧

360
00:12:34,466 --> 00:12:35,699
有什么问题吗

361
00:12:35,966 --> 00:12:38,199
没有哈 好 今天就这样

362
00:12:38,199 --> 00:12:39,499
谢谢 拜拜

