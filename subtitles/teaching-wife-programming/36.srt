1
00:00:00,700 --> 00:00:04,466
哎大家好 今天我们来讲 第36课

2
00:00:04,466 --> 00:00:06,200
今天我们来刷一个题吧

3
00:00:06,200 --> 00:00:08,133
就是最长子序列

4
00:00:08,266 --> 00:00:10,266
这里面有个概念 我们之前讲过

5
00:00:10,266 --> 00:00:11,533
最长子序列

6
00:00:11,533 --> 00:00:14,200
子序列就是英文叫做 subsequence

7
00:00:14,966 --> 00:00:17,666
有另外一个概念叫 sublist

8
00:00:17,800 --> 00:00:20,266
子列表 这个下面 是子列表

9
00:00:20,466 --> 00:00:21,766
上面是子序列

10
00:00:21,766 --> 00:00:22,933
我举个简单例子吧

11
00:00:22,933 --> 00:00:25,133
比如说一个数组是等于1

12
00:00:25,766 --> 00:00:28,600
[1,2,3,4,5,6] 对吧

13
00:00:28,600 --> 00:00:31,266
那子列表的话 它是连续的

14
00:00:31,266 --> 00:00:36,466
你可以说是[1,2],[2,3],[2,3,4],[3,4,5] 它必须连续了

15
00:00:36,500 --> 00:00:38,966
那 subsequence 它就是子序列

16
00:00:38,966 --> 00:00:40,066
它不一定是连续

17
00:00:40,066 --> 00:00:44,133
你可以135这样的134, 1346

18
00:00:44,466 --> 00:00:45,866
基本上就是你只要

19
00:00:45,900 --> 00:00:47,733
基本上就是说子序列

20
00:00:47,733 --> 00:00:49,200
说原来这个列表

21
00:00:49,200 --> 00:00:51,566
然后你随便删掉几个 (也可以不删)

22
00:00:51,766 --> 00:00:53,166
你不删 就是123456吗

23
00:00:53,166 --> 00:00:54,200
或者你可以全删

24
00:00:54,266 --> 00:00:57,333
一般来说空的也叫做 subsequence 

25
00:00:57,400 --> 00:00:59,966
你会比如说删掉2就是13456

26
00:00:59,966 --> 00:01:02,566
你可以删掉234就变成156吗对吧

27
00:01:02,566 --> 00:01:04,066
这叫 subsequence

28
00:01:04,400 --> 00:01:06,900
那子列表那是相反 那是必须连续的

29
00:01:06,933 --> 00:01:09,766
那一般解决这种问题的话 一般来说

30
00:01:09,800 --> 00:01:12,300
就是如果是子列表的话

31
00:01:12,300 --> 00:01:13,766
它一般的时间复杂度

32
00:01:13,766 --> 00:01:16,266
我们就是可以用穷举 就是 欧

33
00:01:16,266 --> 00:01:17,100
O(N平方)

34
00:01:17,100 --> 00:01:19,300
就是我怎么理解这个O(N平方)

35
00:01:19,300 --> 00:01:21,166
就是我可以随机取一个

36
00:01:21,300 --> 00:01:23,166
我可以穷举左边这个

37
00:01:23,166 --> 00:01:24,600
子列表开始的位置

38
00:01:24,933 --> 00:01:27,766
和然后可以穷举右边开始的位置对吧

39
00:01:27,766 --> 00:01:29,400
那其实它实际上你就可以说

40
00:01:29,400 --> 00:01:31,066
for i in range(n)

41
00:01:31,300 --> 00:01:32,266
这是 left 吗

42
00:01:32,266 --> 00:01:33,366
for left in range(n)

43
00:01:33,366 --> 00:01:36,800
然后 for j in range 从i到

44
00:01:37,166 --> 00:01:37,866
最右边的这

45
00:01:37,866 --> 00:01:38,466
个结尾

46
00:01:38,466 --> 00:01:40,933
这样这种形式就基本上是O(N^2)

47
00:01:40,933 --> 00:01:44,866
我只是讲说 是穷举的方法

48
00:01:44,866 --> 00:01:47,366
当然可能每道题呢有不同的

49
00:01:47,466 --> 00:01:49,600
可能会有更优的解法

50
00:01:49,600 --> 00:01:51,666
那 subsequence 它可能就是

51
00:01:51,766 --> 00:01:52,366
怎么说呢

52
00:01:52,366 --> 00:01:53,766
就是如果是穷举的方法

53
00:01:53,766 --> 00:01:56,600
它实际上是一个指数形式的

54
00:01:56,600 --> 00:01:57,600
我们可以这么理解

55
00:01:57,600 --> 00:01:58,333
就是

56
00:01:58,333 --> 00:02:01,700
就是每个这个元素你可以选或者不选

57
00:02:01,700 --> 00:02:03,800
对吧那第一个元素你有两种可能

58
00:02:03,800 --> 00:02:05,066
第二个元素有两种可能

59
00:02:05,066 --> 00:02:06,300
第三个元素有两种可能

60
00:02:06,300 --> 00:02:08,966
那么它就是2*2*2*2.... 有 n 个元素

61
00:02:08,966 --> 00:02:11,666
那就是2的 n 次方法对吧

62
00:02:11,766 --> 00:02:14,300
我们回来这个这题就是子序列

63
00:02:14,300 --> 00:02:16,266
最长子序列就是

64
00:02:16,533 --> 00:02:19,166
比如说我这个最长序列也就是123456

65
00:02:19,166 --> 00:02:19,966
对吧

66
00:02:20,266 --> 00:02:22,266
对吧那我比如说我再举个例子

67
00:02:22,333 --> 00:02:23,666
我们看这题好了

68
00:02:23,666 --> 00:02:26,200
这题它的例子就很好

69
00:02:26,200 --> 00:02:29,366
比如说这个[10,9,2,5,3,7,101,18]

70
00:02:29,400 --> 00:02:32,366
那它最长子序列就是4 因为你看嘛 2

71
00:02:32,866 --> 00:02:35,200
[2,3,7,101]

72
00:02:35,766 --> 00:02:36,733
是不是这样的

73
00:02:36,866 --> 00:02:39,500
那子序列你可以看到它不一定是要

74
00:02:40,100 --> 00:02:41,733
用完所有的元素

75
00:02:41,733 --> 00:02:42,300
不一就我

76
00:02:42,300 --> 00:02:42,866
我的意思说

77
00:02:42,866 --> 00:02:44,000
不一定最后一个元素

78
00:02:44,000 --> 00:02:45,700
不一定是最末尾那个吧

79
00:02:45,700 --> 00:02:46,733
那第一个元素

80
00:02:46,733 --> 00:02:48,466
也不一定是最开始那个元素

81
00:02:48,466 --> 00:02:50,100
它可能是中间的这个吧

82
00:02:50,166 --> 00:02:51,900
那我们再看来看一个例子

83
00:02:51,900 --> 00:02:55,733
比如说这个第二这个例子010323

84
00:02:55,900 --> 00:02:57,666
那么它是4个为什么呢

85
00:02:57,900 --> 00:02:58,866
这是0

86
00:02:59,700 --> 00:03:02,600
 123对吧

87
00:03:02,600 --> 00:03:04,900
那我们这题叫做 strictly increasing

88
00:03:04,900 --> 00:03:07,200
就说你不可能是

89
00:03:07,300 --> 00:03:10,466
相等的你不能算是这个

90
00:03:10,533 --> 00:03:11,300
列表的一部分

91
00:03:11,300 --> 00:03:14,700
你不能说0023这样不行

92
00:03:15,600 --> 00:03:18,600
那这个7777那就只有一个吗对吧

93
00:03:18,866 --> 00:03:21,733
就每个数字就是它的本身 就是一个

94
00:03:21,733 --> 00:03:24,766
因为每个单独的数字都是一个

95
00:03:24,933 --> 00:03:27,300
子序列对不对 也可能是子列表

96
00:03:27,500 --> 00:03:30,800
那么它就是长度就是一对吧

97
00:03:30,800 --> 00:03:32,766
最坏的情况下面它就是一对吧

98
00:03:32,766 --> 00:03:34,533
最好的情况下就是怎么呢

99
00:03:34,566 --> 00:03:36,966
就所有都可以用上就是有序吗

100
00:03:36,966 --> 00:03:38,933
01234567这样对不对

101
00:03:38,933 --> 00:03:41,066
可以这个题 好理解吧对吧

102
00:03:41,066 --> 00:03:43,900
这个就是今天讲的这个问题吧对

103
00:03:44,133 --> 00:03:45,100
然后

104
00:03:45,466 --> 00:03:47,500
今天我们就用一种算法就是动态规划

105
00:03:47,500 --> 00:03:48,266
我们之前讲过

106
00:03:48,266 --> 00:03:50,800
动态规划就是 dynamic programming

107
00:03:50,800 --> 00:03:53,366
就是之前

108
00:03:53,733 --> 00:03:55,300
讲过它的基本的概念吗

109
00:03:55,300 --> 00:03:56,400
它是一种思想吗

110
00:03:56,400 --> 00:03:58,700
它的思想就是说比如说

111
00:03:58,766 --> 00:04:02,100
你给个小孩子5根火柴

112
00:04:02,100 --> 00:04:04,366
然后你过一会再给TA一根火柴

113
00:04:04,766 --> 00:04:05,766
我问TA有几根火柴

114
00:04:05,766 --> 00:04:06,933
TA肯定会说六根火柴

115
00:04:06,933 --> 00:04:09,700
因为TA不用再去数手上五根火柴吗

116
00:04:09,700 --> 00:04:10,000
对吧

117
00:04:10,000 --> 00:04:12,533
TA已经知道这个TA手上有五根火柴

118
00:04:12,666 --> 00:04:15,700
再来再一根火柴那么就是六根火柴

119
00:04:15,800 --> 00:04:16,933
那这个思想就是说

120
00:04:16,933 --> 00:04:19,100
我们要把中间的这个结果给

121
00:04:19,300 --> 00:04:20,200
记录

122
00:04:20,333 --> 00:04:22,200
之前我们讲那个爬楼梯你还记得吗

123
00:04:22,200 --> 00:04:23,333
就是一个 n 层楼梯

124
00:04:23,333 --> 00:04:24,533
我们一次可以爬一步

125
00:04:24,533 --> 00:04:25,800
一次可以爬两步

126
00:04:25,966 --> 00:04:28,466
那么到最顶端需要多少步

127
00:04:28,466 --> 00:04:29,933
我们可以用 F(N) 来表示吗

128
00:04:29,933 --> 00:04:31,966
F(N) = F(N-1) + F(N-2)

129
00:04:31,966 --> 00:04:33,533
这有点像Fibonacci数列

130
00:04:33,533 --> 00:04:35,133
这个这里面也是一样

131
00:04:35,133 --> 00:04:38,300
这边 这个 Longest Increasing Subsequence

132
00:04:38,300 --> 00:04:40,066
我们假设可以用那个 d

133
00:04:40,366 --> 00:04:42,533
用一个函数叫 f(i) 好了

134
00:04:43,000 --> 00:04:44,800
那我来的这个表示什么呢

135
00:04:44,800 --> 00:04:47,200
f(i) 就是表示这 index 吗

136
00:04:47,200 --> 00:04:49,000
如果它的 index 到 i

137
00:04:49,333 --> 00:04:51,966
这个最长子序列到 i 的这个结果

138
00:04:52,933 --> 00:04:53,666
可以这么理解吧

139
00:04:53,666 --> 00:04:56,533
就是最长子序列 我如果到 i 

140
00:04:57,766 --> 00:05:01,933
我到 index i 吗 index 是0123这样吗

141
00:05:01,966 --> 00:05:04,100
012345这个是 index 

142
00:05:04,100 --> 00:05:06,500
这个我说这个 index 

143
00:05:06,666 --> 00:05:10,800
然后我们刚才这个列表 比如说是

144
00:05:11,400 --> 00:05:17,133
这 value 就下面这个010323好吧

145
00:05:17,133 --> 00:05:18,100
那这个是 index

146
00:05:18,266 --> 00:05:19,600
index 从0开始吗

147
00:05:19,733 --> 00:05:23,500
那我 F(i) 就是代表说如果 F(1)

148
00:05:23,700 --> 00:05:26,133
F(1) 的是代表说子序列

149
00:05:26,966 --> 00:05:28,400
就是到我 这

150
00:05:28,400 --> 00:05:31,566
这个最长子序列到这个 index i 结尾

151
00:05:31,566 --> 00:05:32,900
就是我不管前面怎么样

152
00:05:32,900 --> 00:05:34,766
我到这个 index 我用到这个

153
00:05:34,900 --> 00:05:38,733
这个第二个吧 index i

154
00:05:39,166 --> 00:05:41,666
的这个元素的

155
00:05:41,866 --> 00:05:44,200
子序列的最长的那个长度

156
00:05:45,000 --> 00:05:45,933
可以这么理解吧

157
00:05:45,933 --> 00:05:47,766
那我为什么要记录这个呢

158
00:05:47,766 --> 00:05:50,100
记录这个那比如说我这个2

159
00:05:50,200 --> 00:05:52,400
我一判断2比1大对不对

160
00:05:53,166 --> 00:05:54,200
那这代表什么呢

161
00:05:54,200 --> 00:05:57,966
2比1大那我是不是可以把这个2比1大

162
00:05:57,966 --> 00:06:00,166
那我是不是可以说

163
00:06:00,166 --> 00:06:03,100
我发现的这个最长子序列是不是在于

164
00:06:03,133 --> 00:06:04,200
F(i) 上面

165
00:06:04,200 --> 00:06:05,700
我可以再加一个对吧

166
00:06:05,700 --> 00:06:07,666
因为 F(i) 我知道最长子序列

167
00:06:07,666 --> 00:06:08,766
比如说它现在有2个吗

168
00:06:08,766 --> 00:06:09,866
01吗对吧

169
00:06:09,866 --> 00:06:11,333
就是这个可以这么理解

170
00:06:11,333 --> 00:06:14,566
就说01我现在我有个最长子序列是01

171
00:06:15,066 --> 00:06:15,400
对不对

172
00:06:15,400 --> 00:06:18,533
有两个元素那么我告诉你说2大于1

173
00:06:18,900 --> 00:06:20,266
那你能告我什么呢

174
00:06:20,466 --> 00:06:22,300
2大于1那我就是可以说哎

175
00:06:22,300 --> 00:06:24,800
那我就知道2我可以放到这个列表里

176
00:06:24,800 --> 00:06:26,600
面因为2比最后面那个

177
00:06:27,000 --> 00:06:28,333
那个元素大对不对

178
00:06:28,333 --> 00:06:29,500
那么它的

179
00:06:29,700 --> 00:06:31,800
最长子序列 是那个长度

180
00:06:32,100 --> 00:06:34,133
子序列是不是又加了一个元素

181
00:06:34,800 --> 00:06:37,133
对吧 但这个有什么 这个就是动态规划

182
00:06:37,133 --> 00:06:37,600
怎么说呢

183
00:06:37,600 --> 00:06:39,566
就是因为我不用去数之前的吗

184
00:06:39,566 --> 00:06:41,533
之前你已经告你已经计算过了吗

185
00:06:41,533 --> 00:06:43,133
我不用再去数了这个那个

186
00:06:43,166 --> 00:06:46,100
那太麻烦了吗 我就记录下来吗 对不对

187
00:06:46,500 --> 00:06:47,133
是不是

188
00:06:47,133 --> 00:06:49,466
那这个那我们就用这个思想

189
00:06:49,466 --> 00:06:50,466
来算一下它

190
00:06:50,466 --> 00:06:52,700
其实动态规划一般之前讲过

191
00:06:52,700 --> 00:06:56,333
可以置顶上向下 Top Down 或者 Bottom Up

192
00:06:56,766 --> 00:06:58,100
Top Down 就是怎么说呢

193
00:06:58,100 --> 00:07:00,866
我们一般就用递归的方式

194
00:07:00,866 --> 00:07:02,400
那我先写一下 define

195
00:07:02,466 --> 00:07:04,933
比如说 f function 对吧 参数 i

196
00:07:05,000 --> 00:07:07,266
如果 index 等于0的话 如果

197
00:07:07,400 --> 00:07:10,466
如果我跑到最第一个元素

198
00:07:10,466 --> 00:07:12,200
那么我应该返回多少呢

199
00:07:12,866 --> 00:07:15,766
第一个元素它的最长子序列是多少呢

200
00:07:15,866 --> 00:07:17,266
是不是一对不对

201
00:07:17,266 --> 00:07:18,933
因为它第一个元素它的

202
00:07:18,933 --> 00:07:20,266
它就是它本身吗

203
00:07:20,266 --> 00:07:21,666
对吧是不是

204
00:07:21,700 --> 00:07:23,600
那我现在 我是不是要从

205
00:07:23,600 --> 00:07:25,366
我现在answer等于1吗

206
00:07:25,366 --> 00:07:29,300
然后我就是 for j in range

207
00:07:30,000 --> 00:07:32,533
range 什么呢 range我到

208
00:07:32,933 --> 00:07:35,166
i 到 i 为止嘛

209
00:07:35,166 --> 00:07:35,900
那我就判断

210
00:07:35,900 --> 00:07:38,000
之前的元素有没有比它小嘛

211
00:07:38,000 --> 00:07:42,900
如果 nums[j] 小于 nums[i] 对吧

212
00:07:43,766 --> 00:07:44,666
是吧 那么

213
00:07:44,966 --> 00:07:45,733
nums[j]

214
00:07:45,733 --> 00:07:47,933
我发现前面的一个元素比它小

215
00:07:47,933 --> 00:07:49,900
那么我就可以说 answer 等于 max 我要取最大

216
00:07:49,933 --> 00:07:52,000
最大就是 F

217
00:07:52,300 --> 00:07:53,700
F 什么呢 F[j]

218
00:07:54,200 --> 00:07:55,400
F[j] 加1吗

219
00:07:55,400 --> 00:07:56,600
然后我 return answer

220
00:07:57,400 --> 00:07:58,766
这边我等会讲一下

221
00:07:58,766 --> 00:08:00,400
我拿我当然我要记住这个 F 嘛

222
00:08:00,400 --> 00:08:01,966
不然的话它每次都重复

223
00:08:01,966 --> 00:08:03,466
我是不是要 @cache

224
00:08:03,700 --> 00:08:05,300
@cache 我们讲过缓存吗

225
00:08:05,300 --> 00:08:06,100
就是把它

226
00:08:06,566 --> 00:08:07,166
用过一次

227
00:08:07,166 --> 00:08:08,200
我们计算过一次

228
00:08:08,200 --> 00:08:10,266
我们这个记录起来

229
00:08:10,266 --> 00:08:11,400
就是像一个记事本一样

230
00:08:11,400 --> 00:08:12,466
我算过这个 F 值

231
00:08:12,533 --> 00:08:15,100
比如说 F(5) 我算的是3

232
00:08:15,300 --> 00:08:17,733
那我下回我再看 我在需要 F(5) 的时候

233
00:08:17,733 --> 00:08:19,700
我就不再去重复计算 F(5) 了

234
00:08:19,700 --> 00:08:22,200
对吧 因为 F(5) 可能花了一分钟去算

235
00:08:22,933 --> 00:08:25,200
那我可能需要调用我需要查 F(5)

236
00:08:25,200 --> 00:08:26,200
比如说10次

237
00:08:26,400 --> 00:08:28,000
那你不可能花10次

238
00:08:28,000 --> 00:08:30,333
每次都去算5分钟

239
00:08:30,333 --> 00:08:32,466
那就50分钟我只要算一次我存起来

240
00:08:32,466 --> 00:08:34,333
我下回我要看到 F(5)

241
00:08:34,333 --> 00:08:35,533
我要这个 F(5)

242
00:08:35,533 --> 00:08:37,300
我就直接到那个表里面去取

243
00:08:37,300 --> 00:08:38,966
就是那个记事本去取对不对

244
00:08:39,066 --> 00:08:40,700
这个就是 @cache 的作用

245
00:08:41,966 --> 00:08:44,366
然后 这时候我要返回什么呢

246
00:08:44,366 --> 00:08:46,666
我要返回 max 最大是什么

247
00:08:46,666 --> 00:08:48,900
因为最长子序列 我不知道

248
00:08:48,900 --> 00:08:50,600
它是以到哪里结尾吗

249
00:08:50,600 --> 00:08:50,866
对吧

250
00:08:50,866 --> 00:08:52,933
我们刚才讲说这个子序列 它不可

251
00:08:52,933 --> 00:08:54,800
不一定是到最后一个元素

252
00:08:54,800 --> 00:08:56,900
是不是 是不是 它有可能是中间

253
00:08:56,900 --> 00:09:00,200
像我们刚才这个2 3 7 101它最后一个

254
00:09:00,500 --> 00:09:02,100
最长子序列 它是到101

255
00:09:02,100 --> 00:09:03,100
它没有到最后面吗

256
00:09:03,100 --> 00:09:03,900
对吧所 以我

257
00:09:04,166 --> 00:09:05,400
我不知道是哪里

258
00:09:05,400 --> 00:09:06,333
所以我就 F(i)

259
00:09:07,266 --> 00:09:09,266
我假设它可以到任何一个位置对吧

260
00:09:09,266 --> 00:09:12,766
for i in range(n) 这时候要外面要定一个 n

261
00:09:12,766 --> 00:09:14,533
就是 n 等于 len(nums)

262
00:09:15,300 --> 00:09:18,133
每个元素都有可能是成为

263
00:09:18,133 --> 00:09:20,500
最长子序列的最后面那个元素

264
00:09:20,500 --> 00:09:22,400
对不对 那同时这个 max 函数

265
00:09:22,400 --> 00:09:24,200
如果你给定一个 nums 是

266
00:09:24,200 --> 00:09:26,266
一个那个空的话

267
00:09:26,266 --> 00:09:27,666
那 max 它就会出错

268
00:09:27,666 --> 00:09:29,566
因为你让我取空

269
00:09:29,600 --> 00:09:30,733
这个元素是空

270
00:09:30,733 --> 00:09:32,733
那么我取最大它就没有意义吗

271
00:09:32,733 --> 00:09:34,200
是不是这时候我要加一个 default

272
00:09:34,533 --> 00:09:36,933
什么 加一个

273
00:09:37,266 --> 00:09:39,566
加一个这个 default

274
00:09:40,066 --> 00:09:41,200
等于0好了

275
00:09:41,200 --> 00:09:42,666
就是当那个我们试一下这个

276
00:09:42,666 --> 00:09:43,466
跑一下结果

277
00:09:43,466 --> 00:09:44,266
看一下对不对

278
00:09:44,466 --> 00:09:47,933
哎 max 哎对 max 我这边得

279
00:09:49,866 --> 00:09:53,166
F(i) 等一下 这个是什么问题呢

280
00:09:53,200 --> 00:09:55,333
F(i) for i in range

281
00:09:55,966 --> 00:09:58,600
对我要 我这个得这么这么写

282
00:09:58,600 --> 00:10:01,266
因为它第一个*参数* 要一个列表

283
00:10:01,566 --> 00:10:04,933
然后 default 0 这样应该就可以对 试一下

284
00:10:05,266 --> 00:10:07,933
跑一下看看 它会很慢 应该会很慢

285
00:10:07,933 --> 00:10:09,466
但还是应该可以过

286
00:10:09,900 --> 00:10:11,766
看一下 过没过 过没过

287
00:10:11,800 --> 00:10:13,066
太慢了 太慢了

288
00:10:14,933 --> 00:10:17,666
哎过了是吧 你看吧 它需要花多少时间

289
00:10:17,666 --> 00:10:19,100
6秒 7秒吗

290
00:10:19,100 --> 00:10:23,400
6948 7秒 这个用Python它给的时间

291
00:10:23,400 --> 00:10:25,866
这个容忍度就比较大

292
00:10:25,866 --> 00:10:28,100
因为Python它这个语言 相对来说会比慢

293
00:10:28,100 --> 00:10:30,066
比其它语言 C++慢

294
00:10:30,066 --> 00:10:32,533
这个以后我们讲那个编译原理

295
00:10:32,533 --> 00:10:34,300
或者讲其它编程语言的时候

296
00:10:34,300 --> 00:10:35,400
我们会顺带提一下

297
00:10:35,400 --> 00:10:36,766
解释一下为什么因为Python呢

298
00:10:36,766 --> 00:10:40,266
是相当于一个解释型的这个语言吗

299
00:10:40,266 --> 00:10:41,700
就相对来说一个脚本语言

300
00:10:41,700 --> 00:10:42,600
它会比较慢

301
00:10:42,600 --> 00:10:44,866
就是没有什么优化

302
00:10:44,866 --> 00:10:47,000
这个是这样 这个是

303
00:10:47,566 --> 00:10:48,966
这个是这种方法

304
00:10:48,966 --> 00:10:50,466
我们分析一下时间复杂度吧

305
00:10:50,466 --> 00:10:51,466
因为 F(i) 吗

306
00:10:51,466 --> 00:10:54,400
F(i) 那 i 你看这个 i

307
00:10:54,500 --> 00:10:57,200
它是问题是0到 n 减1 它就有 n 个值吗

308
00:10:57,200 --> 00:10:59,566
我要计算 F(i) 的值只有 n 个

309
00:10:59,800 --> 00:11:01,600
我最多只要计算 n 个为什么

310
00:11:01,600 --> 00:11:02,700
因为我有 @cache

311
00:11:03,100 --> 00:11:05,733
对吧我计算一次 我就给它存一次

312
00:11:05,733 --> 00:11:08,000
所以我不可能计算超过 N

313
00:11:08,333 --> 00:11:09,366
这个 N 次对不对

314
00:11:09,366 --> 00:11:10,266
可以这样理解吧

315
00:11:10,266 --> 00:11:10,766
是吧

316
00:11:10,766 --> 00:11:12,966
但是每次里面 我是不是都要循环

317
00:11:13,100 --> 00:11:14,200
循环有个内循环

318
00:11:14,200 --> 00:11:16,333
所以它时间复杂度就O(N平方)

319
00:11:16,700 --> 00:11:18,300
对吧O(N平方)对吧

320
00:11:18,300 --> 00:11:19,100
那我们

321
00:11:19,166 --> 00:11:22,566
我们也可以用那个Bottom Up 的方法

322
00:11:22,666 --> 00:11:25,333
就是用非递归的方式来算一下

323
00:11:25,466 --> 00:11:26,733
我们先把那个注释掉

324
00:11:26,733 --> 00:11:29,000
这个三个引号就是多行注释

325
00:11:29,066 --> 00:11:31,466
那我们首先就把它放在这个数组里面

326
00:11:31,466 --> 00:11:35,066
就是 dp 1乘以 n 个对吧

327
00:11:35,066 --> 00:11:38,600
这个就是代表说我要给一个那个

328
00:11:38,966 --> 00:11:40,600
我要定义一个数组

329
00:11:40,600 --> 00:11:41,766
然后有长度为 n

330
00:11:41,766 --> 00:11:44,333
然后每个值是1 对吧

331
00:11:44,400 --> 00:11:45,300
对吧

332
00:11:46,366 --> 00:11:47,600
比如说这样

333
00:11:47,600 --> 00:11:51,500
dp 等于[1]*3 它实际上 它会告诉 dp 是什么

334
00:11:51,500 --> 00:11:53,966
它会是 [1,1,1] 这样 就这么简单吧

335
00:11:54,066 --> 00:11:57,300
乘以4那 就是4个1对吧

336
00:11:57,300 --> 00:11:58,900
这个就是这种语法

337
00:11:58,900 --> 00:12:00,366
我要 n 个 然后呢

338
00:12:00,566 --> 00:12:01,800
然后我怎么弄的

339
00:12:01,800 --> 00:12:03,766
我要循环吗

340
00:12:03,766 --> 00:12:05,800
对吧 for i in range n

341
00:12:05,966 --> 00:12:08,666
对吧 然后 第二个循环就说 j in

342
00:12:09,300 --> 00:12:10,933
range i 对吧 我就判断

343
00:12:11,200 --> 00:12:14,600
我每次当 i 确定的时候 我就循环到 i

344
00:12:15,266 --> 00:12:16,400
之前的这些数字

345
00:12:16,400 --> 00:12:17,766
我判断它是不是小于它吧

346
00:12:17,766 --> 00:12:18,566
比如我

347
00:12:19,166 --> 00:12:21,200
nums[j] 小于 nums[i] 对吧

348
00:12:21,600 --> 00:12:23,100
如果前面的元素小于它

349
00:12:23,100 --> 00:12:26,400
那么我就可以说 dp[i] 等于 max dp[i]

350
00:12:27,200 --> 00:12:29,066
dp[j] 加1吗

351
00:12:29,066 --> 00:12:30,600
对吧 这就刚才我们讲的原理吗

352
00:12:30,600 --> 00:12:33,966
我01 我本来 最长子序列是01

353
00:12:33,966 --> 00:12:37,733
那么 我后面发现有一个数字2比1大

354
00:12:38,133 --> 00:12:39,866
那么我就可以把这个

355
00:12:39,866 --> 00:12:41,733
这个数字放到这个列表里面(最后面)

356
00:12:41,733 --> 00:12:45,466
能让它的最长子序列加1对不对

357
00:12:45,733 --> 00:12:47,733
是不是 然后这样子完之后

358
00:12:47,733 --> 00:12:50,166
我就可以说 return

359
00:12:50,800 --> 00:12:54,200
max dp 我要求 dp 因为我说过就是

360
00:12:54,733 --> 00:12:57,700
它有可能是最后面

361
00:12:57,900 --> 00:12:59,700
这个最长子序列 有可能

362
00:12:59,800 --> 00:13:02,966
是在任意一个 index 结束的对吧

363
00:13:02,966 --> 00:13:05,533
然后 default 等于0 这样也应该是可以的

364
00:13:06,666 --> 00:13:09,000
对这样 我们试一下应该也是可以过

365
00:13:09,000 --> 00:13:11,566
但非递归的方式 应该会比较

366
00:13:11,866 --> 00:13:13,466
比较快吧

367
00:13:13,933 --> 00:13:16,366
快一点 但实际上还是很慢的

368
00:13:17,100 --> 00:13:17,866
看一下过了

369
00:13:17,866 --> 00:13:20,266
哎 差不多 你看快了300多毫秒

370
00:13:20,266 --> 00:13:23,700
但实际上 这步 实际上我们是

371
00:13:24,266 --> 00:13:25,000
就是最后面

372
00:13:25,000 --> 00:13:27,066
再去这个 dp 数组里面取最大

373
00:13:27,066 --> 00:13:28,666
那我们实际上可以在这里面

374
00:13:28,933 --> 00:13:30,133
求吗 ans 对吧

375
00:13:30,133 --> 00:13:32,300
我碰到一个我就给它记录下来是吧

376
00:13:32,566 --> 00:13:35,133
对吧 那这时候我就不用 return dp

377
00:13:35,133 --> 00:13:35,966
我就 return ans

378
00:13:35,966 --> 00:13:37,566
这时候 answer 应该是等于1

379
00:13:37,900 --> 00:13:39,000
这样应该可以吧

380
00:13:39,500 --> 00:13:41,733
这样会有问题 如果空的话

381
00:13:41,733 --> 00:13:42,900
它是多少的

382
00:13:42,900 --> 00:13:44,333
它会不会有问题呢

383
00:13:44,600 --> 00:13:45,733
它这个数字为空吗

384
00:13:45,733 --> 00:13:48,166
我们看一下不知道 它会不会空

385
00:13:48,166 --> 00:13:50,600
Test Case 如果我们给一个空的话 它会

386
00:13:50,800 --> 00:13:51,966
它会报错吗

387
00:13:52,100 --> 00:13:55,066
就是 corner case 你看吧

388
00:13:55,066 --> 00:13:57,066
所以我们不需要考虑为空的情况

389
00:13:57,066 --> 00:13:59,900
因为它这个 test case 是没有空的吗

390
00:13:59,900 --> 00:14:00,933
对吧 所以我们不用管

391
00:14:00,933 --> 00:14:02,733
这样应该也是可以过的

392
00:14:05,566 --> 00:14:08,866
嗯好慢了 two thousand years later

393
00:14:11,466 --> 00:14:12,900
four thousand years later

394
00:14:13,600 --> 00:14:14,733
死了吧

395
00:14:15,500 --> 00:14:16,933
哎哎过哎这样

396
00:14:16,933 --> 00:14:18,500
竟然有问题

397
00:14:18,500 --> 00:14:19,066
为什么

398
00:14:19,066 --> 00:14:21,933
为什么刚才过了现在不能过了是不是

399
00:14:22,933 --> 00:14:23,933
不太可能

400
00:14:23,933 --> 00:14:26,066
刚才我就改了一行代码哎

401
00:14:27,400 --> 00:14:29,933
难道是碰巧不过 碰巧不过

402
00:14:32,566 --> 00:14:33,966
哎过了过了你看

403
00:14:34,333 --> 00:14:35,666
所以这个就是这个算法

404
00:14:35,666 --> 00:14:37,066
已经就是在于它

405
00:14:37,066 --> 00:14:39,300
我猜它是7秒钟

406
00:14:39,466 --> 00:14:42,333
那个就是慢 它有时候快 有时候慢吗

407
00:14:42,333 --> 00:14:44,000
这个已经算法已经就是极限了

408
00:14:44,000 --> 00:14:46,000
就是刚好可以

409
00:14:46,133 --> 00:14:48,133
刚好可以擦边过 如果你多按几下

410
00:14:48,133 --> 00:14:49,600
你比赛的时候有时候

411
00:14:49,666 --> 00:14:51,333
像我之前比赛的时候也是这样

412
00:14:51,333 --> 00:14:53,900
有时候这个算法就是擦边过吗

413
00:14:54,066 --> 00:14:55,600
那我就多按几下对吧

414
00:14:55,600 --> 00:14:56,800
那我就过了对不对

415
00:14:57,333 --> 00:14:58,766
对这个当然

416
00:14:58,800 --> 00:15:00,200
那比赛的时候它有个问题

417
00:15:00,200 --> 00:15:02,600
就是你每一次没过它会扣你5分钟

418
00:15:02,600 --> 00:15:04,666
就是你它会认为你的时间

419
00:15:04,666 --> 00:15:05,866
你就会被罚时吗

420
00:15:05,866 --> 00:15:07,866
就会多给你那个解决问题

421
00:15:07,866 --> 00:15:09,166
里面加5分钟

422
00:15:09,166 --> 00:15:10,900
它是这样子 就是四道题

423
00:15:11,066 --> 00:15:12,966
然后看谁的

424
00:15:13,933 --> 00:15:14,900
做的题多

425
00:15:15,133 --> 00:15:18,166
多吗 如果都做出来 那么看谁的用时少

426
00:15:18,466 --> 00:15:19,566
那用时少就是

427
00:15:19,566 --> 00:15:21,866
要么就是你真的比如说10分钟做完

428
00:15:21,866 --> 00:15:23,300
有个人20分钟做完

429
00:15:23,300 --> 00:15:26,066
但是有可能这个10分钟做完的TA

430
00:15:26,133 --> 00:15:29,733
提交了三四次都出错 TA

431
00:15:29,733 --> 00:15:31,866
那TA就要加 比如说TA 3次出错

432
00:15:31,866 --> 00:15:34,533
那么TA就要加5分钟*以3就15分钟

433
00:15:34,533 --> 00:15:36,933
TA的用时就是10加15=25分钟

434
00:15:36,933 --> 00:15:38,533
还是要比那个20分钟做

435
00:15:38,533 --> 00:15:39,900
做完的那个要慢

436
00:15:39,900 --> 00:15:42,066
对吧 所以TA 20分钟那个要比TA好

437
00:15:42,100 --> 00:15:44,866
你明白了吗 有点离题了这个

438
00:15:45,133 --> 00:15:47,366
这个就是讲这个用那个

439
00:15:47,966 --> 00:15:49,466
数组的方式去存了

440
00:15:49,500 --> 00:15:51,800
下面刚才这个也是可以的

441
00:15:52,300 --> 00:15:53,966
也是可以用类似的方法吧

442
00:15:53,966 --> 00:15:56,200
你可以是在这个里面判断

443
00:15:56,200 --> 00:15:57,866
但是写的就比较恶心 我们就不

444
00:15:57,866 --> 00:16:00,566
展开了 这个一般就是标准写法

445
00:16:00,566 --> 00:16:01,733
这是O(N平方)

446
00:16:01,733 --> 00:16:02,300
你看这个

447
00:16:02,300 --> 00:16:04,300
这个循环就很明显就是O(N平方)吗

448
00:16:04,300 --> 00:16:07,266
对一个 for 有第一个有 n 步

449
00:16:07,266 --> 00:16:09,400
然后每个 n 步里面 它会有

450
00:16:09,666 --> 00:16:10,900
类似有 n 步吗

451
00:16:10,900 --> 00:16:11,900
差不多了 n 步

452
00:16:11,900 --> 00:16:14,066
实际上呢这个是 n 加 n 加1

453
00:16:14,300 --> 00:16:16,800
n 减1 加 n 减2 加 n 减3 加 n 减4

454
00:16:16,800 --> 00:16:18,266
那你算出来展开的话

455
00:16:18,266 --> 00:16:21,533
实际上它是一个 n*(n-1)/2

456
00:16:21,533 --> 00:16:24,733
那它的那个项 就是 n 平方

457
00:16:24,933 --> 00:16:26,166
虽然它有一个除以2

458
00:16:26,166 --> 00:16:28,500
那我们计算时间复杂度的时候

459
00:16:28,500 --> 00:16:29,333
或者空间复杂度

460
00:16:29,333 --> 00:16:31,500
我们要把那个常数的

461
00:16:31,766 --> 00:16:34,966
级别的这个除以2乘以2乘以加3这种

462
00:16:35,066 --> 00:16:36,366
这种都忽略不计

463
00:16:36,366 --> 00:16:39,133
所以实际上复杂度还是O(N平方)

464
00:16:39,466 --> 00:16:40,866
我们这个算法实际上

465
00:16:40,866 --> 00:16:42,300
不是一个最优的解法

466
00:16:42,300 --> 00:16:44,900
我们下周就会讲一个最优的解法是

467
00:16:44,966 --> 00:16:46,300
是另外一种方法

468
00:16:46,300 --> 00:16:48,066
它的时间复杂度是 O(NLogN)

469
00:16:48,066 --> 00:16:51,500
它会明显会比这种算法快 我们

470
00:16:51,933 --> 00:16:54,333
对我们下周再讲 今天有什么问题吗

471
00:16:54,333 --> 00:16:55,300
嗯 没有是吧

472
00:16:55,300 --> 00:16:56,200
很 Happy 哦

473
00:16:56,200 --> 00:16:58,333
嗯好 拜拜 拜拜 拜拜

