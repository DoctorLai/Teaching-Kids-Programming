1
00:00:00,533 --> 00:00:01,266
哎大家好

2
00:00:01,266 --> 00:00:02,800
今天我们来讲第38课

3
00:00:02,800 --> 00:00:04,566
我们今天讲一个比较简单的问题

4
00:00:04,566 --> 00:00:06,166
就是 给定三个数组

5
00:00:06,300 --> 00:00:08,400
然后每个数组里面都有一些整数

6
00:00:08,400 --> 00:00:09,500
然后可能有重复的

7
00:00:09,500 --> 00:00:10,400
那我们要判断

8
00:00:10,700 --> 00:00:13,500
哪些整数出现过至少两次以上

9
00:00:13,500 --> 00:00:16,900
这至少两次是指不同的这个数组

10
00:00:16,900 --> 00:00:18,466
出现在两个数组以上吧

11
00:00:18,466 --> 00:00:19,066
这么说吧

12
00:00:19,066 --> 00:00:21,966
比如说我第一个数组是1234

13
00:00:21,966 --> 00:00:23,233
我有可能是重复的 对吧

14
00:00:23,766 --> 00:00:28,666
第二个数组可能是[2,2,3,4]

15
00:00:29,066 --> 00:00:32,733
第三个数组可能是[4,5,6]

16
00:00:32,733 --> 00:00:33,566
那么你看一下

17
00:00:33,566 --> 00:00:34,233
这些

18
00:00:34,233 --> 00:00:37,300
哪些数字是出现过至少两个数组以上

19
00:00:37,500 --> 00:00:38,633
2出现过2次

20
00:00:38,633 --> 00:00:40,900
3出现过2次 4出现过2次

21
00:00:40,900 --> 00:00:43,266
3次 5出现过2次对吧

22
00:00:43,266 --> 00:00:44,566
那就是2345对不对

23
00:00:44,566 --> 00:00:45,100
除了1吗

24
00:00:45,100 --> 00:00:46,233
对吧 还有6

25
00:00:46,333 --> 00:00:49,166
那你要返回就是2345

26
00:00:49,633 --> 00:00:51,700
对 然后 你也可以 这个顺序不重要

27
00:00:51,700 --> 00:00:54,100
你可以返回5432或者5234

28
00:00:54,166 --> 00:00:56,566
那但是每个 这个返回的这个数组

29
00:00:56,566 --> 00:00:57,066
必须是

30
00:00:57,066 --> 00:00:58,066
不含重复的

31
00:00:58,066 --> 00:00:59,733
你不能说223

32
00:00:59,766 --> 00:01:00,866
我们来看一下这题

33
00:01:00,866 --> 00:01:02,666
这个就是 Two Out of Three

34
00:01:03,100 --> 00:01:04,366
给定三个数组

35
00:01:04,366 --> 00:01:05,866
然后你只要返回一个 distinct

36
00:01:05,866 --> 00:01:07,000
就是唯一的

37
00:01:07,166 --> 00:01:08,366
不含重复的

38
00:01:08,433 --> 00:01:10,500
然后至少出现过两次

39
00:01:10,566 --> 00:01:12,500
对吧 那你可以 any order 对吧

40
00:01:12,500 --> 00:01:16,000
是吧 然后 今天就来讲这么一个题

41
00:01:16,000 --> 00:01:17,866
那这题它是有几个解法吧

42
00:01:17,866 --> 00:01:20,800
那最直观的解法 是不是就是说 我先

43
00:01:21,033 --> 00:01:21,600
找一下

44
00:01:21,600 --> 00:01:24,866
我先过一遍 这个数组1里面的数

45
00:01:24,866 --> 00:01:26,533
那我看一下这个数组1的数

46
00:01:26,766 --> 00:01:29,433
是不是出现在数组2里面

47
00:01:29,433 --> 00:01:31,266
或者出现在数组3里面

48
00:01:31,433 --> 00:01:33,166
对那我就先添加进来

49
00:01:33,533 --> 00:01:35,033
那这样并不完全嘛

50
00:01:35,033 --> 00:01:37,766
但你还需要再遍例一下数组2里面

51
00:01:37,766 --> 00:01:40,033
看一下数组3是不是也在数组3

52
00:01:40,133 --> 00:01:40,966
那我画一个图

53
00:01:40,966 --> 00:01:42,466
就是这个数组1对不对

54
00:01:42,666 --> 00:01:43,833
然后这个数组2

55
00:01:44,066 --> 00:01:45,366
这个数组3对吧

56
00:01:45,600 --> 00:01:47,800
这个是1这个是2这个3

57
00:01:47,833 --> 00:01:49,966
我刚开始说遍例数组1的数

58
00:01:49,966 --> 00:01:52,000
然后看它是不是在数组2或者数组3

59
00:01:52,000 --> 00:01:54,233
那么它应该是这一相交的部分

60
00:01:54,233 --> 00:01:55,966
是吧 这一部分

61
00:01:55,966 --> 00:01:58,766
但是你看数组2和数组3里面的

62
00:01:58,966 --> 00:02:00,033
它们又没有包进来

63
00:02:00,033 --> 00:02:01,366
所以我第二次我还要

64
00:02:01,400 --> 00:02:03,333
过滤一下这个数组2里面的数

65
00:02:03,333 --> 00:02:05,033
看一下哪些数字它

66
00:02:05,066 --> 00:02:06,366
它也出现在数组3里面

67
00:02:06,366 --> 00:02:07,733
对不对 是不是

68
00:02:07,733 --> 00:02:09,633
那我们就可以来实现一下这个

69
00:02:09,633 --> 00:02:10,733
这个简单的方法

70
00:02:10,800 --> 00:02:12,600
首先这个Answer它是一个 set

71
00:02:12,600 --> 00:02:13,866
是一个list的吧

72
00:02:13,866 --> 00:02:15,933
但是它返回是一个list的

73
00:02:15,933 --> 00:02:18,400
但是我们是需要给它用个 set

74
00:02:18,400 --> 00:02:19,200
因为呢

75
00:02:19,666 --> 00:02:22,066
因为不返回这个重复的元素吗

76
00:02:22,066 --> 00:02:24,400
我们用个 set 然后再给它转成 list 就可以了

77
00:02:24,733 --> 00:02:26,466
首先我过滤

78
00:02:26,466 --> 00:02:28,466
遍例一下这个 number 1的数

79
00:02:28,666 --> 00:02:31,333
那我判断 if i in number 2对吧

80
00:02:31,966 --> 00:02:34,766
number 2 或者 i in number three

81
00:02:34,766 --> 00:02:38,966
那是的话我就 Answer 点 add 这个 i

82
00:02:39,033 --> 00:02:40,333
然后这是

83
00:02:40,533 --> 00:02:42,733
这是第一遍 第二遍就 for i in

84
00:02:43,533 --> 00:02:44,733
number 2对吧

85
00:02:44,733 --> 00:02:48,499
然后 if i in number three 那我就把 answer 点

86
00:02:48,599 --> 00:02:49,399
点 Add i

87
00:02:49,399 --> 00:02:50,499
i

88
00:02:50,499 --> 00:02:52,133
然后我这时候 return answer 就行了

89
00:02:52,333 --> 00:02:53,599
这个 Answer 是个 set 

90
00:02:53,599 --> 00:02:55,999
但是它需要的类型是 list 的

91
00:02:55,999 --> 00:02:57,966
我们可以这么直接给它返回

92
00:02:58,166 --> 00:02:59,299
转换成 list 的

93
00:02:59,300 --> 00:03:01,100
这样应该也可以 也可以不用写吧

94
00:03:01,100 --> 00:03:03,033
我觉得它应该是自己会转换的

95
00:03:03,033 --> 00:03:03,933
我们就先不要写

96
00:03:03,933 --> 00:03:06,133
看一下它遍例一下 看看能不能过

97
00:03:06,466 --> 00:03:07,533
应该是可以过的

98
00:03:07,533 --> 00:03:08,466
好跑一遍

99
00:03:08,466 --> 00:03:09,566
哎过了对

100
00:03:09,566 --> 00:03:12,833
过了 这个 加上 list 应该也是得过

101
00:03:12,833 --> 00:03:14,300
再跑一下哎

102
00:03:14,300 --> 00:03:16,166
应该是可以过了 过了

103
00:03:16,200 --> 00:03:18,733
那这里面它有个问题就是这个 i

104
00:03:18,766 --> 00:03:20,933
你看这个 我遍例这个

105
00:03:21,333 --> 00:03:24,300
这个 nums 1的这个数就 O(N) 次吗是吧

106
00:03:24,300 --> 00:03:26,200
这个如果假设三个

107
00:03:26,366 --> 00:03:27,566
数组的长度都是 n

108
00:03:27,566 --> 00:03:30,100
好吧 那这个里面它实际上它也是 n

109
00:03:30,100 --> 00:03:31,300
因为我要判断

110
00:03:31,700 --> 00:03:33,533
判断一个数在不在这个 nums2

111
00:03:33,533 --> 00:03:34,500
nums 2 或 nums 3里面

112
00:03:34,500 --> 00:03:36,200
它要查找 它实际上是线性的查找

113
00:03:36,200 --> 00:03:37,166
这是很慢吗

114
00:03:37,166 --> 00:03:37,966
对吧

115
00:03:38,333 --> 00:03:38,933
就很慢吗

116
00:03:38,933 --> 00:03:40,833
那我们不停的进行这个操作 就很慢

117
00:03:40,833 --> 00:03:42,100
还有包括下面这个

118
00:03:42,100 --> 00:03:44,366
所以这个现在复杂度是 O(N平方)

119
00:03:44,366 --> 00:03:47,566
我们可以简单把这个 nums2 和 nums3

120
00:03:47,766 --> 00:03:49,400
都给它变成这个

121
00:03:49,533 --> 00:03:51,400
这个 set 吧就集合

122
00:03:51,400 --> 00:03:52,000
那我们把

123
00:03:52,000 --> 00:03:53,900
其实这个 nums 1也可以变成 set 了

124
00:03:53,900 --> 00:03:54,700
都可以

125
00:03:54,800 --> 00:03:56,333
s1 = set(nums1) 就这个简单

126
00:03:56,333 --> 00:03:59,166
把 list 变成 set,  s2 = set(nums2)

127
00:03:59,700 --> 00:04:01,933
s3 = set(nums3)

128
00:04:02,233 --> 00:04:04,033
那我都把它变成这个

129
00:04:04,233 --> 00:04:05,733
哈稀表 哈稀表

130
00:04:05,733 --> 00:04:08,100
这样我就判断的时候就很快嘛

131
00:04:08,100 --> 00:04:09,800
就 i in 这个 s two

132
00:04:10,033 --> 00:04:12,166
i in s three 对吧 这个是 i in

133
00:04:12,300 --> 00:04:13,600
我可以遍例这个

134
00:04:13,833 --> 00:04:16,766
遍例这个集合 而不是这个 list 的

135
00:04:16,766 --> 00:04:18,799
s2 s3

136
00:04:18,800 --> 00:04:19,833
这样的话它会快

137
00:04:19,833 --> 00:04:21,133
我们看一下 对看一下

138
00:04:21,166 --> 00:04:23,033
哎 你看快 应该是会比刚才快吧

139
00:04:23,033 --> 00:04:25,000
你看 是不是就明显吧

140
00:04:25,000 --> 00:04:27,700
173毫秒到76毫秒是不是提升了 对不对

141
00:04:28,200 --> 00:04:29,900
对 这个是这样的

142
00:04:29,900 --> 00:04:31,200
这里面它就是

143
00:04:31,233 --> 00:04:32,700
用集合的方式

144
00:04:32,700 --> 00:04:35,633
哈稀表 这个哈稀表里面去查找

145
00:04:35,733 --> 00:04:37,700
我们说过哈稀表去查找一个元素

146
00:04:37,700 --> 00:04:39,366
它是非常快

147
00:04:39,366 --> 00:04:42,433
就是常数级别的 O(1)

148
00:04:42,433 --> 00:04:43,166
常数级别的

149
00:04:43,166 --> 00:04:44,633
O(1) 这个级别的

150
00:04:44,633 --> 00:04:45,866
那这样的话就非常快

151
00:04:45,866 --> 00:04:46,900
非常快

152
00:04:46,900 --> 00:04:48,466
那我们刚才说到这个

153
00:04:48,466 --> 00:04:49,266
其实这个算法

154
00:04:49,266 --> 00:04:51,500
其实让我们实际上就是要返回 这中间

155
00:04:51,500 --> 00:04:52,100
这个相交

156
00:04:52,100 --> 00:04:52,666
这个元素吗

157
00:04:52,666 --> 00:04:54,200
是吧 这一部分吗是吧

158
00:04:54,366 --> 00:04:55,466
就这三块吗

159
00:04:55,633 --> 00:04:58,266
对吧 这1-2-4块吧 这四块

160
00:04:58,766 --> 00:05:00,400
其实那就很简单

161
00:05:00,400 --> 00:05:03,100
可以更简单的 就是 return s1

162
00:05:03,500 --> 00:05:08,100
s1 AND s2 相当于 s1.intersection(s2)

163
00:05:08,100 --> 00:05:12,266
s1.intersection(s2) 对吧 那我可以用 s1 & s2

164
00:05:12,266 --> 00:05:13,066


165
00:05:13,266 --> 00:05:16,933
或者 或者就是 UNION 就(合)并 对吧

166
00:05:17,000 --> 00:05:19,766
s2 and s3 或者

167
00:05:19,766 --> 00:05:22,733
s3 and s1 是吧

168
00:05:22,733 --> 00:05:23,966
这样你看就过了

169
00:05:23,966 --> 00:05:25,033
一样的一样的意思吗

170
00:05:25,033 --> 00:05:27,233
其实刚才我这种方法会不会更简单

171
00:05:27,233 --> 00:05:27,966
简单明了 是吧

172
00:05:27,966 --> 00:05:28,333
是不是

173
00:05:28,333 --> 00:05:30,333
其实我就是要返回这集合里面

174
00:05:30,333 --> 00:05:32,233
这个相交的部分吗

175
00:05:32,233 --> 00:05:33,600
你可以1和2相交

176
00:05:33,600 --> 00:05:35,200
或者2-3相交或者1-3相交

177
00:05:35,200 --> 00:05:36,533
就这阴影部分

178
00:05:36,533 --> 00:05:39,200
那还有一种方法 其实就是说我用一个

179
00:05:39,333 --> 00:05:42,133
我记录一下这个每个函数

180
00:05:42,133 --> 00:05:43,700
每个数出现的这个

181
00:05:44,133 --> 00:05:45,366
数组的这个 个数嘛

182
00:05:45,366 --> 00:05:47,800
我就先给它记录一下比如说 c 等于

183
00:05:48,333 --> 00:05:49,133
Counter

184
00:05:49,433 --> 00:05:50,166
Counter 好吧

185
00:05:50,166 --> 00:05:52,500
然后 我就空的 Counter 这个

186
00:05:52,500 --> 00:05:53,833
实际上如果你空的话

187
00:05:53,833 --> 00:05:55,366
你可以其实就相当于 defaultdict(int)

188
00:05:55,366 --> 00:05:57,800
defaultdict(int) 这个实际上是一样的

189
00:05:57,800 --> 00:05:59,833
那我就 遍例这个 number

190
00:06:00,133 --> 00:06:04,100
for i in 这时候我要先把它转成set(nums1)

191
00:06:04,133 --> 00:06:05,100
就是转成set的

192
00:06:05,100 --> 00:06:06,800
如果不转成set的话它会有问题

193
00:06:06,800 --> 00:06:07,833
我等会讲一下

194
00:06:08,000 --> 00:06:10,433
c 那我这时候是 c[i] 加等于1

195
00:06:10,833 --> 00:06:14,400
然后这边同样 copy 两次

196
00:06:14,400 --> 00:06:16,500
数组2里面的数过一遍

197
00:06:16,500 --> 00:06:17,733
然后把它的次数加一

198
00:06:17,733 --> 00:06:18,966
数组3里面过一遍数

199
00:06:18,966 --> 00:06:23,000
数加1然后我现在要返回 k for k, v

200
00:06:23,233 --> 00:06:24,433
in c.items()

201
00:06:24,700 --> 00:06:26,500
就是这个数的这个

202
00:06:26,633 --> 00:06:28,400
这个 dictionary 里 我要判断

203
00:06:28,400 --> 00:06:29,800
如果 v 要大于1

204
00:06:29,800 --> 00:06:31,966
大于1或者大于等于2都可以

205
00:06:31,966 --> 00:06:34,600
大于等于2这样我先看一下 对不对

206
00:06:34,800 --> 00:06:36,033
哎过了过了

207
00:06:36,133 --> 00:06:38,200
这个是实际上就是说我这个 Counter

208
00:06:38,200 --> 00:06:39,033
我就是记录

209
00:06:39,033 --> 00:06:41,300
它每个数出现的这个频率

210
00:06:41,300 --> 00:06:44,600
那我需要每个数组我先去重嘛

211
00:06:44,600 --> 00:06:45,533
去重复的

212
00:06:45,533 --> 00:06:47,366
如果不去重的话它会有问题

213
00:06:47,366 --> 00:06:48,900
假设我不去重的话

214
00:06:49,333 --> 00:06:49,966
它是会有问题

215
00:06:49,966 --> 00:06:53,233
它会如果你一个数组里面还有多个

216
00:06:53,500 --> 00:06:55,966
还有比如说还有多个重复的这个数字

217
00:06:55,966 --> 00:06:56,900
比如说11

218
00:06:57,000 --> 00:06:59,333
那它就它实际上就会报错吗

219
00:06:59,333 --> 00:07:01,366
你看我这样的话它会报错了

220
00:07:01,500 --> 00:07:02,900
它应该是会报错的

221
00:07:02,833 --> 00:07:04,133
对吧嗯

222
00:07:04,133 --> 00:07:05,566
这因为你看嘛一一

223
00:07:05,600 --> 00:07:07,400
它一一就认为它已经出现多次

224
00:07:07,400 --> 00:07:08,300
但实际上不是吗

225
00:07:08,300 --> 00:07:09,166
所以我这个要 Set

226
00:07:09,166 --> 00:07:10,333
把它给弄回来

227
00:07:10,533 --> 00:07:12,933
然后我这个是 c 点 items()

228
00:07:13,166 --> 00:07:15,500
k 就是它的这个数字

229
00:07:15,500 --> 00:07:16,900
v 就是它出现的频率

230
00:07:16,900 --> 00:07:18,133
出现的频率

231
00:07:18,133 --> 00:07:19,200
这个是讲说

232
00:07:19,300 --> 00:07:21,600
出现在多个数组的频率

233
00:07:21,600 --> 00:07:22,633
因为我们已经去重了

234
00:07:22,633 --> 00:07:23,766
所以它如果出现两次

235
00:07:23,766 --> 00:07:26,333
那肯定是只能出现在两个数组里面

236
00:07:26,333 --> 00:07:28,700
然后如果 v大于等于2的话

237
00:07:28,700 --> 00:07:30,400
就是至少出现两次了

238
00:07:30,400 --> 00:07:32,766
那我其实际上 我不用写这么麻烦

239
00:07:32,766 --> 00:07:34,633
我可以这么给它 list 的

240
00:07:34,966 --> 00:07:37,566
这个 set(nums1)

241
00:07:37,633 --> 00:07:39,200
然后把它直接

242
00:07:39,200 --> 00:07:40,600
放到这里面来就可以了

243
00:07:41,033 --> 00:07:43,000
加这个

244
00:07:43,000 --> 00:07:45,233
一二

245
00:07:45,233 --> 00:07:48,600
三 然后 它就能帮它自己帮我数吗

246
00:07:48,600 --> 00:07:50,666
那这样的话两行就可以了对吧

247
00:07:50,666 --> 00:07:52,433
哎对这就可以了

248
00:07:52,433 --> 00:07:54,866
Counter 就是给定一个这个对象

249
00:07:54,999 --> 00:07:58,999
数组或者是字符串 都可以帮你数

250
00:07:59,166 --> 00:08:00,199
进行数嘛

251
00:08:00,199 --> 00:08:01,466
就是看一下有多少个

252
00:08:01,466 --> 00:08:03,099
每个元素里面出现多少次嘛

253
00:08:03,099 --> 00:08:04,699
那我就先把它转成 List 的

254
00:08:04,699 --> 00:08:06,766
然后把它叠加起来它就是一个列表

255
00:08:06,899 --> 00:08:08,866
那我再判断它这个

256
00:08:08,866 --> 00:08:11,399
判断它这个次数出现过两次

257
00:08:11,399 --> 00:08:13,566
就出现过两次的这个数是多少

258
00:08:13,566 --> 00:08:15,666
把它放在这个这个List的

259
00:08:15,666 --> 00:08:17,266
这也是一种方法对吧

260
00:08:17,266 --> 00:08:20,233
好 嗯 拜拜 拜拜

