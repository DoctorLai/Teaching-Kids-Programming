1
00:00:00,300 --> 00:00:02,566
大家好 今天讲第**39**课

2
00:00:02,566 --> 00:00:04,966
比较简单叫 Running Sum Of

3
00:00:04,966 --> 00:00:06,066
一维的数组

4
00:00:06,066 --> 00:00:07,799
就是我们看一下这题吧

5
00:00:07,799 --> 00:00:10,099
它实际上就是说 比如给定一个

6
00:00:10,100 --> 00:00:11,033
数组1234

7
00:00:11,033 --> 00:00:13,199
那么你要告诉我这个 第一个就是1

8
00:00:13,199 --> 00:00:14,399
第二个就是1加2

9
00:00:14,399 --> 00:00:17,499
第三个就是1加2加3, 1加2加3加4对吧

10
00:00:17,899 --> 00:00:18,599
那这很简单吧

11
00:00:18,599 --> 00:00:22,299
你看这个题1那这11111就是12345

12
00:00:22,300 --> 00:00:24,500
这个 你要返回这个新的这个数组

13
00:00:24,500 --> 00:00:27,266
它不一定说那个 可不可以改呢

14
00:00:27,266 --> 00:00:28,500
可以改就是

15
00:00:28,500 --> 00:00:29,700
但你要返回一个数组

16
00:00:29,700 --> 00:00:33,100
每个新的这个元素是它

17
00:00:33,100 --> 00:00:35,566
从最开始到它本身的之和

18
00:00:35,566 --> 00:00:38,800
对吧 那我们可以有两种方法吧

19
00:00:38,800 --> 00:00:41,266
首先一种就是 我新建一个数组呗

20
00:00:41,266 --> 00:00:43,866
Answer等于空的列表[] 对吧 然后我

21
00:00:43,866 --> 00:00:47,000
然后我就可以我有一个 s 等于现在

22
00:00:47,300 --> 00:00:50,100
之和吗 我刚开始是之和是0 对吧

23
00:00:50,300 --> 00:00:52,400
我就遍例一下原来这个数组

24
00:00:52,733 --> 00:00:54,733
那我就 s 加等于 i 好吧

25
00:00:54,733 --> 00:00:56,600
然后 ans.append(s)

26
00:00:56,666 --> 00:00:58,600
对吧 我每次就把这个累加

27
00:00:58,600 --> 00:01:00,400
这个 s 就相当于累加之和吗

28
00:01:00,400 --> 00:01:01,800
那累加完之后我就把它

29
00:01:01,866 --> 00:01:03,333
添加到这个Answer里面

30
00:01:03,333 --> 00:01:05,266
对吧 这是一种方法

31
00:01:05,266 --> 00:01:06,666
return ans 看一下会不会过

32
00:01:06,666 --> 00:01:08,033
先跑一下测试用例

33
00:01:08,033 --> 00:01:09,333
过了 这是一种方法

34
00:01:09,333 --> 00:01:10,833
这个就是用了额外的数组

35
00:01:10,833 --> 00:01:12,500
那用了额外数组这个

36
00:01:12,500 --> 00:01:14,100
空间复杂度就是 O(N)

37
00:01:14,100 --> 00:01:15,233
那时间复杂度也是 O(N)

38
00:01:15,233 --> 00:01:17,266
因为我们要遍例一下这个数组对吧

39
00:01:17,266 --> 00:01:18,799
那另外一种方法就是

40
00:01:18,800 --> 00:01:20,433
我可以直接修改这个数组

41
00:01:20,433 --> 00:01:23,266
就是 n 等于 首先我判断它长度

42
00:01:23,700 --> 00:01:26,033
然后它后面一个 是不是可以等于累加

43
00:01:26,033 --> 00:01:26,933
我就可以累加了

44
00:01:26,933 --> 00:01:29,633
for i in range 从第二个元素开始

45
00:01:29,633 --> 00:01:33,266
2就是 index 1到结尾

46
00:01:33,433 --> 00:01:34,900
那我们就说 nums[i]

47
00:01:34,900 --> 00:01:37,433
nums[i] += nums[i-1]

48
00:01:37,433 --> 00:01:39,833
就是 我比如说第二个元素

49
00:01:39,966 --> 00:01:41,666
第二个元素就等于

50
00:01:41,966 --> 00:01:43,966
它本身加上它就是3了吗

51
00:01:43,966 --> 00:01:44,999
就变成3了

52
00:01:45,166 --> 00:01:46,866
然后到这里的时候就是3

53
00:01:46,866 --> 00:01:48,099
加它前面那个元素

54
00:01:48,099 --> 00:01:49,099
就是3吗

55
00:01:49,099 --> 00:01:50,033
6吗是吧

56
00:01:50,033 --> 00:01:51,666
然后这个就改成6

57
00:01:51,666 --> 00:01:55,299
然后到这个4的时候 就4加上前面

58
00:01:55,299 --> 00:01:57,399
已经改过就变成4加6, 10吗

59
00:01:57,566 --> 00:01:59,066
我跑一下应该也是可以过的

60
00:01:59,066 --> 00:02:00,199
跑一下测试用例

61
00:02:00,200 --> 00:02:01,166
过了

62
00:02:01,166 --> 00:02:02,066
哎过了吧 对吧

63
00:02:02,066 --> 00:02:03,633
这是一种方法直接修改数组

64
00:02:03,633 --> 00:02:05,299
那它这个时间复杂度还是 O(N)

65
00:02:05,299 --> 00:02:06,433
但是空间复杂度

66
00:02:06,633 --> 00:02:09,366
我们没有用到那个额外的数组

67
00:02:09,433 --> 00:02:10,899
那这就是 O(1) - constant 常数级别

68
00:02:11,466 --> 00:02:12,333
空间复杂度

69
00:02:12,499 --> 00:02:14,899
那Python里面实际上可以直接这么写

70
00:02:14,899 --> 00:02:16,966
return accumulate 有个

71
00:02:16,966 --> 00:02:18,633
accumulate 函数就是做这个用了

72
00:02:18,633 --> 00:02:20,266
就 accumulate(nums) 就可以了

73
00:02:20,499 --> 00:02:22,233
就是用到它内置 (itertools 包) 的这个函数

74
00:02:22,233 --> 00:02:23,033
你看很快吧

75
00:02:23,033 --> 00:02:24,466
就这么一句话对吧

76
00:02:24,466 --> 00:02:26,733
那这个题本身是很简单

77
00:02:26,733 --> 00:02:27,499
那我们来

78
00:02:27,499 --> 00:02:29,566
研究一下为什么要有这么个玩意了

79
00:02:29,566 --> 00:02:32,133
对吧 它实际上是有一个用处的 (前缀和)

80
00:02:32,133 --> 00:02:35,066
就是比如说 我现在 我要求和吗对吧

81
00:02:35,066 --> 00:02:37,566
我要求任意这个数组里面 任意

82
00:02:37,566 --> 00:02:40,466
任意两个区间的和

83
00:02:40,466 --> 00:02:42,499
比如说 求2加3对不对

84
00:02:42,533 --> 00:02:43,533
就5吗对吧

85
00:02:43,933 --> 00:02:45,533
或者这边

86
00:02:45,633 --> 00:02:47,133
这1加2加10就是

87
00:02:47,133 --> 00:02:49,833
我要求任意数组里面一个区间和

88
00:02:49,833 --> 00:02:51,666
那如果我没有用到这个

89
00:02:51,666 --> 00:02:53,733
没有用到这种 accumulate 的话

90
00:02:53,733 --> 00:02:55,666
那我是不是我就得累加

91
00:02:55,666 --> 00:02:57,599
就1加2加4每次都这么累加

92
00:02:57,599 --> 00:02:58,833
那你假设我每次

93
00:02:58,866 --> 00:03:00,533
我这个操作的很多

94
00:03:00,533 --> 00:03:01,933
那我每次都要进行

95
00:03:02,266 --> 00:03:04,399
动态的去累加就很慢了 对吧

96
00:03:04,633 --> 00:03:05,633
那我有一个方法

97
00:03:05,633 --> 00:03:08,233
就是我比如说我可以先用

98
00:03:08,266 --> 00:03:10,666
先存一个这个 accumulate 的 就前缀和吗

99
00:03:10,666 --> 00:03:12,666
accumulate 叫前缀 prefix sum

100
00:03:13,133 --> 00:03:14,066
那这个有什么好处

101
00:03:14,066 --> 00:03:15,099
你看我比如说

102
00:03:15,100 --> 00:03:16,366
我要累加2加3吗

103
00:03:16,366 --> 00:03:17,166
对吧

104
00:03:17,166 --> 00:03:20,266
我画一个图吧就比较可以理解

105
00:03:20,266 --> 00:03:25,199
比如说这个1这个2这个3这个4

106
00:03:25,299 --> 00:03:27,933
这个5再加一个6吧

107
00:03:27,933 --> 00:03:31,099
比如说我要算3加5这段和吗

108
00:03:31,099 --> 00:03:32,633
对 我要算这段和对吧

109
00:03:32,733 --> 00:03:36,733
那它实际上是不是等于1-5的的和对吧

110
00:03:36,966 --> 00:03:37,933
减去

111
00:03:38,799 --> 00:03:40,366
1-2的和对不对

112
00:03:40,966 --> 00:03:42,333
可以这么理解

113
00:03:42,366 --> 00:03:44,533
是不是 我要加3加4加5

114
00:03:44,533 --> 00:03:45,433
实际上这个和

115
00:03:45,433 --> 00:03:47,533
是不是等于1加2加3加4加5

116
00:03:47,533 --> 00:03:48,166
是等于多少呢

117
00:03:48,166 --> 00:03:52,099
15是吧 15再减去前面两个数之和3

118
00:03:52,833 --> 00:03:55,533
是吧那就是等于15减3就等于12

119
00:03:55,533 --> 00:03:57,366
你看3加4加5就是12

120
00:03:57,533 --> 00:03:59,699
那我如果 首先 我先

121
00:03:59,933 --> 00:04:01,099
给它算一遍的话

122
00:04:01,099 --> 00:04:03,099
那么我存一下这个 prefix sum

123
00:04:03,099 --> 00:04:06,366
那我再去算任意区间的这个和的话

124
00:04:06,366 --> 00:04:07,799
那我实际上我就是

125
00:04:08,100 --> 00:04:10,600
只要去取这个

126
00:04:10,633 --> 00:04:11,900
这个 prefix

127
00:04:11,966 --> 00:04:14,766
这个sum 1到5这个位置是15

128
00:04:14,966 --> 00:04:19,300
那我到2这个位置是3 那15减3就等于12

129
00:04:19,300 --> 00:04:20,400
那么它的这个

130
00:04:20,533 --> 00:04:21,333
就很快吗

131
00:04:21,333 --> 00:04:22,700
因为我只是去取

132
00:04:22,933 --> 00:04:24,766
取两个数字 做一下减

133
00:04:24,800 --> 00:04:27,700
那我们就不用去说3加4加5

134
00:04:27,700 --> 00:04:29,733
那你想这个3加4加5

135
00:04:29,733 --> 00:04:30,600
它有可能是

136
00:04:30,600 --> 00:04:32,733
比如说中间有10,000个数好了

137
00:04:32,933 --> 00:04:34,733
对吧 那我这样加的很慢吗

138
00:04:34,733 --> 00:04:35,533
如果我要算

139
00:04:36,133 --> 00:04:38,400
3到5之间假设中间有1万个数

140
00:04:38,400 --> 00:04:39,900
那你如果之前的方法

141
00:04:39,900 --> 00:04:41,966
是不是要得加1万个数字

142
00:04:42,100 --> 00:04:45,233
现在我只要取这两个数字做相减

143
00:04:45,300 --> 00:04:45,966
我这个

144
00:04:45,966 --> 00:04:48,133
而且这个数字我是之前已经计算过了

145
00:04:48,133 --> 00:04:49,700
我就不用再重新计算对吧

146
00:04:49,733 --> 00:04:52,366
这个它时间复杂度就变成了 O(1) constant

147
00:04:52,433 --> 00:04:53,833
这就是我们先

148
00:04:53,933 --> 00:04:55,966
用一个空间去换一个时间

149
00:04:55,966 --> 00:04:57,500
就我先想要预存下来

150
00:04:57,500 --> 00:04:59,000
然后 我之后再查表计算

151
00:04:59,133 --> 00:05:01,900
有点这个意思吧 对吧

152
00:05:01,900 --> 00:05:05,033
嗯 那今天就讲到这吧 有什么问题吗

153
00:05:05,333 --> 00:05:06,966
没有, 好, 拜拜, 拜拜

