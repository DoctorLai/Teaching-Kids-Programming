1
00:00:00,333 --> 00:00:03,000
哎大家好 今天我们讲第15课

2
00:00:03,000 --> 00:00:04,766
合并两个有序数列

3
00:00:05,166 --> 00:00:06,366
那两个有序数列

4
00:00:06,466 --> 00:00:08,500
就是说两个数列 它是

5
00:00:08,900 --> 00:00:10,633
它是有序的 那我们怎么跟它合并起来

6
00:00:10,633 --> 00:00:12,333
比如说我们现在有两个数列 a

7
00:00:12,733 --> 00:00:16,533
[1,3,5,7,9] 对吧

8
00:00:16,933 --> 00:00:17,766
这是有序的吗

9
00:00:17,766 --> 00:00:19,500
它就是排序的 然后 b 是

10
00:00:20,433 --> 00:00:21,633
246

11
00:00:22,266 --> 00:00:23,400
6 8 10 好了

12
00:00:24,433 --> 00:00:26,900
那我们怎么把它合并起来变成 c

13
00:00:26,900 --> 00:00:29,833
是123456789呢

14
00:00:29,866 --> 00:00:30,633
对吧

15
00:00:30,633 --> 00:00:33,000
就我们今天要讲的就是这么一个问题

16
00:00:33,000 --> 00:00:34,300
还有个10

17
00:00:34,300 --> 00:00:36,233
9 10 对, 很好

18
00:00:36,433 --> 00:00:38,966
对 那这个怎么弄呢

19
00:00:38,966 --> 00:00:40,666
这个比如说我们先这么写吧

20
00:00:40,666 --> 00:00:43,066
让我们先定义一个Merge对吧

21
00:00:43,666 --> 00:00:45,133
那然后 a b

22
00:00:45,533 --> 00:00:46,500
然后这时候

23
00:00:47,200 --> 00:00:48,900
我还没写

24
00:00:48,900 --> 00:00:51,566
那我这时候 我如果比如说调用它的话

25
00:00:52,166 --> 00:00:55,233
a b 那它应该给我返回是那个

26
00:00:55,900 --> 00:00:57,266
123456789,10吗

27
00:00:57,300 --> 00:00:59,700
如果假定这两个是有序的话

28
00:00:59,700 --> 00:01:01,100
那一个很简单的方法

29
00:01:01,100 --> 00:01:02,966
就是我把它两个加起来再排序

30
00:01:02,966 --> 00:01:05,400
对不对 那 c 等于 a 加 b

31
00:01:05,500 --> 00:01:06,366
那 c 等于 a 加 b

32
00:01:06,366 --> 00:01:09,466
这时候它是135792468,10但它不是排好序的

33
00:01:09,466 --> 00:01:10,266
对吧 嗯

34
00:01:10,266 --> 00:01:12,166
那我再给c.sort()对吧

35
00:01:12,333 --> 00:01:14,733
嗯 那这时候我们是上一节课讲的

36
00:01:14,733 --> 00:01:15,733
排序的时间复杂度是

37
00:01:15,733 --> 00:01:17,066
排序的时间复杂度是 O(NLogN)

38
00:01:17,733 --> 00:01:20,500
当那个 c 的元素是

39
00:01:20,966 --> 00:01:21,800
n 个的时候

40
00:01:21,800 --> 00:01:24,966
那这时候 c 的元素比如说是 a 加 b 吗

41
00:01:24,966 --> 00:01:26,833
对吧 所以实际上是 a 加 b

42
00:01:27,466 --> 00:01:28,700
Log(A+B)

43
00:01:29,100 --> 00:01:31,266
a 个数加 b 个数 实际上是这样子

44
00:01:31,466 --> 00:01:33,133
return c 我们先试一下

45
00:01:33,133 --> 00:01:34,400
对123456789, 10

46
00:01:34,900 --> 00:01:36,233
如果我不加这一行的话

47
00:01:36,733 --> 00:01:39,666
它就是135792468,10 对吧

48
00:01:40,300 --> 00:01:41,333
这是最原始的方法

49
00:01:41,333 --> 00:01:42,866
它这个时间复杂度是这样

50
00:01:43,533 --> 00:01:44,800
那我先给它改成 merge1

51
00:01:45,366 --> 00:01:48,033
那我们这还有一种方法比较讨巧就是

52
00:01:48,200 --> 00:01:49,966
它因为有序了吗 我两个

53
00:01:50,666 --> 00:01:53,733
我首先有2个指针 指向1 和 指向2

54
00:01:53,733 --> 00:01:55,033
就是分别指向它这个

55
00:01:55,033 --> 00:01:56,266
数列的首 对吧

56
00:01:56,566 --> 00:01:59,233
开始 然后我就比较 如果1小于2的话

57
00:01:59,833 --> 00:02:03,266
那么我就加入1 然后把1往前移一格

58
00:02:03,966 --> 00:02:05,366
那这3跟2比

59
00:02:05,966 --> 00:02:07,766
2比较小 你这不更麻烦吗

60
00:02:08,099 --> 00:02:09,033
但是它快

61
00:02:09,433 --> 00:02:11,633
但你等会 我给你看一下为什么会快

62
00:02:11,633 --> 00:02:12,833
你懂我的意思吧

63
00:02:12,833 --> 00:02:15,299
def merge2

64
00:02:15,299 --> 00:02:17,533
a b 那 我首先我要

65
00:02:17,599 --> 00:02:19,999
两个长度 la, lb 等于 len(a)

66
00:02:20,399 --> 00:02:21,499
len(b) 对吧

67
00:02:21,799 --> 00:02:24,433
那我这个 c 刚开始是 [] 是

68
00:02:24,666 --> 00:02:26,133
空的 然后比如说 i

69
00:02:26,533 --> 00:02:28,699
等于 j 等于0 最开始 然后

70
00:02:29,099 --> 00:02:31,633
i 小于 la

71
00:02:32,333 --> 00:02:35,599
当第一个指针 i 没有移到最

72
00:02:35,733 --> 00:02:38,366
最末位的时候从 它从 i 是从这里

73
00:02:38,699 --> 00:02:41,566
第一个到最后一个 j 是从这个 b

74
00:02:41,799 --> 00:02:42,899
走到最后一个

75
00:02:43,299 --> 00:02:45,866
对吧 并且 j 要小于 lb

76
00:02:46,266 --> 00:02:47,199
lb 的话

77
00:02:47,533 --> 00:02:49,666
然后 这时候就判断 如果 a[i]

78
00:02:49,733 --> 00:02:51,966
小于 b[j] 那这时候 我要用谁呢

79
00:02:52,799 --> 00:02:53,566
当

80
00:02:53,566 --> 00:02:56,499
还没两个人都没有走到底的时候

81
00:02:56,933 --> 00:02:58,933
我们假设i和j两个人

82
00:02:58,966 --> 00:03:01,733
然后 i 最开始在 a 的队首

83
00:03:01,933 --> 00:03:04,766
 j 是在 b 的队首, 那么它们同时往前走

84
00:03:04,866 --> 00:03:06,233
它们每走一步的话

85
00:03:06,233 --> 00:03:07,399
就得判断 a[i] 小

86
00:03:07,399 --> 00:03:10,766
b[j] 的话 我们就用 a[i] 吗对吧

87
00:03:10,933 --> 00:03:13,133
因为是小的那个 那我就是 c.append(a[i])

88
00:03:13,433 --> 00:03:15,466
a[i] 那 append 完的时候是

89
00:03:15,466 --> 00:03:17,399
是不是 i 要往前走一步 对不对

90
00:03:17,933 --> 00:03:20,233
那否则的话就是 c.append(b[j])

91
00:03:20,966 --> 00:03:22,766
b[j] 是吧

92
00:03:22,766 --> 00:03:25,799
b[j] 那这要向前走一步吗 对吧

93
00:03:26,166 --> 00:03:27,499
那完了之后是不是

94
00:03:27,833 --> 00:03:30,833
如果它两个长度不相等的时候

95
00:03:30,999 --> 00:03:32,633
那是不是有一个会先走到

96
00:03:32,933 --> 00:03:34,399
对吧 那这时候 比如我

97
00:03:34,433 --> 00:03:36,899
我就给再加一个20好了

98
00:03:37,366 --> 00:03:38,599
对吧b的比较长

99
00:03:39,633 --> 00:03:42,133
那这时候我就判断了 是吧 如果

100
00:03:43,033 --> 00:03:46,066
i 小于 la 的话

101
00:03:46,133 --> 00:03:48,166
如果 la 还没走到

102
00:03:48,533 --> 00:03:50,433
i 还没走到最末尾

103
00:03:50,433 --> 00:03:52,966
那我是不是把剩下 i 的部分全部都

104
00:03:53,233 --> 00:03:55,699
都添加到那个 c 里面去 对不对

105
00:03:55,933 --> 00:03:59,433
那我就可以c点 extend 等会跟你讲 extend 的意思

106
00:03:59,766 --> 00:04:01,266
这个 a[i]

107
00:04:02,233 --> 00:04:03,266
到末尾 对吧

108
00:04:03,666 --> 00:04:04,866
否则的话就是

109
00:04:05,166 --> 00:04:06,266
j 没有到吗

110
00:04:06,266 --> 00:04:06,933
你可以这么写

111
00:04:06,933 --> 00:04:09,933
j < lb 那写的明显一点对吧

112
00:04:10,099 --> 00:04:11,133
只有一种情况吗

113
00:04:11,133 --> 00:04:12,999
对它不可能两个情况满足吗

114
00:04:12,999 --> 00:04:14,166
它要么是i没走到

115
00:04:14,166 --> 00:04:16,166
要么j没走到, 不可能

116
00:04:16,299 --> 00:04:18,099
i 和 j 同时没走到

117
00:04:19,399 --> 00:04:21,266
对那这样我们就 return c

118
00:04:22,466 --> 00:04:23,566
先看一下 对不对

119
00:04:24,033 --> 00:04:26,599
merge什么 没有merge这个 是merge什么

120
00:04:27,033 --> 00:04:28,766
merge2吧 对merge2

121
00:04:28,766 --> 00:04:32,399
135791357 哎 不对不对 有问题

122
00:04:33,166 --> 00:04:33,966
不对不对

123
00:04:34,466 --> 00:04:36,999
没有没有 这个刚才走错了

124
00:04:37,000 --> 00:04:38,166
i < la

125
00:04:38,900 --> 00:04:40,833
这里 c 点

126
00:04:41,000 --> 00:04:42,366
这应该是 b[j:]

127
00:04:42,700 --> 00:04:43,933
这个看一下对不对

128
00:04:44,400 --> 00:04:47,900
应该13579246842, 10哎也不对吗 对吧

129
00:04:47,966 --> 00:04:49,466
那这里肯定有问题吗是吧

130
00:04:49,600 --> 00:04:52,033
来来分析一下分析一下

131
00:04:52,033 --> 00:04:53,066
看出来了 有问题了

132
00:04:53,066 --> 00:04:54,800
来 la 等等等等

133
00:04:55,233 --> 00:04:57,399
如果 a[i] 小于 b

134
00:04:57,566 --> 00:05:00,566
哦 b[j] 看到没有对吧 这个写错了

135
00:05:00,799 --> 00:05:02,799
这个很容易写错 来我们试一下

136
00:05:03,999 --> 00:05:05,566
123456789,10,20吗

137
00:05:05,566 --> 00:05:08,233
对吧 那如果 你看一下这个长一点的话

138
00:05:08,233 --> 00:05:10,133
比如说加个 [30, 40]

139
00:05:10,799 --> 00:05:11,833
对吧你看一下它

140
00:05:11,866 --> 00:05:12,966
它是不是也是对的

141
00:05:13,566 --> 00:05:15,933
没错吧 它排好序吗

142
00:05:15,933 --> 00:05:18,699
这个 extend 就是把

143
00:05:19,499 --> 00:05:20,899
extend 这个就是数列

144
00:05:20,899 --> 00:05:26,599
比如说 a 等于1234 然后 b 等于5678

145
00:05:26,599 --> 00:05:28,633
那么 a 点 extend b

146
00:05:28,966 --> 00:05:31,166
那 a 就变成 12345678

147
00:05:31,299 --> 00:05:33,566
就是 extend 把它延长吗 对吧

148
00:05:33,899 --> 00:05:34,699
这个意思

149
00:05:35,266 --> 00:05:37,099
这个时间复杂度是多少呢

150
00:05:37,099 --> 00:05:40,799
分析一下 就 i 从头走到尾

151
00:05:41,266 --> 00:05:43,366
j 从头走到尾

152
00:05:43,599 --> 00:05:47,133
那长度是不是最多走 a 加 b 是不是

153
00:05:47,199 --> 00:05:49,533
是不是 它的时间复杂度实际上是

154
00:05:49,899 --> 00:05:51,633
O(A+B) 嘛

155
00:05:51,633 --> 00:05:53,533
那哪一个好呢？

156
00:05:53,533 --> 00:05:56,233
(A+B)*Log(A+B) 或者是 (A+B)

157
00:05:57,199 --> 00:05:59,466
因为 log(A+B)是大于1的吗

158
00:05:59,466 --> 00:06:01,133
对不对 一般来说对不对

159
00:06:01,233 --> 00:06:02,833
假设它大于1吗 对不对

160
00:06:03,166 --> 00:06:04,099
那假设大于1

161
00:06:04,099 --> 00:06:06,799
所以这个东西 a 加 b 应该会比它小

162
00:06:06,799 --> 00:06:07,666
是不是嗯

163
00:06:07,799 --> 00:06:10,199
所以这个算法会比较好 它是线性的吗

164
00:06:10,366 --> 00:06:12,499
这个实际上是不是线性它是 O(NLogN)

165
00:06:12,499 --> 00:06:14,066
这种算法 不是线性的

166
00:06:14,166 --> 00:06:16,466
那我们再复习一下对吧

167
00:06:17,333 --> 00:06:18,233
主要是这个判断吗

168
00:06:18,233 --> 00:06:19,833
刚才这个没写对

169
00:06:19,966 --> 00:06:22,499
c.append(a[i]); i 加 1

170
00:06:23,033 --> 00:06:25,033
把小的添加到 c 里面

171
00:06:25,033 --> 00:06:27,299
然后把那个小的

172
00:06:27,366 --> 00:06:29,166
那个指针往前走一步

173
00:06:29,599 --> 00:06:32,099
对吧然后判断 如果这长度不为1的

174
00:06:32,099 --> 00:06:32,866
不相等的时候

175
00:06:32,866 --> 00:06:33,466
要把

176
00:06:33,466 --> 00:06:36,133
剩下的部分给添加到这个c里面去

177
00:06:36,499 --> 00:06:37,299
对吧

178
00:06:37,399 --> 00:06:39,366
今天就是这样 来我们看一下这题

179
00:06:40,099 --> 00:06:41,566
这题实际上就是这个意思吗

180
00:06:41,566 --> 00:06:43,533
两个数组 然后把它那个

181
00:06:43,533 --> 00:06:44,733
一模一样的意思嘛

182
00:06:44,733 --> 00:06:46,199
对吧

183
00:06:46,799 --> 00:06:48,199
这个是list的

184
00:06:48,199 --> 00:06:49,966
这个实际上是 ListNode

185
00:06:49,966 --> 00:06:51,166
它实际上不是

186
00:06:52,466 --> 00:06:53,766
列表, 它是个链表

187
00:06:54,199 --> 00:06:55,933
对吧 它是链表实际上也可以

188
00:06:55,933 --> 00:06:57,033
我们把这代码抄过来

189
00:06:57,033 --> 00:06:58,066
看看可不可以用

190
00:06:58,366 --> 00:06:59,166
就抄过来

191
00:06:59,799 --> 00:07:01,199
但是要改一下

192
00:07:01,366 --> 00:07:03,966
因为它是个链表, 它不是一个数组

193
00:07:04,299 --> 00:07:05,366
我们把抄过来

194
00:07:06,433 --> 00:07:08,733
对吧 这时候它就没有个 len(a) 嘛

195
00:07:08,733 --> 00:07:11,366
对 它没有一个 len(a) 那怎么办呢

196
00:07:11,766 --> 00:07:13,899
试一试 它是要返回

197
00:07:13,900 --> 00:07:15,433
因为它是 你看这个链表

198
00:07:15,433 --> 00:07:16,500
它实际上是说

199
00:07:16,900 --> 00:07:18,433
当前的值 指向下一个

200
00:07:18,433 --> 00:07:19,466
它是这样一个链的吗

201
00:07:19,466 --> 00:07:22,433
1-2, 2-4它不是一个数组

202
00:07:22,700 --> 00:07:24,666
那我这时候我应该c

203
00:07:24,666 --> 00:07:25,633
它应该返回什么

204
00:07:25,633 --> 00:07:28,000
head of the merged list

205
00:07:28,300 --> 00:07:29,933
那我就可以c

206
00:07:30,200 --> 00:07:32,433
c 我就可以刚开始是

207
00:07:32,900 --> 00:07:34,666
ListNode

208
00:07:35,100 --> 00:07:36,833
List Node 然后

209
00:07:37,300 --> 00:07:40,533
我随便给它指定一个对吧 这个然后

210
00:07:41,366 --> 00:07:44,633
i 就等于 List1

211
00:07:45,466 --> 00:07:48,666
队首 j 等于 List2 两个队首, 当 i

212
00:07:49,666 --> 00:07:51,266
i 不等于

213
00:07:51,600 --> 00:07:54,233
None 的时候 并且它还没到末尾的时候

214
00:07:56,266 --> 00:07:58,066
这时候不是 a[i] 了

215
00:07:58,600 --> 00:08:03,600
这就是 i 点 val 对吧 小于 b 点 val

216
00:08:04,233 --> 00:08:06,033
那么我这时候我应该是 c

217
00:08:07,100 --> 00:08:09,233
c 就等于 i 然后

218
00:08:10,066 --> 00:08:16,600
answer 也是等于 c, 然后 i 等于 i 点 next

219
00:08:17,700 --> 00:08:19,000
移动到下一个

220
00:08:20,100 --> 00:08:22,266
这个是 c 等于 j

221
00:08:23,600 --> 00:08:24,400
然后

222
00:08:24,833 --> 00:08:27,633
j 等于 j 点 next 那这时候是

223
00:08:28,066 --> 00:08:33,866
如果 i 的话那么 c.next 就等于 i

224
00:08:34,800 --> 00:08:38,033
如果 j 的话 c.next 就等于 j

225
00:08:38,500 --> 00:08:39,566
return

226
00:08:39,566 --> 00:08:42,166
answer.next 等会我解释一下

227
00:08:42,200 --> 00:08:43,700
这个是 answer

228
00:08:44,100 --> 00:08:45,500
answer.next

229
00:08:46,333 --> 00:08:47,133
等于 i

230
00:08:56,066 --> 00:08:58,666
我们试一下, 先跑一下测试用例

231
00:08:58,999 --> 00:09:00,066
哇擦 还要让我登录

232
00:09:00,066 --> 00:09:01,133
好跑一下

233
00:09:02,866 --> 00:09:05,200
哎忘了加个冒号嘛 对吧

234
00:09:05,966 --> 00:09:07,433
这个 b 哎

235
00:09:07,433 --> 00:09:09,633
b 也没有的这应该 j

236
00:09:11,966 --> 00:09:13,700
哎对了我们试一下 对不对

237
00:09:14,733 --> 00:09:17,400
哎过了吗是吧过了 Accepted 再点一下

238
00:09:19,666 --> 00:09:20,900
基本上一次性过吗

239
00:09:20,900 --> 00:09:23,366
刚才那个是语法错误 不算

240
00:09:24,566 --> 00:09:25,366
哈哈哈对

241
00:09:26,200 --> 00:09:27,733
哎这其实你看 有点不一样

242
00:09:27,900 --> 00:09:29,600
就是说怎么说它的数据类型

243
00:09:29,600 --> 00:09:31,400
之前 我们用的是数组

244
00:09:31,533 --> 00:09:34,366
所以就很简单可以直接取 那链表

245
00:09:34,400 --> 00:09:35,766
就是链表是从头开始

246
00:09:35,766 --> 00:09:37,300
你只能一个一个往下跳

247
00:09:38,066 --> 00:09:40,400
就比如说一个链表 你想一个链子吗

248
00:09:40,400 --> 00:09:43,266
那我比如说要访问第100个节点

249
00:09:43,266 --> 00:09:44,733
那我不能直接去调100节点

250
00:09:44,733 --> 00:09:46,733
我要从第1个节点开始往下跳

251
00:09:46,866 --> 00:09:48,466
跳跳跳跳跳跳到100个节点

252
00:09:48,466 --> 00:09:49,733
它就这两个链表

253
00:09:50,333 --> 00:09:52,866
然后当不等于都没到尾巴的时候

254
00:09:52,866 --> 00:09:55,066
我就判断 i 和 j 当前哪一个小

255
00:09:55,133 --> 00:09:57,233
哪一个小我就把它链到哪一个吗

256
00:09:57,233 --> 00:09:58,900
嗯然后跳那一个

257
00:09:58,900 --> 00:09:59,466
这个一样吗

258
00:09:59,466 --> 00:10:02,033
i = i.next 之前那个就是 i 加等 1

259
00:10:02,300 --> 00:10:04,900
j = j.next 之前那个是 j 加等 1 对吧

260
00:10:04,900 --> 00:10:06,833
嗯 然后这个一样吗

261
00:10:06,833 --> 00:10:07,600
这个其实一样

262
00:10:07,600 --> 00:10:09,566
它是链表 它只向下一次就行了

263
00:10:09,566 --> 00:10:11,633
那这个时间复杂度也是一样的

264
00:10:11,633 --> 00:10:12,633
就是两个长度

265
00:10:12,633 --> 00:10:13,766
如果是 a 和 b 的话

266
00:10:13,766 --> 00:10:16,166
那么它时间复杂度就是 O(A+B)

267
00:10:16,500 --> 00:10:17,966
对吧 这个是这样的

268
00:10:17,966 --> 00:10:19,966
merge two lists 刚才你看这个有点

269
00:10:20,100 --> 00:10:22,366
基本上是一样的吧 是吧

270
00:10:22,366 --> 00:10:24,366
只不过是类似 对吧

271
00:10:24,566 --> 00:10:26,100
那这个是数组吗

272
00:10:26,100 --> 00:10:27,766
这个是 这种类型 数组 List/Array

273
00:10:28,133 --> 00:10:29,533
list 的嘛, 然后这个是

274
00:10:30,233 --> 00:10:32,033
这个是 ListNode 它是一个节点

275
00:10:32,033 --> 00:10:34,533
它每个节点只能有一个存一个值

276
00:10:34,566 --> 00:10:37,033
然后存着它下一个节点是哪里 对吧

277
00:10:37,300 --> 00:10:38,866
点 next 你看那个图

278
00:10:39,233 --> 00:10:40,133
这个就是链表

279
00:10:40,133 --> 00:10:41,833
这个图1,2,4 它

280
00:10:42,266 --> 00:10:44,500
你要访问4你就得从1开始跳到2

281
00:10:44,500 --> 00:10:46,066
2告诉你4在哪里

282
00:10:46,300 --> 00:10:48,133
对吧 那就这样合并起来

283
00:10:48,433 --> 00:10:49,766
今天我们就讲到这里

284
00:10:49,766 --> 00:10:50,700
有什么问题吗

285
00:10:50,866 --> 00:10:51,933
没有, 好

286
00:10:51,933 --> 00:10:52,533
今天就这样

287
00:10:52,533 --> 00:10:54,166
谢谢 谢谢 拜拜 拜拜

