1
00:00:00,333 --> 00:00:01,066
哎大家好

2
00:00:01,066 --> 00:00:02,366
今天我们讲32课

3
00:00:02,366 --> 00:00:03,766
今天我们来讲一个

4
00:00:03,766 --> 00:00:04,066
问题

5
00:00:04,066 --> 00:00:06,833
就是最大子序列和 叫做 Max SubArray 

6
00:00:06,833 --> 00:00:09,066
这题是比较经典

7
00:00:09,066 --> 00:00:10,166
因为怎么经典呢

8
00:00:10,166 --> 00:00:12,333
就是它可以用多种方法来解决

9
00:00:12,333 --> 00:00:14,066
Max SubArray 就是我给您一个数组

10
00:00:14,166 --> 00:00:17,133
[1, 3, -2]有正的有负的

11
00:00:17,266 --> 00:00:20,100
那这样 然后 就是 Sub Array 就是

12
00:00:20,500 --> 00:00:23,133
什么是 Sub Array 子序列 就是说 它是连续吧

13
00:00:23,133 --> 00:00:24,766
连续的 就是说

14
00:00:25,300 --> 00:00:29,100
就连续嘛 [1,3]或者[1,3,-2]或者[1,3,-2,5]或者3

15
00:00:29,533 --> 00:00:31,633
-2这样 对吧 连续的嘛 对吧

16
00:00:32,100 --> 00:00:34,666
如果不连续的 那叫做子序列*吧

17
00:00:34,733 --> 00:00:37,466
不连续的就是1-2这样子

18
00:00:37,700 --> 00:00:39,366
一般叫做 Subsequence 

19
00:00:39,366 --> 00:00:42,000
这一般刷题 就有两个概念 先搞清楚

20
00:00:42,000 --> 00:00:42,800
Subsequence 

21
00:00:43,333 --> 00:00:44,833
subsequence 还有 sublist

22
00:00:44,900 --> 00:00:46,466
sublist 或者 subarray

23
00:00:46,600 --> 00:00:48,033
子列表就是

24
00:00:48,566 --> 00:00:49,233
连续的

25
00:00:49,233 --> 00:00:51,466
就是连续的 Subsequence 就是不是连续的

26
00:00:51,466 --> 00:00:53,533
就是你可以随便跳

27
00:00:53,533 --> 00:00:54,933
就是

28
00:00:54,966 --> 00:00:56,933
就是1这样-2或者3

29
00:00:57,500 --> 00:00:58,133
5 这样子的

30
00:00:58,133 --> 00:01:01,500
或者它本身也可以不跳 就[1,3,-2,5]

31
00:01:01,500 --> 00:01:02,300
就是说

32
00:01:02,466 --> 00:01:05,733
子列表所有的子列表都是Subsequence

33
00:01:05,733 --> 00:01:06,900
但是反过来不是

34
00:01:06,900 --> 00:01:08,300
这个这是一个概念问题

35
00:01:08,366 --> 00:01:10,400
那就是Sublist的就是连续的

36
00:01:10,400 --> 00:01:13,366
那我要保证就是取Sublist最大和

37
00:01:13,366 --> 00:01:14,400
加起来最大和

38
00:01:14,666 --> 00:01:16,000
那如果你想一想

39
00:01:16,000 --> 00:01:17,600
如果这个数都是正

40
00:01:18,300 --> 00:01:20,633
都是正的 那最大和就是本身吗对吧

41
00:01:20,866 --> 00:01:21,633
可以这样理解

42
00:01:21,633 --> 00:01:24,366
是不是 比如说你本身就是正的12345

43
00:01:24,433 --> 00:01:27,200
那我要求最大和那肯定就是12345吗

44
00:01:27,200 --> 00:01:28,566
对吧因为它都是正的吗对吧

45
00:01:28,633 --> 00:01:30,233
那当然有负的就不一定了

46
00:01:30,233 --> 00:01:32,466
这今天这个题就是这样的

47
00:01:33,433 --> 00:01:35,800
看一下这个 sub array 就是

48
00:01:36,633 --> 00:01:38,433
给定一个 sub array 

49
00:01:38,433 --> 00:01:40,766
如果是 contiguous part of the array

50
00:01:40,766 --> 00:01:41,633
这个就是说

51
00:01:41,766 --> 00:01:42,800
连续的

52
00:01:42,800 --> 00:01:45,133
我们要获得最大的这个值

53
00:01:45,133 --> 00:01:45,933
最大的值

54
00:01:46,433 --> 00:01:48,233
对吧那这个它有几个例子

55
00:01:48,266 --> 00:01:50,833
我们首先就是来用穷举的方法

56
00:01:50,833 --> 00:01:53,000
就是左边取一个右边取一个

57
00:01:53,000 --> 00:01:55,000
那然后我们动态的去算这个

58
00:01:55,433 --> 00:01:56,366
这个值吗

59
00:01:56,633 --> 00:01:58,433
那我们首先就Answer要等于

60
00:01:59,000 --> 00:02:00,666
负的 infinity 对吧

61
00:02:00,666 --> 00:02:02,666
这个 math infinity 就是一个常量

62
00:02:02,666 --> 00:02:05,033
就是代表是最负的那个

63
00:02:05,166 --> 00:02:06,433
负无穷大 对吧

64
00:02:06,766 --> 00:02:08,700
那我 n 是等于 len(nums)

65
00:02:09,566 --> 00:02:10,366
然后

66
00:02:10,500 --> 00:02:15,133
然后我 for i in range(n) 左边 我用 l 吧

67
00:02:15,133 --> 00:02:15,966
left 对吧

68
00:02:15,966 --> 00:02:20,266
left in range(n), 然后 for right in

69
00:02:21,000 --> 00:02:24,666
range 从 left 开始到 n 对吧

70
00:02:24,666 --> 00:02:26,833
那么我现在 我是要从左边到右边

71
00:02:26,833 --> 00:02:28,100
那么它的现在的 sum

72
00:02:28,100 --> 00:02:30,766
current sum 是不是等于 sum[left:

73
00:02:31,366 --> 00:02:31,866
Hmmms

74
00:02:31,866 --> 00:02:34,933
我要 sum nums 这个从 left 的开始到 right

75
00:02:35,066 --> 00:02:35,966
对吧到 right

76
00:02:36,233 --> 00:02:38,300
但是这个到 right 是包括的

77
00:02:38,300 --> 00:02:39,566
就 right 加1对吧

78
00:02:39,566 --> 00:02:42,766
然后如果 Current Sum 大于它的话

79
00:02:43,000 --> 00:02:44,733
如果 Current Sum 大于 answer 那么

80
00:02:45,100 --> 00:02:46,400
current sum 大于 answer

81
00:02:46,400 --> 00:02:48,500
那么就 answer 等于 current sum 对吧

82
00:02:48,900 --> 00:02:51,100
然后我其实 这个可以直接写成

83
00:02:51,100 --> 00:02:52,400
Answer 等于 max

84
00:02:52,666 --> 00:02:53,933
Answer, curSum

85
00:02:54,966 --> 00:02:56,133
然后

86
00:02:56,800 --> 00:02:58,666
返回这个Answer 看一下

87
00:02:58,666 --> 00:03:00,166
这个是最简单的实现方法

88
00:03:00,166 --> 00:03:01,766
就是我们就穷举所有的

89
00:03:02,100 --> 00:03:03,566
穷举 你看这个测试用例过

90
00:03:03,566 --> 00:03:05,633
但是它实际上是通不过所有的测试

91
00:03:05,633 --> 00:03:07,266
测试用例 等会我也来讲为什么

92
00:03:07,366 --> 00:03:10,166
就是你看 罗列左边的这个开始的位置

93
00:03:10,166 --> 00:03:11,700
罗列右边开始的位置

94
00:03:12,166 --> 00:03:13,200
对吧 Range是从

95
00:03:13,666 --> 00:03:16,166
右边是从左边开始到 n 结束

96
00:03:16,166 --> 00:03:17,066
那我这个是

97
00:03:17,366 --> 00:03:20,333
nums[left:right+1] 就是这段连续的

98
00:03:20,333 --> 00:03:21,600
这个子列表*

99
00:03:21,600 --> 00:03:22,533
然后我再求和

100
00:03:22,533 --> 00:03:23,633
然后 然后

101
00:03:23,633 --> 00:03:25,733
我再记录最大的这个和

102
00:03:25,733 --> 00:03:27,466
那这个实际上它是会超时的

103
00:03:27,466 --> 00:03:28,333
跑不过的

104
00:03:28,566 --> 00:03:29,800
应该是会跑不过的

105
00:03:30,466 --> 00:03:31,366
你们看一下

106
00:03:34,633 --> 00:03:35,433
是好慢

107
00:03:37,500 --> 00:03:39,033
好慢好慢

108
00:03:39,666 --> 00:03:42,533
two thousand years later, time limited

109
00:03:42,733 --> 00:03:43,333
对吧 为什么

110
00:03:43,333 --> 00:03:45,333
因为你看这个是左边这个 n

111
00:03:45,633 --> 00:03:49,066
这个是 O(N)

112
00:03:49,300 --> 00:03:51,266
然后 O(N) 里面还有 O(N) 是吧

113
00:03:52,100 --> 00:03:53,200
然后但是这个 sum

114
00:03:53,200 --> 00:03:54,133
你看它求和

115
00:03:54,133 --> 00:03:56,200
它还是一次 O(N) 所以它总共

116
00:03:56,633 --> 00:03:57,633
总共时间复杂度

117
00:03:57,633 --> 00:03:59,133
就是 O(N) 乘以 O(N) 乘以 O(N)

118
00:03:59,133 --> 00:03:59,866
你可以理解吧

119
00:03:59,866 --> 00:04:01,833
我做一个事情我需要 n 步

120
00:04:01,833 --> 00:04:04,233
然后每步里面还需要 n 步

121
00:04:04,600 --> 00:04:06,100
每 n 小步里面又 n 步

122
00:04:06,100 --> 00:04:08,000
那么它总共需要多少步 n 乘以 n 乘以 n

123
00:04:08,000 --> 00:04:09,200
它的时间复杂度

124
00:04:09,200 --> 00:04:11,200
那这个是相当慢的对吧

125
00:04:11,333 --> 00:04:12,133
但实际上

126
00:04:12,333 --> 00:04:14,633
这个慢在哪里呢 慢在于这个

127
00:04:15,100 --> 00:04:17,100
我这个 sum 对我每次都得求和

128
00:04:17,100 --> 00:04:18,766
就像我上次昨天

129
00:04:19,333 --> 00:04:19,866
上一周吧

130
00:04:19,866 --> 00:04:22,566
给你讲了这个动态规划1234是吧

131
00:04:22,766 --> 00:04:24,533
我是知道1234求和是10

132
00:04:24,533 --> 00:04:26,766
那我再加上一个5就是10加5

133
00:04:26,966 --> 00:04:27,166
对吧

134
00:04:27,166 --> 00:04:30,033
但是它这里的算法是1加2加3加4加5

135
00:04:30,033 --> 00:04:32,300
就是每次都重新计算 就没有必要嘛

136
00:04:32,300 --> 00:04:32,766
对吧

137
00:04:32,766 --> 00:04:34,233
所以我就可以把这个再优化一下

138
00:04:34,233 --> 00:04:35,500
我就这边写一个 current sum

139
00:04:35,500 --> 00:04:36,800
current sum 写在这边等于0

140
00:04:37,066 --> 00:04:37,866
然后这

141
00:04:38,333 --> 00:04:41,100
不去重复去加 我就current sum加等于

142
00:04:41,466 --> 00:04:42,700
加等于 nums

143
00:04:43,000 --> 00:04:45,366
right 就可以了对吧 那这时候应该是

144
00:04:45,733 --> 00:04:47,133
就只有O(N平方)

145
00:04:47,133 --> 00:04:48,866
我们虽然稍稍微改了两行

146
00:04:48,866 --> 00:04:50,466
对吧但实际上它是O(N平方)

147
00:04:50,466 --> 00:04:52,366
它应该还是会超时

148
00:04:53,033 --> 00:04:54,566
对吧应该是会超时

149
00:04:56,033 --> 00:04:58,400
太慢了这个O(N平方)也不过

150
00:04:58,400 --> 00:05:00,433
那刚才那个O(N立方)就肯定过不了

151
00:05:00,433 --> 00:05:02,400
对吧 这肯定是超时

152
00:05:04,533 --> 00:05:05,333
对吧 还是超时

153
00:05:05,333 --> 00:05:07,366
但是它会比刚才那个稍微快一点

154
00:05:07,533 --> 00:05:08,566
这个是

155
00:05:08,766 --> 00:05:10,366
两个算法 那但是

156
00:05:10,366 --> 00:05:10,900
但这个

157
00:05:10,900 --> 00:05:12,900
我们肯定要找比它快的方法吗

158
00:05:12,900 --> 00:05:15,166
对 不然的话就刷不了这个题了 对吧

159
00:05:15,200 --> 00:05:16,166
这个快的方法呢

160
00:05:16,166 --> 00:05:18,100
实际上是这样子比如说我们

161
00:05:18,333 --> 00:05:20,566
来举个例子 就是我

162
00:05:20,833 --> 00:05:22,166
我每次我都取

163
00:05:22,266 --> 00:05:24,233
我有个贪心 我有种策略吧

164
00:05:24,233 --> 00:05:26,233
就是我每次都

165
00:05:27,000 --> 00:05:28,366
每次都有一个和

166
00:05:28,366 --> 00:05:30,800
代表现在累加的最大的那个和

167
00:05:30,966 --> 00:05:32,200
那如果它是负的话

168
00:05:32,200 --> 00:05:34,066
那我肯定要摒弃吗 我就不用

169
00:05:34,200 --> 00:05:35,000
我就要用

170
00:05:35,133 --> 00:05:36,600
我就摒弃掉吧

171
00:05:36,600 --> 00:05:38,233
对吧 否则的话我就可以继续累加

172
00:05:38,233 --> 00:05:39,333
如果是和是正的话

173
00:05:39,333 --> 00:05:40,600
我是不是可以继续累加

174
00:05:40,633 --> 00:05:41,366
和是负的话

175
00:05:41,366 --> 00:05:43,033
我干脆就从现在的开

176
00:05:43,033 --> 00:05:44,166
现在的这个值开始

177
00:05:44,166 --> 00:05:44,933
对不对

178
00:05:44,933 --> 00:05:47,700
就每次开始对吧 那我们可以看一下

179
00:05:47,833 --> 00:05:49,733
试一下就是Answer然后我们写

180
00:05:49,833 --> 00:05:51,966
上面写一个current 和等于0吗 对吧

181
00:05:52,300 --> 00:05:54,366
然后 for i in numbers

182
00:05:55,400 --> 00:05:56,633
是吧 然后 如果

183
00:05:57,000 --> 00:05:58,200
如果现在的和

184
00:05:58,666 --> 00:06:00,133
大于等于0了哈

185
00:06:00,166 --> 00:06:02,900
对吧 那么我就可以 cur 加等于现在的

186
00:06:03,166 --> 00:06:03,966
这个值

187
00:06:04,100 --> 00:06:06,866
否则的话我就 cur 就等于 i 对吧

188
00:06:07,100 --> 00:06:07,533
那同时

189
00:06:07,533 --> 00:06:09,833
我要记录一下这个现在遇到的这个

190
00:06:10,100 --> 00:06:11,266
最大的和吧

191
00:06:11,533 --> 00:06:13,266
这样这种情况来看一下对不对

192
00:06:13,266 --> 00:06:14,200
先跑一下

193
00:06:14,700 --> 00:06:15,566
跑一下这个例子

194
00:06:15,700 --> 00:06:16,733
这个跑一下

195
00:06:18,666 --> 00:06:19,533
哎对了过了吗

196
00:06:19,533 --> 00:06:20,933
你看我只有一个循环是不是

197
00:06:20,933 --> 00:06:21,600
只有O(N)吗

198
00:06:21,600 --> 00:06:22,800
你看这就很快了吧

199
00:06:22,900 --> 00:06:24,466
这就O(N)对不对

200
00:06:24,466 --> 00:06:25,000
O(N)

201
00:06:25,000 --> 00:06:26,400
为什么, 这个策略 我讲一下

202
00:06:26,400 --> 00:06:27,166
就是贪心

203
00:06:27,166 --> 00:06:27,633
就是说哎

204
00:06:27,633 --> 00:06:29,800
我现在 current 是第四行的 current

205
00:06:29,900 --> 00:06:31,700
是代表 我现在

206
00:06:31,766 --> 00:06:33,900
见过的最大的这个子列表*的和

207
00:06:34,500 --> 00:06:35,566
那如果它大于0

208
00:06:35,566 --> 00:06:37,100
那我是不是可以继续累加

209
00:06:37,166 --> 00:06:38,733
试一下这个当前的这个

210
00:06:38,733 --> 00:06:39,833
因为它是大于0吗

211
00:06:39,933 --> 00:06:41,666
那如果是小于0的话 那我

212
00:06:42,000 --> 00:06:43,866
我就不用了吗 我还不如

213
00:06:44,966 --> 00:06:45,833
另起炉灶

214
00:06:45,833 --> 00:06:46,933
按照现在的这个

215
00:06:47,033 --> 00:06:48,866
这个当前的这数 加上去

216
00:06:48,866 --> 00:06:52,000
那我每次 第10行 我就是来记录

217
00:06:52,200 --> 00:06:54,266
我目前遇到过最大的这个和

218
00:06:54,266 --> 00:06:55,733
就 O(N) 的这个算法

219
00:06:55,800 --> 00:06:58,066
对 是这样子的

220
00:06:58,133 --> 00:07:00,466
那还有一种算法就是动态规划 就是

221
00:07:00,833 --> 00:07:02,133
动态规划它实际上

222
00:07:02,366 --> 00:07:03,800
这里面有个算法叫做

223
00:07:04,233 --> 00:07:07,600
卡蛋算法 卡蛋算法 卡蛋算法

224
00:07:07,766 --> 00:07:09,333
卡蛋卡蛋

225
00:07:09,966 --> 00:07:11,400
Kadane's Algorithm

226
00:07:11,433 --> 00:07:13,900
它实际上就是叫 DP (Dynamic Programming)

227
00:07:13,900 --> 00:07:14,733
只不过有个

228
00:07:15,066 --> 00:07:17,200
有个刚好就卡蛋这个人

229
00:07:17,733 --> 00:07:19,366
就觉得 这个是一个算法

230
00:07:19,366 --> 00:07:21,266
所以TA就给取了个名字

231
00:07:21,266 --> 00:07:23,266
叫卡蛋算法 卡了蛋

232
00:07:24,633 --> 00:07:26,033
那实际上是这个意思

233
00:07:26,166 --> 00:07:28,300
是怎么来说呢 就是我如果是 DP

234
00:07:28,633 --> 00:07:32,500
DP[i] 的话 用 DP[i] 是代表说

235
00:07:32,900 --> 00:07:34,000
这个当前

236
00:07:34,500 --> 00:07:35,933
到 i 这个 index

237
00:07:35,966 --> 00:07:37,200
最大的这个

238
00:07:37,200 --> 00:07:37,666
*子列表和

239
00:07:37,666 --> 00:07:39,733
就是我不管子列表*是从哪开始

240
00:07:39,733 --> 00:07:42,133
但是至到 i 这个位置 最大对吧

241
00:07:42,800 --> 00:07:43,466
到这个位置

242
00:07:43,466 --> 00:07:45,400
那它其实就有两种选择

243
00:07:45,400 --> 00:07:47,733
它实际上是不是 相当于

244
00:07:47,733 --> 00:07:48,966
相当于

245
00:07:48,966 --> 00:07:52,100
我那个怎么说呢 我就是前面那个

246
00:07:52,633 --> 00:07:53,833
到前面那个列表

247
00:07:53,833 --> 00:07:55,666
我用了前面这个列表对吧

248
00:07:55,700 --> 00:07:58,733
就是我用了前面这个到 i 减1这个位置

249
00:07:59,100 --> 00:08:00,433
那么或者我不用

250
00:08:00,433 --> 00:08:02,966
就是0, 我再加上现在的这个

251
00:08:03,133 --> 00:08:05,133
当前的这个值吗 当前这个 i

252
00:08:05,800 --> 00:08:06,333
可以这么理解

253
00:08:06,333 --> 00:08:08,566
就是我我比如说[1,2,3,4,5]

254
00:08:08,766 --> 00:08:10,666
我这个 i 我在3的时候

255
00:08:10,666 --> 00:08:11,900
我那么是不是有两种选择

256
00:08:11,900 --> 00:08:14,066
就是我用上前面的

257
00:08:14,800 --> 00:08:16,066
连续的子列表*和

258
00:08:16,066 --> 00:08:16,933
或者我不用

259
00:08:16,933 --> 00:08:18,833
我就另起炉灶 这有点刚才

260
00:08:18,866 --> 00:08:20,600
跟刚才那个 Greedy (贪心) 有点类似

261
00:08:20,600 --> 00:08:22,100
我们先实现一下这个

262
00:08:22,100 --> 00:08:23,000
这个动态规划

263
00:08:23,300 --> 00:08:25,700
就是这么说 DP

264
00:08:25,966 --> 00:08:27,166
我们先实现一下 dp

265
00:08:27,166 --> 00:08:28,533
然后我再给它转成 Kadane's

266
00:08:28,533 --> 00:08:30,300
其实是一样的 dp 就是一个

267
00:08:30,500 --> 00:08:31,300
刚开始是

268
00:08:31,533 --> 00:08:34,933
第一个数值就是 nums[0] 然后再加上

269
00:08:35,500 --> 00:08:39,133
-math.inf 负无穷大* 乘以

270
00:08:39,633 --> 00:08:41,066
n 等于 len(nums)

271
00:08:41,733 --> 00:08:44,166
这个长度 n 减1好了

272
00:08:44,233 --> 00:08:45,733
那这样 dp 就是它的数组

273
00:08:45,733 --> 00:08:47,300
那我就可以从第

274
00:08:47,300 --> 00:08:48,333
第二个开始吧

275
00:08:48,333 --> 00:08:50,266
如果这个数组只有一个数, 那么它

276
00:08:50,266 --> 00:08:51,666
因为它是说 那个

277
00:08:51,666 --> 00:08:53,033
它有没有说为空呢

278
00:08:53,366 --> 00:08:55,700
它没有说到为空的这个问题

279
00:08:55,700 --> 00:08:56,900
应该是不为空的

280
00:08:56,900 --> 00:08:58,800
我觉得应该是不为空 我们试一下

281
00:08:58,800 --> 00:09:00,100
等等会我们试一下

282
00:09:00,233 --> 00:09:01,033
就是

283
00:09:01,100 --> 00:09:03,266
就是 如果这个数组只有一个元素

284
00:09:03,266 --> 00:09:04,233
那么它就是

285
00:09:04,933 --> 00:09:06,233
只有一种可能吗 对吧

286
00:09:06,333 --> 00:09:08,700
就是它本身吗 就对吧 嗯

287
00:09:09,466 --> 00:09:10,266
那我就是你看

288
00:09:10,266 --> 00:09:12,966
DP[i] 就等于那刚才那个数字

289
00:09:13,233 --> 00:09:16,100
DP[i-1] 你看这时候 我们用 i 减1

290
00:09:16,100 --> 00:09:17,300
所以就要从1开始

291
00:09:17,300 --> 00:09:18,766
不然的话会越界嘛

292
00:09:18,766 --> 00:09:20,833
你如果等于0开始0减1就-1

293
00:09:21,366 --> 00:09:23,233
数组的-1是没有意义的对吧

294
00:09:23,633 --> 00:09:25,833
在Python里面有意义

295
00:09:25,833 --> 00:09:28,166
但是 一般来说 不是我们要

296
00:09:28,400 --> 00:09:29,966
用的 DP[-1] 是说

297
00:09:30,533 --> 00:09:32,266
末尾 末尾那个

298
00:09:32,800 --> 00:09:34,133
就是结尾那个值吧

299
00:09:34,133 --> 00:09:36,666
就是1234 我现在再插一句

300
00:09:36,833 --> 00:09:38,366
a 等于1234

301
00:09:38,566 --> 00:09:41,066
a[-1] 就是4这个值对吧

302
00:09:41,533 --> 00:09:43,166
a[0] 是第一个嘛

303
00:09:43,166 --> 00:09:45,366
a[-1] 是最后一个

304
00:09:46,133 --> 00:09:49,500
然后 dp[i-1]

305
00:09:49,700 --> 00:09:51,366
然后再加上 nums[i]

306
00:09:51,366 --> 00:09:53,333
这个这是递归推导方程式

307
00:09:53,333 --> 00:09:54,133
然后

308
00:09:54,133 --> 00:09:57,766
我要返回的就是所有 dp 的 (max) 值吗

309
00:09:57,766 --> 00:09:58,766
因为就是说 你

310
00:09:58,966 --> 00:10:00,566
有 n 种可能吗

311
00:10:00,566 --> 00:10:02,833
对吧 dp[i] 是代表是说

312
00:10:03,300 --> 00:10:06,833
这个子列表*到 i 结束的最大的这个值

313
00:10:07,300 --> 00:10:08,200
最大的可能

314
00:10:08,200 --> 00:10:10,466
那么它有 n 种可能 我就要求最大

315
00:10:10,533 --> 00:10:11,866
我们看一下是不是对

316
00:10:12,266 --> 00:10:13,066
Hmmmm

317
00:10:13,300 --> 00:10:14,500
呦这不对了这

318
00:10:14,500 --> 00:10:17,000
是不是 乘不对 但是第几行出错

319
00:10:17,000 --> 00:10:19,000
Line 6 不对

320
00:10:19,400 --> 00:10:21,866
nums[0] 加上

321
00:10:22,766 --> 00:10:24,033
哎怎么不对呢

322
00:10:24,600 --> 00:10:26,200
哦这应该是

323
00:10:26,600 --> 00:10:28,633
这个应该是用 不是用那个

324
00:10:28,766 --> 00:10:30,966
方框号是代表是 list 的

325
00:10:30,966 --> 00:10:32,700
刚才那个圆框号弄错了

326
00:10:33,500 --> 00:10:34,633
对对对

327
00:10:35,000 --> 00:10:36,266
它应该是会过的

328
00:10:36,466 --> 00:10:37,066
过了

329
00:10:37,066 --> 00:10:39,400
我们试一下我们先试一下如果空的

330
00:10:39,966 --> 00:10:42,100
空的时候它是多少

331
00:10:42,166 --> 00:10:45,066
空的时候它应该会报错吧 会报错吗

332
00:10:45,933 --> 00:10:47,566
空的时候它是会报错的

333
00:10:48,500 --> 00:10:50,933
会报错的 那我们就加一个判断

334
00:10:51,333 --> 00:10:53,533
if not nums 应该是 return 0

335
00:10:53,733 --> 00:10:55,300
我觉得 我们试一下

336
00:10:56,333 --> 00:10:57,933
哦对它 测试用例

337
00:10:57,933 --> 00:10:58,900
它不允许为空

338
00:10:58,900 --> 00:11:00,533
那我们再试一下

339
00:11:00,533 --> 00:11:01,333
如果是-

340
00:11:01,533 --> 00:11:03,266
-2的话 如果它是不是

341
00:11:03,933 --> 00:11:04,633
返回

342
00:11:04,633 --> 00:11:07,333
那就是 你看 我因为我测 它没有说

343
00:11:07,633 --> 00:11:10,266
是否是为空 这个值 没有说是否为空

344
00:11:10,600 --> 00:11:12,200
所以我给了一个-2的这个值

345
00:11:12,200 --> 00:11:13,233
来测试它

346
00:11:13,466 --> 00:11:15,766
因为它告诉我它答案 expected 是-2

347
00:11:15,766 --> 00:11:18,533
那就代表说你这个子列表是不能空

348
00:11:18,533 --> 00:11:20,766
如果子列表为空那么它就0嘛

349
00:11:20,800 --> 00:11:21,800
0要比-2大

350
00:11:21,800 --> 00:11:23,666
对吧 所以我们刚才说的这个是

351
00:11:24,033 --> 00:11:26,066
这种情况是对的你看这个 dp

352
00:11:26,066 --> 00:11:27,866
你看 dp[i] 是

353
00:11:28,366 --> 00:11:30,533
只是取决于 dp[i-1]

354
00:11:30,533 --> 00:11:32,766
对吧 那我就不用去用一个 dp 来

355
00:11:33,066 --> 00:11:35,933
保存这个值 那我可以直接

356
00:11:36,166 --> 00:11:37,100
这个也不用

357
00:11:37,100 --> 00:11:38,700
Line 4,5 不用因为它不为空

358
00:11:38,966 --> 00:11:40,700
怎么弄呢 就是可以

359
00:11:41,233 --> 00:11:42,633
这样 current 等于

360
00:11:43,166 --> 00:11:44,133
等于负的

361
00:11:44,200 --> 00:11:45,866
current 等于多少呢

362
00:11:45,866 --> 00:11:47,833
对Answer等于负无穷大

363
00:11:49,633 --> 00:11:50,700
Current等于0

364
00:11:52,733 --> 00:11:56,500
nums然后 current 等于 max current 加上 i

365
00:11:56,900 --> 00:11:59,466
我可以用 我如果加上 i

366
00:12:00,200 --> 00:12:03,133
之前的子列表加上 当前的数

367
00:12:03,133 --> 00:12:05,733
或者 我直接另起炉灶

368
00:12:06,866 --> 00:12:10,366
子列表 以当前这个数字 开始为一个

369
00:12:10,800 --> 00:12:12,966
那么 answer 等于 max answer

370
00:12:14,433 --> 00:12:15,333
return answer

371
00:12:16,433 --> 00:12:18,733
看一下对不对

372
00:12:18,966 --> 00:12:20,000
哎也过了吧 对吧

373
00:12:20,000 --> 00:12:21,933
这个就是叫卡蛋算法

374
00:12:21,933 --> 00:12:24,066
你看这个很简洁明了 对吧

375
00:12:24,200 --> 00:12:25,233
就是其实

376
00:12:25,366 --> 00:12:26,933
其实卡蛋算法就跟那刚才

377
00:12:26,933 --> 00:12:28,400
那个动态规划是一个一样的

378
00:12:28,400 --> 00:12:29,766
它的核心就是说

379
00:12:30,133 --> 00:12:32,766
我当前我现在第二个数来说

380
00:12:32,766 --> 00:12:34,233
哦假设我是第二个数来说

381
00:12:34,266 --> 00:12:35,566
那么它就有两种选择

382
00:12:35,966 --> 00:12:39,066
一个是继续延续之前

383
00:12:39,766 --> 00:12:40,666
的那个子列表

384
00:12:40,666 --> 00:12:42,466
我加上当前这个第二个数字

385
00:12:42,466 --> 00:12:44,400
或者我之前的列表不要了

386
00:12:45,333 --> 00:12:47,800
拿我以现在这个当前这个

387
00:12:48,133 --> 00:12:49,833
第二个数字开始子列表

388
00:12:49,833 --> 00:12:50,633
因为它是连续吗

389
00:12:50,633 --> 00:12:51,566
我可以这么弄的

390
00:12:51,866 --> 00:12:53,733
那第8行基本上都是需要的

391
00:12:53,733 --> 00:12:56,333
就是我碰到当前那个

392
00:12:56,633 --> 00:12:59,233
记录最大的这个子列表是吧

393
00:12:59,233 --> 00:13:01,133
那刚才我们讲了几种方法

394
00:13:01,133 --> 00:13:03,066
第一种是 O(N立方) 的算法是吧

395
00:13:03,066 --> 00:13:06,433
O(N立方)这个很慢吗 就是穷举暴力

396
00:13:06,733 --> 00:13:07,766
然后我们稍微改一下

397
00:13:07,766 --> 00:13:09,333
就变成 O(N平方) 对吧

398
00:13:09,333 --> 00:13:12,233
那个就是累计叠加这个值

399
00:13:12,233 --> 00:13:14,400
然后 我们这个还是通不过

400
00:13:14,400 --> 00:13:16,366
然后 O(N) 算法 O(N) 算法有几种呢

401
00:13:16,366 --> 00:13:17,166
有这个Greedy (贪心)

402
00:13:17,166 --> 00:13:17,966
刚才那个

403
00:13:18,200 --> 00:13:20,566
就是Greedy贪心的算法

404
00:13:20,566 --> 00:13:22,000
还有就是这个动态规划

405
00:13:22,200 --> 00:13:24,466
动态规划也就是在卡蛋算法是吧

406
00:13:24,500 --> 00:13:25,300
卡蛋算法

407
00:13:25,800 --> 00:13:26,433
对

408
00:13:26,433 --> 00:13:28,766
就是这样 O(N) 的时候才会通过对吧

409
00:13:28,900 --> 00:13:30,366
那这个是不是很有意思呢

410
00:13:30,366 --> 00:13:33,100
这个当然这个算法还有很多

411
00:13:33,533 --> 00:13:35,900
还有其它的解法吧

412
00:13:35,900 --> 00:13:36,966
比如说可以用那个

413
00:13:37,400 --> 00:13:38,900
Divide and Conquer 的这个就比较复杂

414
00:13:38,900 --> 00:13:41,366
我们之后有机会再说吧

415
00:13:41,366 --> 00:13:43,033
我们今天那有什么问题吗

416
00:13:43,100 --> 00:13:45,633
今天没有我们今天就讲了这 拜拜

