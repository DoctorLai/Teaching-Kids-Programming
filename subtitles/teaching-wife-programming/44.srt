1
00:00:00,200 --> 00:00:02,000
Hi, 大家好啊, 我们今天来讲

2
00:00:02,200 --> 00:00:03,066
第44课

3
00:00:03,066 --> 00:00:04,766
讲继续讲那个算法

4
00:00:04,766 --> 00:00:06,033
coding 我们讲一个题吧

5
00:00:06,033 --> 00:00:09,033
就很有意思啊这题, 就是我给定一个

6
00:00:09,066 --> 00:00:11,266
数字 比如说这1 最开始这个1嘛

7
00:00:11,266 --> 00:00:12,433
那你去数它

8
00:00:12,500 --> 00:00:14,666
你那 数几个1呢

9
00:00:14,666 --> 00:00:15,833
它就有一个1嘛 对吧

10
00:00:15,833 --> 00:00:17,766
它读作 One "1" 对吧?

11
00:00:17,766 --> 00:00:18,633
有一个1

12
00:00:18,966 --> 00:00:21,066
那一个1它就会变成

13
00:00:21,700 --> 00:00:23,600
"11"嘛, 一个1嘛 对吧?

14
00:00:23,633 --> 00:00:26,300
那你现在去再去数这个

15
00:00:26,366 --> 00:00:27,766
就有两个一是不是

16
00:00:28,066 --> 00:00:30,500
两个一那就是变成 Two 1's 对吧

17
00:00:30,500 --> 00:00:33,100
嗯 Two 1's 那它实际上就变成 "21" 对吧

18
00:00:33,233 --> 00:00:35,033
然后再下一个就是

19
00:00:35,500 --> 00:00:38,200
1个"2", 1个"1" 是不是, One 2

20
00:00:38,433 --> 00:00:40,833
One 1 嗯 那

21
00:00:40,900 --> 00:00:42,866
那这时候它应该是变成什么呢?

22
00:00:42,866 --> 00:00:44,566
"1211" 对不对

23
00:00:45,000 --> 00:00:46,266
是吧 嗯

24
00:00:46,433 --> 00:00:48,166
然后我们再继续

25
00:00:48,366 --> 00:00:52,066
一个1 一个2

26
00:00:52,066 --> 00:00:54,733
然后两个1 对不对

27
00:00:54,966 --> 00:00:57,466
那它应该就是12

28
00:00:57,466 --> 00:01:00,200
11 12 21对吧

29
00:01:00,333 --> 00:01:02,633
就是这么个简单的这个例子

30
00:01:02,633 --> 00:01:03,766
我们看一下这题

31
00:01:03,766 --> 00:01:05,533
实际上它讲的是一样的意思

32
00:01:05,533 --> 00:01:06,433
就这个你看

33
00:01:06,466 --> 00:01:09,433
它这个题目是讲的很好 3322251

34
00:01:09,600 --> 00:01:10,600
两个3

35
00:01:11,233 --> 00:01:12,733
3个2, 1个5, 1个1

36
00:01:12,733 --> 00:01:14,566
你看吧 它就这里面 就分组嘛

37
00:01:14,566 --> 00:01:15,200
对吧 对

38
00:01:15,233 --> 00:01:16,099
对一个同一个字符串

39
00:01:16,166 --> 00:01:18,499
数字字符串来说,我首先要给它分组

40
00:01:18,666 --> 00:01:20,066
同样数字的我给它分成一组

41
00:01:20,066 --> 00:01:21,100
然后我数多少个嘛

42
00:01:21,100 --> 00:01:23,800
我要 Count 的它 这个 Count 的就是我去数

43
00:01:24,233 --> 00:01:27,100
有两个3就去数有两个

44
00:01:27,400 --> 00:01:31,433
然后 Say, Count and Say 就是说它这个3嘛对吧

45
00:01:31,433 --> 00:01:33,000
所以就是"23" 对不对

46
00:01:33,000 --> 00:01:35,000
然后这个是3个2, "32"

47
00:01:35,166 --> 00:01:36,233
1个5就 "15"

48
00:01:36,233 --> 00:01:37,233
然后1个1就 "11"

49
00:01:37,233 --> 00:01:38,766
然后这样不停的迭代 对吧

50
00:01:38,800 --> 00:01:39,966
然后它这个题就是这样

51
00:01:39,966 --> 00:01:41,300
比如说给定1个1

52
00:01:41,300 --> 00:01:43,166
就是"1" 这个是最原始的嘛

53
00:01:43,266 --> 00:01:45,699
然后给定4就是"1211"

54
00:01:45,966 --> 00:01:46,933
那你看到这个题目

55
00:01:46,933 --> 00:01:49,433
它的这个范围是 1到30

56
00:01:49,433 --> 00:01:51,733
所以这个数据量是相对来说比较小的

57
00:01:51,899 --> 00:01:54,533
对吧 那我现在就是有个

58
00:01:54,833 --> 00:01:55,633
这个想法吧

59
00:01:55,633 --> 00:01:58,666
就是比如说你我要数n等于5对吧

60
00:01:58,666 --> 00:02:00,633
那我是不是要

61
00:02:00,633 --> 00:02:02,766
首先我是要获得n等于4的这种情况

62
00:02:02,766 --> 00:02:03,566
对不对 嗯

63
00:02:03,699 --> 00:02:04,033
是吧

64
00:02:04,033 --> 00:02:06,466
那我n等于4是不是要获得n等于3的情况

65
00:02:06,499 --> 00:02:07,899
就是说我 f(n)

66
00:02:08,466 --> 00:02:11,233
我假设 f(n) 是我这个要的这个结果

67
00:02:11,233 --> 00:02:12,666
那我首先我获得 f(n)

68
00:02:12,666 --> 00:02:14,733
我就要获得 f(n-1) 的情况

69
00:02:14,833 --> 00:02:16,033
那我要获得 f(n-1)

70
00:02:16,033 --> 00:02:17,833
我就要获得 f(n-2) 的情况

71
00:02:18,066 --> 00:02:19,866
那这种情况就是相当于一个

72
00:02:19,933 --> 00:02:21,966
不停的递归去调用嘛

73
00:02:21,966 --> 00:02:25,166
就假设我f(n)的话我需要去调用f(n-1)

74
00:02:25,166 --> 00:02:26,466
然后调用f(n-2)

75
00:02:26,533 --> 00:02:29,133
然后一直调用到f(1) 是吧?

76
00:02:29,166 --> 00:02:31,099
f(1) 我们就不用再去算了嘛, 对吧?

77
00:02:31,099 --> 00:02:32,533
那我们就知道这个是 "1" 嘛, 对吧?

78
00:02:32,533 --> 00:02:33,766
那这个叫做递归嘛

79
00:02:33,766 --> 00:02:34,233
这个递归

80
00:02:34,233 --> 00:02:36,499
我们之前在讲费伯纳切数列的时候

81
00:02:36,499 --> 00:02:38,166
就讲过递归, 就自己调用自己

82
00:02:38,433 --> 00:02:39,633
我要调用这个f(n)

83
00:02:39,633 --> 00:02:41,633
我需要把它分解成比较小的问题

84
00:02:41,633 --> 00:02:42,866
就 f(n-1), 对吧?

85
00:02:42,899 --> 00:02:44,566
最基本的情况就是n等于1的时候

86
00:02:44,633 --> 00:02:46,600
你需要告诉计算机

87
00:02:46,766 --> 00:02:48,233
怎么去解决最基本f(n=1)的时候

88
00:02:48,400 --> 00:02:50,100
如果你不告诉计算机f(n=1)

89
00:02:50,233 --> 00:02:51,966
那计算机就不知道怎么去

90
00:02:52,633 --> 00:02:54,799
再去分解, 那f(1)它就 它可能

91
00:02:54,799 --> 00:02:56,566
在会继续调用自己就 f(0)

92
00:02:56,566 --> 00:02:58,499
然后再f(-1)那就没完没了

93
00:02:58,499 --> 00:02:59,933
它就没有办法去解决嘛

94
00:02:59,933 --> 00:03:01,966
但你调用到f(1)的时候

95
00:03:02,033 --> 00:03:03,166
那知道等于 "1"

96
00:03:03,166 --> 00:03:05,099
然后根据这个 "1" 然后去推 f(2)

97
00:03:05,099 --> 00:03:06,999
然后知道这个 f(2) 再去推 f(3), 对吧?

98
00:03:06,999 --> 00:03:07,799
然后推到 f(n)

99
00:03:07,999 --> 00:03:09,366
那我们就开始来写

100
00:03:09,433 --> 00:03:11,299
就 define 我们假设这个 n 嘛, 对吧

101
00:03:11,366 --> 00:03:14,433
那最基本的情况就是 if n==1 是吧

102
00:03:14,433 --> 00:03:16,999
等于1, 我知道是"1"嘛, 对吧

103
00:03:17,533 --> 00:03:19,766
那我现在我要看之前的那个结果

104
00:03:19,766 --> 00:03:21,033
我假设给它设为a

105
00:03:21,299 --> 00:03:22,133
就 f(n-1)

106
00:03:22,133 --> 00:03:23,699
你看我这个是调用自己嘛, 是吧

107
00:03:23,999 --> 00:03:25,533
调用自己这个 n-1

108
00:03:25,533 --> 00:03:26,199
这里面有个问题

109
00:03:26,199 --> 00:03:28,233
就是你n必须要大于0

110
00:03:28,233 --> 00:03:30,166
你如果等于0它就没有意义嘛, 对吧

111
00:03:30,166 --> 00:03:31,599
所以我这边有个 assert

112
00:03:31,599 --> 00:03:34,099
assert 就是断言, 就是假定

113
00:03:34,366 --> 00:03:35,933
假定N一定要大于等于1

114
00:03:35,933 --> 00:03:37,099
如果是等于0的话

115
00:03:37,099 --> 00:03:39,699
你给定等于0这个计算机会报错

116
00:03:39,699 --> 00:03:42,099
就是说, 你告诉我n是大于等于1

117
00:03:42,099 --> 00:03:44,233
但是你给我1个0我不知道怎么算的

118
00:03:44,233 --> 00:03:44,899
它就会报错

119
00:03:44,899 --> 00:03:46,533
这个就是一个比较好的习惯

120
00:03:46,533 --> 00:03:49,833
就是让让你这个程序比较那个清楚

121
00:03:49,833 --> 00:03:52,033
就是不会有一些很意外的这种

122
00:03:52,199 --> 00:03:52,799
情况发生

123
00:03:52,799 --> 00:03:55,633
那我们这个a是等于 f(n-1), 是吧?

124
00:03:55,666 --> 00:03:57,633
我们这个之前的这个情况

125
00:03:57,633 --> 00:03:59,433
比如说它是等于 "332225"

126
00:03:59,566 --> 00:04:00,399
我要把它

127
00:04:00,966 --> 00:04:02,233
归类嘛就分组是吧

128
00:04:02,233 --> 00:04:02,966
我要分组

129
00:04:02,966 --> 00:04:05,466
那我分组我就可以去数, 那怎么办呢

130
00:04:05,633 --> 00:04:08,166
有个比较好的方法叫 itertools

131
00:04:08,366 --> 00:04:09,700
groupby 我给你举个例子

132
00:04:09,700 --> 00:04:11,066
比如说这个a是等于

133
00:04:11,600 --> 00:04:14,566
112233333好吧

134
00:04:14,566 --> 00:04:15,066
这样分组

135
00:04:15,066 --> 00:04:16,833
它实际上是要把这个 "111" 同样的

136
00:04:16,833 --> 00:04:18,300
分一组 "222" 分一组

137
00:04:18,400 --> 00:04:20,466
分一组, "3333", 分一组, 那怎么弄呢?

138
00:04:20,466 --> 00:04:21,466
它是有个叫 itertools

139
00:04:21,599 --> 00:04:24,666
from itertools import

140
00:04:25,599 --> 00:04:27,133
调用这个包叫做 groupby

141
00:04:27,733 --> 00:04:29,466
那 groupby 就是 groupby嘛

142
00:04:29,566 --> 00:04:32,866
然后它实际上 (i, j) 它是返回一个那个

143
00:04:33,400 --> 00:04:34,466
就一个 tuple

144
00:04:34,666 --> 00:04:38,333
元主 in groupby(a)

145
00:04:38,333 --> 00:04:40,433
我把这个 groupby, 那我可以 print 一下

146
00:04:40,433 --> 00:04:40,966
它是什么

147
00:04:40,966 --> 00:04:43,266
i 就是这个每个组的元素

148
00:04:43,266 --> 00:04:44,766
它会返回是123嘛

149
00:04:44,766 --> 00:04:46,966
然后这个 j 它是那个组

150
00:04:47,166 --> 00:04:48,733
它所代表的那个组

151
00:04:48,733 --> 00:04:50,633
那它实际上是一个迭代器 (Iterator) 我要把它

152
00:04:50,699 --> 00:04:52,099
把它转换成这个 list 的

153
00:04:52,099 --> 00:04:53,266
就是转换成个列表

154
00:04:53,266 --> 00:04:54,899
那我们看一下它会得到什么

155
00:04:54,899 --> 00:04:55,799
我们跑一下

156
00:04:56,866 --> 00:04:58,599
你看吧你看吧这个123嘛

157
00:04:58,599 --> 00:05:01,266
123, 1它是有三个1嘛, 对吧

158
00:05:01,500 --> 00:05:04,466
两个2, 3是有5个3对吧

159
00:05:04,466 --> 00:05:06,300
这就刚好上面对应的这种情况嘛

160
00:05:06,300 --> 00:05:07,700
那所以这个 i 就是说

161
00:05:07,733 --> 00:05:10,166
相当于这个每个组的

162
00:05:10,166 --> 00:05:11,366
这个独立的这个

163
00:05:11,366 --> 00:05:12,766
这个unique就是唯一的

164
00:05:12,766 --> 00:05:15,200
这个代表这个组的元素就是1, 2, 3

165
00:05:15,200 --> 00:05:17,066
然后它的这个 list 的

166
00:05:17,100 --> 00:05:17,800
它是一个迭代器 (Iterator)

167
00:05:17,800 --> 00:05:18,900
我把它转成 list 的

168
00:05:18,900 --> 00:05:20,766
就是相当于是它那个组

169
00:05:20,766 --> 00:05:22,266
你看有3个有两个

170
00:05:22,333 --> 00:05:24,366
有5个那 我也可以把它

171
00:05:24,533 --> 00:05:26,033
加一个 len 函数 对吧

172
00:05:26,033 --> 00:05:27,733
加一个 len 函数就获取它的长度

173
00:05:27,733 --> 00:05:29,933
那么它就是实际上它就会得到什么呢

174
00:05:30,200 --> 00:05:33,566
就1有3个, 2有两个, 3有5个, 对吧

175
00:05:33,566 --> 00:05:35,133
那有这个我们就很方便了, 是吧

176
00:05:35,133 --> 00:05:39,066
那我们就可以说 for i, j in groupby, 是吧

177
00:05:39,066 --> 00:05:43,533
itertools.groupby(a)

178
00:05:43,600 --> 00:05:45,700
对吧, 基于之前的结果, 然后来

179
00:05:45,999 --> 00:05:46,199
然后

180
00:05:46,199 --> 00:05:48,066
我首先要把这个结果放在这个 answer

181
00:05:48,066 --> 00:05:48,399
answer 里面

182
00:05:48,399 --> 00:05:50,099
answer 我先首先放那个 list 好了

183
00:05:50,133 --> 00:05:52,833
groupby(a) 然后 ans.append

184
00:05:53,433 --> 00:05:55,466
append 什么呢, 最我要数它多少个嘛

185
00:05:55,533 --> 00:05:57,499
是不是我首先数那个组里面有多少个

186
00:05:57,499 --> 00:05:58,733
那我首先是要把它

187
00:05:59,033 --> 00:06:00,533
对先给它转换成 list 的, 是吧

188
00:06:00,533 --> 00:06:01,733
刚才说了 list 的

189
00:06:01,799 --> 00:06:03,466
然后 list 的完以后

190
00:06:03,666 --> 00:06:05,133
有多少个, 是吧

191
00:06:05,399 --> 00:06:07,666
然后但是它这个是要变成字符串

192
00:06:07,666 --> 00:06:09,033
就再给它转成字符串

193
00:06:09,033 --> 00:06:09,833
对

194
00:06:09,999 --> 00:06:13,333
那就这样, 这有好多括号, 嗯 groupby

195
00:06:14,199 --> 00:06:16,333
嗯, 这为什么有个下划线呢?

196
00:06:16,666 --> 00:06:17,966
然后 ans.append

197
00:06:18,400 --> 00:06:21,100
再来就是它这前面这个是有多少个

198
00:06:21,100 --> 00:06:22,766
那后面是多少个什么嘛, 对吧

199
00:06:22,766 --> 00:06:24,333
i 就是多少个什么嘛

200
00:06:24,333 --> 00:06:24,966
对吧

201
00:06:24,966 --> 00:06:26,600
然后完了之后你看一下这个 ans

202
00:06:26,600 --> 00:06:28,400
它实际上是一个

203
00:06:28,566 --> 00:06:29,166
它是什么呢

204
00:06:29,166 --> 00:06:31,933
它实际上是一个相当于一个列表

205
00:06:31,933 --> 00:06:34,833
就是比如说一个2对吧

206
00:06:34,833 --> 00:06:38,800
两个3 三个5比如说是这样的

207
00:06:38,800 --> 00:06:41,033
那我把这个东西给它变成字符串

208
00:06:41,033 --> 00:06:43,566
那我就是要用一个叫做

209
00:06:43,800 --> 00:06:47,733
join 函数, 就是 join, 我们之前讲过了 join

210
00:06:48,000 --> 00:06:48,966
join 什么呢

211
00:06:49,166 --> 00:06:50,100
join(ans)

212
00:06:50,233 --> 00:06:51,633
对吧, 这个是分割符

213
00:06:51,699 --> 00:06:53,299
我如果空的话就是把它统统加起来嘛

214
00:06:53,399 --> 00:06:54,499
这之前讲过

215
00:06:54,499 --> 00:06:55,433
这样应该就可以

216
00:06:55,433 --> 00:06:59,833
那我们调用一下这个 f(n), return f(n) 好吧

217
00:06:59,833 --> 00:07:02,599
跑一下, 先跑一下测试用例

218
00:07:02,866 --> 00:07:04,499
哎 你看它两个都过了嘛 是吧

219
00:07:04,599 --> 00:07:07,233
哎, 这是过还没过呢? 这是过了吧, 哈

220
00:07:07,233 --> 00:07:10,466
a few seconds ago, 你看这就过了, 对

221
00:07:10,599 --> 00:07:12,133
我们回顾一下

222
00:07:12,133 --> 00:07:13,900
简单理解一下就是这个

223
00:07:13,900 --> 00:07:15,700
我们这个递归调用自己

224
00:07:15,866 --> 00:07:17,466
然后如果等于1的时候

225
00:07:17,466 --> 00:07:18,766
我们就解决了这个问题

226
00:07:18,766 --> 00:07:21,800
然后我们根据之前那个数的结果去数

227
00:07:21,933 --> 00:07:25,400
这个就是数去用 groupby 去分组, 分组

228
00:07:25,400 --> 00:07:27,100
然后去数有多少个

229
00:07:27,266 --> 00:07:28,133
多少个什么呢

230
00:07:28,133 --> 00:07:28,600
然后加起来

231
00:07:28,600 --> 00:07:29,533
最后面用这个 join 函数

232
00:07:29,533 --> 00:07:31,333
join 函数把它给连接起来

233
00:07:31,333 --> 00:07:33,900
就把这个字符串数组

234
00:07:33,900 --> 00:07:35,266
一个数组变成一个

235
00:07:35,266 --> 00:07:36,566
那个字符串把它连起来

236
00:07:36,566 --> 00:07:37,866
join, 它的反过来的操作

237
00:07:37,866 --> 00:07:39,133
就是一个叫split

238
00:07:39,200 --> 00:07:41,333
对吧split and join, split就分开

239
00:07:41,400 --> 00:07:42,700
join 用一次合起来, 对吧

240
00:07:42,833 --> 00:07:43,833
比如 f(s+t)

241
00:07:44,200 --> 00:07:47,200
实际上在什么情况下是等于 f(s) + f(t)呢

242
00:07:47,633 --> 00:07:51,833
哎 就是比如说 f(123) 对吧

243
00:07:51,833 --> 00:07:55,366
然后 你要数123或者数456, 123456

244
00:07:55,366 --> 00:07:56,833
实际上是相当等于

245
00:07:56,833 --> 00:07:57,466
相当于什么呢

246
00:07:57,466 --> 00:08:00,500
f(123) 再加上 f(456)

247
00:08:00,500 --> 00:08:01,100
可以这么理解

248
00:08:01,100 --> 00:08:02,433
就是相当于你这个

249
00:08:02,633 --> 00:08:04,833
s的最后一个字符串

250
00:08:04,833 --> 00:08:07,166
最后一个字符不等于t的第一个字符

251
00:08:07,166 --> 00:08:09,200
就你可以把它分开来嘛

252
00:08:09,200 --> 00:08:10,366
比如说这个3不等于4

253
00:08:10,366 --> 00:08:12,500
那实际上就可以说, 我数123

254
00:08:12,500 --> 00:08:13,666
再加上456

255
00:08:13,666 --> 00:08:14,900
合起来可以这么理解吧

256
00:08:14,900 --> 00:08:16,866
对吧 嗯

257
00:08:17,000 --> 00:08:19,900
对 然后我们今天就讲到这个吧

258
00:08:19,900 --> 00:08:20,566
简单了一点

259
00:08:20,566 --> 00:08:22,866
今天就讲一个这个递归的方式

260
00:08:22,866 --> 00:08:23,866
递归的算法

261
00:08:23,866 --> 00:08:26,100
那我们最重要的递归就是说这需要

262
00:08:26,100 --> 00:08:27,433
有一个 Terminal Case

263
00:08:27,433 --> 00:08:28,900
就是要一个base case

264
00:08:29,033 --> 00:08:30,233
如果没有这个base case

265
00:08:30,233 --> 00:08:32,500
那计算机它就不停的循环调用自己

266
00:08:32,566 --> 00:08:34,700
但永远没有办法解决一个问题

267
00:08:34,900 --> 00:08:35,600
对吧, 那就是

268
00:08:35,600 --> 00:08:37,466
等于是相当于问题就没有得到解决

269
00:08:37,466 --> 00:08:38,566
这个就是递归的精髓

270
00:08:38,566 --> 00:08:40,433
你需要告诉它

271
00:08:40,433 --> 00:08:42,800
最基本的那种情况比如说 N阶乘 对吧

272
00:08:42,800 --> 00:08:45,166
n阶乘是等于n

273
00:08:45,200 --> 00:08:47,566
n乘于(n-1)阶乘是吧

274
00:08:47,733 --> 00:08:52,566
(n-1)阶乘就可以变成 (n-1)*(n-2)!

275
00:08:52,766 --> 00:08:54,166
(n-2)阶乘, 是吧

276
00:08:54,466 --> 00:08:56,266
直到1阶乘嘛, 或0阶乘嘛

277
00:08:56,266 --> 00:08:59,099
你得告诉它0阶乘等于1, 1阶乘等于1

278
00:08:59,099 --> 00:09:00,666
如果你都不告诉它0阶乘等于1

279
00:09:00,666 --> 00:09:04,199
那么它就会再继续调用自己就变得-2

280
00:09:04,199 --> 00:09:06,699
-3, -4, -5, -6 永远就是循环

281
00:09:06,699 --> 00:09:08,899
它没有办法解决, 它就会报错

282
00:09:08,966 --> 00:09:11,466
就是计算机里面很有名的叫做 Stack Over Flow

283
00:09:11,599 --> 00:09:13,933
就是 堆栈溢出了, 就这个问题

284
00:09:13,933 --> 00:09:14,999
因为它不停的调用

285
00:09:15,133 --> 00:09:15,933
调用调用.....

286
00:09:15,966 --> 00:09:18,266
但没有得到解决, 对吧, 嗯, 行

287
00:09:18,266 --> 00:09:19,899
今天就这样吧, 有什么问题嘛

288
00:09:19,933 --> 00:09:20,333
没有, 好

289
00:09:20,433 --> 00:09:22,199
这就是这期的视频

290
00:09:22,266 --> 00:09:24,599
如果大家喜欢我们的视频求点赞

291
00:09:24,633 --> 00:09:25,466
求收藏

292
00:09:25,466 --> 00:09:27,133
就这样 嗯 拜拜 拜拜 拜拜

