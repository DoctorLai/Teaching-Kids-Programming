1
00:00:00,266 --> 00:00:01,133
哎大家好

2
00:00:01,133 --> 00:00:03,166
今天我们讲第22课

3
00:00:03,166 --> 00:00:04,700
我们讲一个二叉树的问题

4
00:00:04,700 --> 00:00:05,900
二叉树就是一个

5
00:00:05,900 --> 00:00:07,133
数据结构吧 它的

6
00:00:07,133 --> 00:00:09,233
每个节点 最多有两个孩子吗 对吧

7
00:00:09,233 --> 00:00:12,300
然后没有孩子的那个叫树叶节点 对吧

8
00:00:12,300 --> 00:00:13,100
Leaf / Leaves

9
00:00:13,400 --> 00:00:16,400
然后没有父母的它是叫做根结点

10
00:00:16,400 --> 00:00:17,566
这个就是 Root 的对吧

11
00:00:17,733 --> 00:00:19,200
然后我们二叉树

12
00:00:19,200 --> 00:00:20,033
它实际上每个节点

13
00:00:20,033 --> 00:00:21,666
它是可以存一些数据的嘛

14
00:00:21,666 --> 00:00:23,133
所以它是一个数据结构

15
00:00:23,133 --> 00:00:24,000
放数字的话

16
00:00:24,000 --> 00:00:26,300
比如说 这个根节点 比如说 10

17
00:00:26,566 --> 00:00:29,300
我们规定它左边的节点都永远比

18
00:00:29,533 --> 00:00:30,933
根节点小

19
00:00:30,933 --> 00:00:32,200
右边的节点比它大

20
00:00:32,200 --> 00:00:33,666
比如说我们这个放一个7

21
00:00:34,433 --> 00:00:36,533
然后这边放一个13对吧

22
00:00:36,866 --> 00:00:39,900
那要比7小的就是 随便放一个5

23
00:00:40,400 --> 00:00:41,766
然后这边我比它大

24
00:00:42,166 --> 00:00:43,466
这边注意哈

25
00:00:43,466 --> 00:00:44,366
我这边根结点

26
00:00:44,366 --> 00:00:46,200
这边这个结点要比这个7大

27
00:00:46,200 --> 00:00:47,400
但是要不能比10大

28
00:00:47,400 --> 00:00:49,600
如果你放一个12就不行了 对吧

29
00:00:49,700 --> 00:00:50,800
12它还是在这

30
00:00:50,933 --> 00:00:52,200
10这个节点的左边

31
00:00:52,200 --> 00:00:53,166
所以它是要比它小

32
00:00:53,166 --> 00:00:55,633
所以它这边只能放一个8或者9这样的

33
00:00:56,133 --> 00:00:57,166
树这么构建起来

34
00:00:57,166 --> 00:00:59,533
我们就称它为叫做二叉搜索树

35
00:00:59,533 --> 00:01:00,900
binary search tree 

36
00:01:00,900 --> 00:01:02,100
比如说这个是11

37
00:01:02,733 --> 00:01:04,166
这个是15

38
00:01:04,900 --> 00:01:06,166
对这样

39
00:01:06,200 --> 00:01:07,733
这个就是二叉搜索树

40
00:01:07,733 --> 00:01:09,133
那这个有什么好处呢

41
00:01:09,333 --> 00:01:12,266
我们搜索它的这个效率就会大大提高

42
00:01:12,266 --> 00:01:13,100
对吧 如果

43
00:01:13,100 --> 00:01:13,333
比如说

44
00:01:13,333 --> 00:01:15,600
我们搜索看一下11在不在这个树里面

45
00:01:15,966 --> 00:01:17,600
那我们以前如果不

46
00:01:17,766 --> 00:01:19,866
如果没有按照这种顺序去排

47
00:01:20,200 --> 00:01:21,666
排列这个二叉树的话

48
00:01:21,666 --> 00:01:23,866
那么我们就得必须

49
00:01:24,266 --> 00:01:26,133
每个节点都去搜索对吧

50
00:01:26,133 --> 00:01:28,900
那我现在只要每一个进行判断

51
00:01:28,900 --> 00:01:31,066
比如说11是不是在比10大

52
00:01:31,066 --> 00:01:32,900
那我就它肯定是在右边吗对吧

53
00:01:33,100 --> 00:01:36,000
然后再往下走 往右边走 比13小

54
00:01:36,233 --> 00:01:37,733
那往左边走 对不对

55
00:01:37,766 --> 00:01:38,966
那它这个效率就很高

56
00:01:38,966 --> 00:01:40,666
比如说它这里有 n 个节点的话

57
00:01:40,666 --> 00:01:42,166
它的高度是多少呢

58
00:01:42,500 --> 00:01:44,300
这边你看每个树的假设

59
00:01:44,300 --> 00:01:45,433
它都是很平衡的

60
00:01:45,433 --> 00:01:46,933
平衡就是说

61
00:01:46,933 --> 00:01:49,333
平衡二叉树就是说左边和右边的这个

62
00:01:49,333 --> 00:01:51,500
每个任意节点的左边的

63
00:01:51,500 --> 00:01:52,800
深度和右边的深度

64
00:01:53,033 --> 00:01:54,333
误差不超过一嘛

65
00:01:54,633 --> 00:01:55,900
就是你相当平衡

66
00:01:55,900 --> 00:01:57,733
举一个比较不平衡的例子就是

67
00:01:57,733 --> 00:01:58,966
比如说它只有一边嘛

68
00:01:58,966 --> 00:02:00,200
这个就很不平衡嘛

69
00:02:00,766 --> 00:02:03,200
你看这个不平衡是不是就相当于

70
00:02:03,300 --> 00:02:04,233
没有办法

71
00:02:04,900 --> 00:02:06,866
分边走了对吧 你想 如果

72
00:02:07,533 --> 00:02:09,666
如果二叉树是这样子

73
00:02:09,666 --> 00:02:11,100
这个实际上也是一个二叉树

74
00:02:11,100 --> 00:02:12,500
如果它是这样子的情况下

75
00:02:12,500 --> 00:02:14,600
是不是它的搜索效率就很慢嘛

76
00:02:14,600 --> 00:02:16,000
它就是线性的吧 对吧

77
00:02:16,066 --> 00:02:17,466
比如说我11放在最后面

78
00:02:17,466 --> 00:02:19,966
那么它是不是得一个一个往下找

79
00:02:20,033 --> 00:02:21,633
嗯对吧 那你有 n 个的话

80
00:02:21,633 --> 00:02:22,333
它是不是 最情情况下

81
00:02:22,333 --> 00:02:24,333
最坏情况下是不是也要找N次

82
00:02:24,466 --> 00:02:25,633
那是 O(N) 吗

83
00:02:25,733 --> 00:02:27,466
那如果是像这种平衡的

84
00:02:27,466 --> 00:02:28,966
就左边右边都有的

85
00:02:29,066 --> 00:02:31,266
你看吧这个有 N 个节点

86
00:02:31,266 --> 00:02:33,733
那么它的高度就实际上是 LogN 吗 对吧

87
00:02:33,866 --> 00:02:34,700
嗯对

88
00:02:34,700 --> 00:02:37,333
那我每次我是不是分边走 我选一边

89
00:02:37,333 --> 00:02:40,266
那么它的时间复杂度就是 O(LogN) 

90
00:02:40,266 --> 00:02:42,133
这个它的时间复杂度就比较(小)快

91
00:02:42,133 --> 00:02:43,833
我们今天就讲了这个这个问题

92
00:02:44,000 --> 00:02:45,033
就有一道题

93
00:02:45,033 --> 00:02:46,733
Binary Search Tree 就是讲这样的

94
00:02:46,733 --> 00:02:48,933
给定一个二叉树 Root 根节点

95
00:02:48,933 --> 00:02:50,666
那么我判断一个 value

96
00:02:51,133 --> 00:02:51,366
对吧

97
00:02:51,366 --> 00:02:53,166
那看到这个Value在不在这个树里面

98
00:02:53,166 --> 00:02:54,066
对吧 你看

99
00:02:54,200 --> 00:02:55,200
比如说给定这个4

100
00:02:55,200 --> 00:02:57,500
它是在节点里面 那我们怎么判断呢

101
00:02:57,866 --> 00:02:59,199
4 大于它这个根结点

102
00:02:59,200 --> 00:03:00,233
它在右边是吧

103
00:03:00,233 --> 00:03:01,700
比9小在左边

104
00:03:02,000 --> 00:03:03,866
比7小 在左边 找到了 对吧

105
00:03:03,866 --> 00:03:06,633
那如果没找到的情况下就是 当它等于

106
00:03:07,033 --> 00:03:09,633
空的话 你再比如说 我要找3

107
00:03:09,633 --> 00:03:10,966
找一个1好了 对吧

108
00:03:12,100 --> 00:03:12,900
3

109
00:03:13,166 --> 00:03:14,200
往左边走

110
00:03:14,200 --> 00:03:15,000
2

111
00:03:15,233 --> 00:03:16,633
没有没有路可以走了吗

112
00:03:16,633 --> 00:03:18,100
那么它就没找到了对吧

113
00:03:18,200 --> 00:03:21,033
那这边来再看一个例子 100对吧

114
00:03:21,233 --> 00:03:22,466
比3大在右边

115
00:03:22,466 --> 00:03:23,666
比9大在右边

116
00:03:23,666 --> 00:03:25,200
比12大在右

117
00:03:25,200 --> 00:03:26,633
在右边 但是没有右边了

118
00:03:26,633 --> 00:03:28,133
那么它就没找到对吧

119
00:03:28,233 --> 00:03:31,566
这题它是可以有两种算法

120
00:03:31,566 --> 00:03:33,266
我们先用递归的方式吗

121
00:03:33,266 --> 00:03:34,766
递归就是Recursion

122
00:03:34,966 --> 00:03:36,500
就是自己调用自己

123
00:03:36,733 --> 00:03:37,833
比如说我就可以

124
00:03:38,066 --> 00:03:40,500
在这边先定一个叫做 search

125
00:03:40,500 --> 00:03:41,800
我先填个坑

126
00:03:41,800 --> 00:03:44,800
我要返回就是 return 这个 search

127
00:03:45,200 --> 00:03:46,200
search(root, val)

128
00:03:46,200 --> 00:03:47,766
对吧 然后这样 search

129
00:03:48,700 --> 00:03:50,500
如果 root

130
00:03:50,900 --> 00:03:52,666
等于空的话就 is None 对吧

131
00:03:52,666 --> 00:03:54,500
你可以这么写或者 if not root

132
00:03:54,500 --> 00:03:55,300
如果都

133
00:03:55,300 --> 00:03:57,433
Root 就是这个节点 已经空了 没路走了

134
00:03:57,433 --> 00:03:59,766
那么我是不是返回 找不到了 对吧

135
00:03:59,866 --> 00:04:01,900
如果这个节点这个 value

136
00:04:02,333 --> 00:04:03,600
如果是等于

137
00:04:04,100 --> 00:04:05,100
root.value

138
00:04:05,433 --> 00:04:08,100
相等了那么是不是 return True 是不是

139
00:04:08,100 --> 00:04:08,566
嗯

140
00:04:08,566 --> 00:04:11,700
那如果这时候是 如果比它小 root.value

141
00:04:12,033 --> 00:04:14,266
那么我应该往哪里走?

142
00:04:14,500 --> 00:04:15,466
这个我们要找的

143
00:04:15,466 --> 00:04:17,366
这个节点比这个根节点要小

144
00:04:17,366 --> 00:04:18,866
那么它应该往左还往右?

145
00:04:19,500 --> 00:04:21,866
左边走 那我就是 return 

146
00:04:21,866 --> 00:04:24,466
调用自己 search(root.left, val)

147
00:04:24,900 --> 00:04:26,766
search(root.left, val) 对吧

148
00:04:27,100 --> 00:04:28,866
那否则的话就是 return

149
00:04:29,300 --> 00:04:30,100
search

150
00:04:30,633 --> 00:04:32,766
search(root.right, value) 对吧

151
00:04:32,900 --> 00:04:35,066
这样就可以 这样应该是可以过的

152
00:04:35,366 --> 00:04:38,966
过了 对这个就过 这个是

153
00:04:38,966 --> 00:04:40,766
就是很简单的方法 就是

154
00:04:41,066 --> 00:04:44,000
递归 我判断节点在

155
00:04:44,266 --> 00:04:45,500
在左边的话

156
00:04:45,500 --> 00:04:48,100
那么我就往左走 就 root.left 就往左走

157
00:04:48,433 --> 00:04:49,666
root.right 就往右走

158
00:04:49,899 --> 00:04:51,366
哎 它这有数据量吗?

159
00:04:51,366 --> 00:04:52,233
我们可以看一下

160
00:04:52,233 --> 00:04:54,166
线性的应该也是可以过的吗

161
00:04:54,166 --> 00:04:54,966
你看它这个

162
00:04:55,233 --> 00:04:56,399
这个是10的五次方

163
00:04:56,433 --> 00:04:59,133
这个Log个10的五次方 实际上是很小

164
00:04:59,399 --> 00:05:00,633
但如果 O(N) 的话

165
00:05:00,633 --> 00:05:02,033
线性的话应该是可以过

166
00:05:02,033 --> 00:05:03,266
线性的话 就怎么

167
00:05:03,333 --> 00:05:03,766
怎么办呢

168
00:05:03,766 --> 00:05:04,966
我就不要判断了

169
00:05:05,099 --> 00:05:06,866
我就判断它是不是在

170
00:05:07,399 --> 00:05:10,766
是在左边 或者 是在右边嘛 

171
00:05:11,499 --> 00:05:13,566
那这时候它的算法就是

172
00:05:14,099 --> 00:05:16,099
反正我就左边找

173
00:05:16,166 --> 00:05:18,366
没有找到就在右边找 那它这个

174
00:05:18,566 --> 00:05:20,666
时间复杂度是线性的对吧

175
00:05:20,666 --> 00:05:21,466
试一下 

176
00:05:21,766 --> 00:05:23,800
我没有 return

177
00:05:24,400 --> 00:05:25,500
对刚才3毫秒

178
00:05:25,500 --> 00:05:26,133
现在1毫秒

179
00:05:26,133 --> 00:05:27,833
因为我们现在的时间复杂度

180
00:05:27,833 --> 00:05:28,633
会好一点

181
00:05:28,666 --> 00:05:30,133
然后我们现在讲那个

182
00:05:30,400 --> 00:05:32,033
另外一种方法就是

183
00:05:32,333 --> 00:05:33,433
不用递归的方法

184
00:05:33,433 --> 00:05:35,133
不用递归就是我们刚才

185
00:05:35,233 --> 00:05:36,366
给你演示的那个

186
00:05:37,033 --> 00:05:38,533
就往左就往左是吧

187
00:05:38,533 --> 00:05:39,800
那我就这么简单

188
00:05:39,800 --> 00:05:41,333
while root

189
00:05:41,400 --> 00:05:42,966
对吧 当 root 不是空

190
00:05:42,966 --> 00:05:44,300
当我还可以走的时候

191
00:05:44,333 --> 00:05:45,766
对吧 那么

192
00:05:46,166 --> 00:05:49,533
如果 root.value 要等于 value

193
00:05:49,533 --> 00:05:50,766
那么我就找到了是吧

194
00:05:50,933 --> 00:05:55,800
嗯 那如果这个 Value 要小于 root 的Value

195
00:05:56,566 --> 00:05:58,033
小于 root.Value

196
00:05:59,300 --> 00:06:02,400
那我应该是root要往左走 是吧

197
00:06:02,400 --> 00:06:05,633
那这时候就是 root等于root.left 对不对

198
00:06:05,633 --> 00:06:06,866
否则的话是什么呢

199
00:06:06,866 --> 00:06:08,666
你们告诉我一下root等于什么

200
00:06:08,666 --> 00:06:09,466
如果它在

201
00:06:09,566 --> 00:06:10,966
那就root.right是吧

202
00:06:10,966 --> 00:06:12,866
嗯那如果在外面呢

203
00:06:12,866 --> 00:06:13,133
外面

204
00:06:13,133 --> 00:06:15,466
如果它没路走了应该会return True还是False?

205
00:06:16,233 --> 00:06:17,466
False 对嗯

206
00:06:18,366 --> 00:06:19,233
试一下

207
00:06:21,366 --> 00:06:23,099
你看这样也是可以吗 对吧

208
00:06:23,099 --> 00:06:24,399
今天我们就

209
00:06:24,666 --> 00:06:26,366
基本上就讲这个这么个问题

210
00:06:26,366 --> 00:06:28,199
这个二叉搜索树

211
00:06:28,233 --> 00:06:29,066
Binary Search Tree

212
00:06:29,066 --> 00:06:30,733
算是一个非常有用的数据结构

213
00:06:30,733 --> 00:06:32,466
它基本上能够把

214
00:06:32,466 --> 00:06:33,333
那个时间复杂度

215
00:06:33,333 --> 00:06:35,500
从 O(N) 线性的方法 给它提高

216
00:06:35,633 --> 00:06:37,100
提高到 O(LogN)

217
00:06:37,100 --> 00:06:39,233
那这个是一个非常大的提升嘛

218
00:06:39,233 --> 00:06:40,066
对吧 你想想

219
00:06:40,066 --> 00:06:40,866
O(N)

220
00:06:41,466 --> 00:06:42,233
这样

221
00:06:42,233 --> 00:06:43,866
O(LogN) 是这样

222
00:06:43,966 --> 00:06:47,000
对吧你看当 N 很大的时候 对吧

223
00:06:47,000 --> 00:06:48,866
这个difference(区别)是很大的

224
00:06:48,866 --> 00:06:50,600
行 我们今天就讲到这吧

225
00:06:50,600 --> 00:06:52,466
今天就先这样嗯

226
00:06:54,000 --> 00:06:55,566
好 就这样 拜拜 拜拜

