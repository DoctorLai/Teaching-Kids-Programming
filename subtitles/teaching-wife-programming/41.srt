1
00:00:00,533 --> 00:00:01,399
哎 大家好

2
00:00:01,400 --> 00:00:02,900
今天我们讲第41课啊

3
00:00:02,900 --> 00:00:05,666
讲一个 那个 计算机里面比较重要的

4
00:00:05,666 --> 00:00:07,566
这个数据结构叫图

5
00:00:07,666 --> 00:00:08,999
图英文就是 Graph

6
00:00:09,000 --> 00:00:12,100
图我们可以用大G来表示

7
00:00:12,100 --> 00:00:14,700
它实际上是一个v和e的一个collection 集合

8
00:00:14,700 --> 00:00:17,466
集合 这个v就是vertex

9
00:00:17,566 --> 00:00:19,499
顶点

10
00:00:19,933 --> 00:00:21,966
E就是edges, 边

11
00:00:22,066 --> 00:00:23,933
那以前我们讲过那个二叉树 对吧

12
00:00:23,933 --> 00:00:25,066
二叉树 三叉树

13
00:00:25,066 --> 00:00:28,099
多叉树 二叉树实际上就是一个图

14
00:00:28,366 --> 00:00:30,466
那二叉树 它有顶点嘛

15
00:00:30,466 --> 00:00:32,366
就是每个有节点

16
00:00:32,366 --> 00:00:34,566
然后那个父母指向孩子的那个

17
00:00:34,566 --> 00:00:35,499
就叫边对吧

18
00:00:35,500 --> 00:00:37,333
我们先画一下这个

19
00:00:37,466 --> 00:00:38,666
你看这个1

20
00:00:39,500 --> 00:00:41,666
这个2, 这个根节点是1是吧

21
00:00:41,666 --> 00:00:43,166
然后它有两个节点

22
00:00:43,166 --> 00:00:44,199
两个孩子节点

23
00:00:44,200 --> 00:00:46,300
左叉树 右叉树 左节点 右节点

24
00:00:46,300 --> 00:00:48,266
那1是父母节点

25
00:00:48,500 --> 00:00:51,400
那2和3是左右子节点

26
00:00:51,400 --> 00:00:54,000
那一般来说是 从父母访问到这个孩子

27
00:00:54,000 --> 00:00:57,466
就是1-2 那1到3这个有带箭头的

28
00:00:57,466 --> 00:00:59,666
带箭头的我们就称为有向图啊

29
00:00:59,666 --> 00:01:01,133
如果没有带箭头的话

30
00:01:01,133 --> 00:01:02,899
就是代表1可以访问到2

31
00:01:02,900 --> 00:01:03,700
2也可以访问到1

32
00:01:03,700 --> 00:01:05,533
那么这个这样就叫做无向图

33
00:01:05,700 --> 00:01:06,700
就是 Directed

34
00:01:06,766 --> 00:01:08,333
或者是 Undirected

35
00:01:08,333 --> 00:01:10,766
这里面讲的概念 有向图

36
00:01:11,200 --> 00:01:13,000
或者是无向图

37
00:01:14,266 --> 00:01:16,399
那树实际上是DAG

38
00:01:16,400 --> 00:01:18,966
但是可以理解成一个DAG 就是有向无环图

39
00:01:18,966 --> 00:01:21,299
无环图 A就是 Acylic

40
00:01:21,966 --> 00:01:23,966
无环图 有向无环图

41
00:01:24,100 --> 00:01:26,133
那树它肯定不能是环吗

42
00:01:26,133 --> 00:01:28,533
如果你这边是加1条边

43
00:01:28,533 --> 00:01:30,366
它就不不是树了对吧

44
00:01:30,500 --> 00:01:31,600
在树里面的定义

45
00:01:31,600 --> 00:01:35,100
它就是说每个孩子它有两个呃

46
00:01:35,100 --> 00:01:36,300
最多有两个孩子啊

47
00:01:36,300 --> 00:01:37,733
每个节点最多有两个孩子

48
00:01:37,733 --> 00:01:39,899
每个节点最多只有一个父亲

49
00:01:39,966 --> 00:01:40,699
或者没有父亲

50
00:01:40,700 --> 00:01:41,900
就根节点没有父亲吗

51
00:01:41,900 --> 00:01:44,100
这个是树的定义啊

52
00:01:44,400 --> 00:01:46,166
那你加了1条边它就变成环

53
00:01:46,166 --> 00:01:47,566
那就不符合这个定义

54
00:01:48,066 --> 00:01:50,733
那还有一个概念就是

55
00:01:51,733 --> 00:01:53,466
Simple Graph 简单图

56
00:01:53,466 --> 00:01:56,199
现在我们看那个 任意两个顶点之间

57
00:01:56,700 --> 00:01:57,466
只有一条边

58
00:01:57,466 --> 00:01:59,066
它不能说哎自己

59
00:01:59,566 --> 00:02:00,933
哎也不能说有两条边

60
00:02:00,933 --> 00:02:02,766
也不能说自己指向自己啊

61
00:02:02,933 --> 00:02:04,666
对吧这种是带环的

62
00:02:04,666 --> 00:02:07,266
叫 self loop 这种就不是简单图

63
00:02:07,266 --> 00:02:08,466
如果你说有两条边

64
00:02:08,466 --> 00:02:10,366
1-2它有两条路径的话

65
00:02:10,800 --> 00:02:12,133
那这种也不叫简单图

66
00:02:12,133 --> 00:02:12,966
简单图

67
00:02:13,366 --> 00:02:15,533
那图的概念里面还有一个比较重要

68
00:02:15,533 --> 00:02:16,766
就是联通性啊

69
00:02:16,766 --> 00:02:18,566
就是联通性

70
00:02:18,566 --> 00:02:21,333
就比如说我这个图 这样子啊

71
00:02:21,333 --> 00:02:22,133
那么

72
00:02:22,966 --> 00:02:24,533
它实际上都是联通的吗

73
00:02:24,533 --> 00:02:26,733
对吧或者去掉一条边也是联通

74
00:02:26,733 --> 00:02:28,399
但是如果这边再加一个顶点

75
00:02:28,400 --> 00:02:31,100
它不跟这个3个顶点有边的话

76
00:02:31,100 --> 00:02:32,900
这个就不联通对吧

77
00:02:33,900 --> 00:02:36,400
那还有一个叫做强联通性啊

78
00:02:36,400 --> 00:02:38,133
strongly connected component

79
00:02:38,333 --> 00:02:38,966
强联通性

80
00:02:38,966 --> 00:02:40,499
就是说任意一个顶点

81
00:02:40,500 --> 00:02:41,900
图里面的任意一个顶点

82
00:02:41,900 --> 00:02:43,700
都可以访问到其它顶点

83
00:02:43,766 --> 00:02:47,066
都有到其它顶点的路径啊

84
00:02:47,066 --> 00:02:49,866
呃比如说1可以到任何其它顶点

85
00:02:50,100 --> 00:02:51,166
那我们要怎么样

86
00:02:51,166 --> 00:02:53,699
怎么样证明呃是强联通呢

87
00:02:53,700 --> 00:02:56,100
就是说我们可以证明两件事情

88
00:02:56,100 --> 00:02:58,533
一个是说我这个顶点可以到

89
00:02:58,733 --> 00:03:00,799
可以证明这个顶点到其它顶点

90
00:03:01,366 --> 00:03:02,666
然后也都有路吗

91
00:03:02,666 --> 00:03:04,133
然后再证明一个

92
00:03:04,133 --> 00:03:06,599
就是从其它顶点都可以到这个顶点

93
00:03:06,600 --> 00:03:08,133
就是1可以到任何其它顶点

94
00:03:08,133 --> 00:03:10,599
然后第二个事情是任何点都可以到顶点1

95
00:03:10,766 --> 00:03:12,066
那么这样

96
00:03:12,066 --> 00:03:13,066
两个证明加起来

97
00:03:13,066 --> 00:03:15,066
就可以证明任何一点可以到任意一点

98
00:03:15,066 --> 00:03:16,799
这叫strongly connected component

99
00:03:17,133 --> 00:03:18,899
那一般我们可以用深度优先来

100
00:03:18,900 --> 00:03:20,200
来解决这个问题

101
00:03:20,600 --> 00:03:21,400
呃

102
00:03:22,466 --> 00:03:24,933
然后这个我们讲这个图啊我们

103
00:03:25,300 --> 00:03:27,100
呃刚才讲的这个叫做什么

104
00:03:27,100 --> 00:03:29,100
有向图 无向图对吧

105
00:03:29,100 --> 00:03:30,166
那还有一个权重

106
00:03:30,166 --> 00:03:33,499
就是说比如说1可以到2 它的权重

107
00:03:33,900 --> 00:03:35,966
如果没有没有加数字 它就是无权图

108
00:03:35,966 --> 00:03:36,966
无权图吗

109
00:03:36,966 --> 00:03:39,933
无权图就是可以认为所有权重

110
00:03:40,066 --> 00:03:43,266
所有顶点之间的这个Cost

111
00:03:43,500 --> 00:03:44,366
它都是相等

112
00:03:44,366 --> 00:03:46,166
如果不相等我们可以加一个数字

113
00:03:46,166 --> 00:03:50,733
比如说1到2的Cost的是2, 2到3的Cost的是3

114
00:03:50,733 --> 00:03:54,699
那么比如说1到3的Cost的是100好了

115
00:03:55,000 --> 00:03:55,966
对吧 100

116
00:03:57,100 --> 00:03:58,700
那这时候你看从

117
00:03:59,100 --> 00:04:00,066
从1到3

118
00:04:00,066 --> 00:04:03,699
它实际上从它走, 考虑到这Cost的话

119
00:04:03,700 --> 00:04:07,066
它是1到2, 2到3这样Cost是2加3=5吗

120
00:04:07,066 --> 00:04:09,466
但你1到3直接到的话

121
00:04:09,466 --> 00:04:11,066
它的Cost是100 对不对

122
00:04:11,533 --> 00:04:14,133
是不是 这个这个就是说有权图

123
00:04:14,466 --> 00:04:16,166
啊有权重的这个图啊

124
00:04:16,200 --> 00:04:19,766
那这个这个有权重这个就很有意思啊

125
00:04:19,766 --> 00:04:21,366
比如说我可以呃

126
00:04:22,000 --> 00:04:24,200
图的这个算法里面就有一个一类

127
00:04:24,200 --> 00:04:25,566
叫做最短路径啊

128
00:04:25,566 --> 00:04:28,066
对啊就是我呃也给一个图

129
00:04:28,066 --> 00:04:30,333
然后每个顶点之间它有一个

130
00:04:30,666 --> 00:04:32,066
cost 的有个距离吧

131
00:04:32,066 --> 00:04:33,366
对吧 我们就说距离好了

132
00:04:33,366 --> 00:04:35,499
那么我们从a点到b点

133
00:04:35,866 --> 00:04:37,133
要求最短路径

134
00:04:37,166 --> 00:04:39,533
那它可能不是直接那条a点到b点

135
00:04:39,533 --> 00:04:40,799
它怎么堵车啊对吧

136
00:04:40,800 --> 00:04:43,333
那可能可以到c点a到c点

137
00:04:43,333 --> 00:04:44,933
c带到b点这样的

138
00:04:45,400 --> 00:04:47,566
这样的这个代价会更小一点

139
00:04:47,566 --> 00:04:49,099
这个叫最短路径对吧

140
00:04:49,200 --> 00:04:51,500
那还有一种叫做最小生成树

141
00:04:51,500 --> 00:04:53,300
Minimum Spanning Tree

142
00:04:53,566 --> 00:04:54,999
它就说给定一个图

143
00:04:55,166 --> 00:04:56,666
然后你要让它

144
00:04:56,866 --> 00:04:58,799
当然是联通的你要取

145
00:04:59,366 --> 00:04:59,999
取出

146
00:05:00,000 --> 00:05:03,200
你要给我说一个那个subset就是集合

147
00:05:03,200 --> 00:05:05,733
子集就是这个Edge的子集 边的子集

148
00:05:05,733 --> 00:05:08,166
那么你这些边的子集要让我取出来

149
00:05:08,166 --> 00:05:09,766
能让整个图联通

150
00:05:10,133 --> 00:05:11,266
但是这个

151
00:05:11,700 --> 00:05:14,133
这个权重和要最小

152
00:05:14,333 --> 00:05:15,533
而这个怎么理解呢?

153
00:05:15,533 --> 00:05:17,933
就是说 比如说 政府要建

154
00:05:18,100 --> 00:05:18,900
政府建公路, 对吧

155
00:05:18,900 --> 00:05:21,333
那几个周围的城市

156
00:05:21,466 --> 00:05:22,566
然后我

157
00:05:22,866 --> 00:05:24,899
每个城市里面的这个修路的代价

158
00:05:24,900 --> 00:05:25,566
我都知道

159
00:05:25,566 --> 00:05:27,733
那么政府只有一个要求

160
00:05:27,733 --> 00:05:30,933
就是说你要把所有城市都给联通起来

161
00:05:30,933 --> 00:05:33,933
就是从一个城市能不管你多远啊

162
00:05:33,933 --> 00:05:35,566
都能到另外一个城市去

163
00:05:35,900 --> 00:05:37,933
但是那政府当然要要求说

164
00:05:37,933 --> 00:05:40,766
最小化这个城市建设的这个代价啊

165
00:05:40,766 --> 00:05:44,166
这个公路建设的代价这个就是

166
00:05:44,366 --> 00:05:45,899
呃就是最小生成图(树, MST)

167
00:05:45,900 --> 00:05:47,333
我们可以举个例子啊

168
00:05:47,333 --> 00:05:48,466
就是比如说

169
00:05:48,733 --> 00:05:50,466
这刚才这个123吗对吧

170
00:05:50,466 --> 00:05:53,933
那我要联通的话 明显我就是1 选这个2

171
00:05:54,533 --> 00:05:56,199
假设它都是这个无向的啊

172
00:05:56,200 --> 00:05:57,933
我们就假设的无向的啊

173
00:05:58,366 --> 00:06:01,299
然后就是说那个2和3取2和3

174
00:06:01,300 --> 00:06:02,400
我不取这个100吗

175
00:06:02,400 --> 00:06:05,100
对吧我取了2和3那是123都连通了

176
00:06:05,100 --> 00:06:07,066
但我如果加上这个100的话

177
00:06:07,300 --> 00:06:09,900
那它的Cost的就比这个2加3要多吗

178
00:06:09,900 --> 00:06:12,366
对这个叫做最小生成树 - Minimum Spanning Tree

179
00:06:12,466 --> 00:06:14,699
有两种算法 (Prim's, Kruskal) 以后我们会讲啊

180
00:06:14,866 --> 00:06:17,166
那我们这节课其实要讲的重点是

181
00:06:17,166 --> 00:06:18,366
那个怎么去

182
00:06:18,566 --> 00:06:19,333
储存这个图

183
00:06:19,333 --> 00:06:21,366
计算机里面的怎么去储存这个图

184
00:06:21,366 --> 00:06:23,133
这个图本身是个数据结构嘛

185
00:06:23,133 --> 00:06:26,099
Data Structure它肯定呃是要储存

186
00:06:26,133 --> 00:06:29,566
电脑怎么去记录这个数据结构啊

187
00:06:29,700 --> 00:06:30,866
那其实很简单

188
00:06:30,866 --> 00:06:31,766
它有两种方法

189
00:06:31,766 --> 00:06:34,133
我就比如说举几个简单例子 0

190
00:06:34,500 --> 00:06:37,800
哦有像无向都可以啊就是0到1的话

191
00:06:38,333 --> 00:06:40,733
呃 0到1比如说代价是2

192
00:06:40,733 --> 00:06:41,999
那1到

193
00:06:42,800 --> 00:06:44,966
2的代价是3

194
00:06:45,166 --> 00:06:47,499
那2到0的代价比如说5加

195
00:06:47,500 --> 00:06:48,733
就这么一个简单的图

196
00:06:48,900 --> 00:06:50,766
那我怎么用计算机去储存呢?

197
00:06:50,766 --> 00:06:53,699
它有两种方法叫一种叫邻接矩阵

198
00:06:53,933 --> 00:06:54,966
叫 Adjacency Matrix

199
00:06:56,100 --> 00:06:56,900
Adjacency Matrix

200
00:06:57,500 --> 00:06:59,700
然后有一种叫做 Adjacency List (邻接列表)

201
00:06:59,700 --> 00:07:00,900
我们分别来讲一下

202
00:07:00,900 --> 00:07:02,800
Adjacency Matrix 实际上可以理解成

203
00:07:02,933 --> 00:07:03,999
我现在有三个顶点吗

204
00:07:04,000 --> 00:07:05,366
对吧 三个顶点

205
00:07:05,366 --> 00:07:09,566
那我就是建立一个3*3的那个矩阵对吧

206
00:07:09,800 --> 00:07:10,933
3*3的矩阵

207
00:07:12,266 --> 00:07:13,166
我3个顶点啊

208
00:07:13,166 --> 00:07:14,866
我比如说n等于3刚才那个三个顶点

209
00:07:14,866 --> 00:07:17,533
那我就建个矩阵 G

210
00:07:17,533 --> 00:07:20,166
就是下标就0-2那0-2

211
00:07:20,200 --> 00:07:21,700
那我这样表示什么

212
00:07:21,700 --> 00:07:24,700
比如G[i][j]就表示这个Cost

213
00:07:24,933 --> 00:07:29,699
Cost就是它的代价是从顶点vertex i到vertex j

214
00:07:29,900 --> 00:07:30,500
对吧

215
00:07:30,500 --> 00:07:33,666
那我们看看一下啊这0我们首先给它

216
00:07:34,466 --> 00:07:36,599
建立这个3*3的0吗

217
00:07:36,600 --> 00:07:37,400
0

218
00:07:38,066 --> 00:07:38,933
初始值是0

219
00:07:38,933 --> 00:07:40,299
那这个对角线

220
00:07:40,300 --> 00:07:42,766
实际上就是自己顶点到自己本身吗

221
00:07:42,766 --> 00:07:43,499
那我们可以

222
00:07:43,500 --> 00:07:45,800
这个你就可以自己定义了

223
00:07:45,800 --> 00:07:48,466
自己到自己本身Cost的可以是0

224
00:07:48,466 --> 00:07:49,599
也可以是无穷大

225
00:07:49,600 --> 00:07:52,066
如果你不想让它自己到本身的话

226
00:07:52,300 --> 00:07:56,533
那比如说这个0到1的距离是2对吧

227
00:07:56,533 --> 00:07:58,166
0到1就是 G[0][1]

228
00:07:58,200 --> 00:07:59,366
G[0][1] 就这个值

229
00:07:59,366 --> 00:08:01,566
那它要等于2对吧

230
00:08:01,933 --> 00:08:05,199
那1到2, G[1][2]等于3对吧

231
00:08:05,300 --> 00:08:07,866
G[1][2]等于3

232
00:08:09,300 --> 00:08:10,733
试试那下面是 G

233
00:08:11,600 --> 00:08:12,300
这个是什么

234
00:08:12,300 --> 00:08:14,900
2到0, G[2][0]等于5是吧

235
00:08:15,100 --> 00:08:18,333
G[2][0] 等于5

236
00:08:18,333 --> 00:08:20,199
那么这样就可以定义了 对吧

237
00:08:20,366 --> 00:08:23,466
这个就是一个用邻接矩阵  Adjacency Matrix

238
00:08:23,733 --> 00:08:26,666
那如果是无向图的话 这就是无向图

239
00:08:26,666 --> 00:08:30,299
就是 G[i][j] = G[j][i]

240
00:08:30,600 --> 00:08:32,600
对吧无向图就是i到j就可以

241
00:08:32,600 --> 00:08:33,766
j也可以到i吗

242
00:08:33,800 --> 00:08:36,200
那实际上就是相当于对角线对称嘛

243
00:08:36,200 --> 00:08:37,066
就是这个是2

244
00:08:37,066 --> 00:08:38,699
那么这个点也是2是不是

245
00:08:38,800 --> 00:08:41,600
这个是3 这个也是3 对吧对 称嘛 i到j

246
00:08:41,866 --> 00:08:43,999
j到i 的Cost的都一样

247
00:08:44,133 --> 00:08:45,766
这是那个 邻接矩阵

248
00:08:46,533 --> 00:08:47,399
矩阵

249
00:08:49,466 --> 00:08:52,399
然后另一个是叫 Adjacency List

250
00:08:52,400 --> 00:08:54,066
Adjacency List

251
00:08:55,266 --> 00:08:57,199
Adjacency List

252
00:08:57,366 --> 00:08:58,999
那它实际上它是可以这么理解

253
00:08:59,000 --> 00:09:00,333
它是一个 dictionary

254
00:09:00,933 --> 00:09:02,599
dictionary 我们讲过字典嘛

255
00:09:02,600 --> 00:09:04,666
key-value pairs 键值对

256
00:09:04,766 --> 00:09:08,266
那我刚才说这个0, 0它可以到哪里呢

257
00:09:08,800 --> 00:09:12,533
0现在只能到1吗对吧

258
00:09:12,600 --> 00:09:15,566
那如果我再加一个这边0-5好了

259
00:09:16,333 --> 00:09:20,666
这边来一个03到

260
00:09:21,466 --> 00:09:24,866
到4好了 0-3是一个4啊 这是一个3啊

261
00:09:25,866 --> 00:09:27,199
0到3是一个4

262
00:09:27,500 --> 00:09:29,500
然后0到1是一个2是不是

263
00:09:29,800 --> 00:09:30,966
那我就是0吗

264
00:09:30,966 --> 00:09:32,999
0到1它的代价是2

265
00:09:33,000 --> 00:09:35,166
那0到3它的代价是4对吧

266
00:09:35,166 --> 00:09:37,966
这key 这个key 这个 G.keys()

267
00:09:39,300 --> 00:09:41,666
G.keys()就是它的这个顶点(列表)

268
00:09:41,666 --> 00:09:45,299
那它的value就是它这个顶点到的这个

269
00:09:45,566 --> 00:09:48,533
这些顶点 那你可以自己定义

270
00:09:48,533 --> 00:09:50,799
如果它是有权重的图

271
00:09:50,800 --> 00:09:51,966
那么你就是一个 Tuple

272
00:09:51,966 --> 00:09:53,666
就是它一个那个 Tuple

273
00:09:53,700 --> 00:09:55,066
元主 如果没有权重

274
00:09:55,066 --> 00:09:56,899
那么你就直接一个顶点就好了

275
00:09:57,066 --> 00:09:59,899
那它这个是说0到顶点1的代价是2

276
00:09:59,900 --> 00:10:02,466
0到顶点的3的代价是4

277
00:10:02,466 --> 00:10:05,566
然后呢1到2吗对吧

278
00:10:05,566 --> 00:10:07,699
1到2的代价是3

279
00:10:08,100 --> 00:10:09,333
那就1到

280
00:10:10,700 --> 00:10:12,266
2的代价是3对吧

281
00:10:12,266 --> 00:10:14,166
然后下来是什么

282
00:10:14,900 --> 00:10:18,933
呃 2到0的代价是5 是不是

283
00:10:19,100 --> 00:10:21,733
2到0的代价是5

284
00:10:21,866 --> 00:10:23,166
那还有一个顶点是3吗

285
00:10:23,166 --> 00:10:25,466
是吧 3没有到任何顶点是不是

286
00:10:25,733 --> 00:10:26,699
因为有向图

287
00:10:26,700 --> 00:10:28,600
3没有到任何顶点 那就是空列表

288
00:10:28,600 --> 00:10:29,966
这就是叫做邻接

289
00:10:30,466 --> 00:10:31,266
邻接列表

290
00:10:31,333 --> 00:10:34,133
列表因为 你看 它是一个列表对吧

291
00:10:34,366 --> 00:10:35,999
key是它的顶点

292
00:10:36,266 --> 00:10:40,266
value是这个顶点 所到的这个顶点的

293
00:10:40,500 --> 00:10:41,066
就是边吗

294
00:10:41,066 --> 00:10:42,099
你看认为它是1边吗

295
00:10:42,100 --> 00:10:43,366
你看0个有两个顶点

296
00:10:43,366 --> 00:10:47,566
两条边分别是到1代价是2, 到3代价是4

297
00:10:47,766 --> 00:10:49,366
对吧 刚才那个

298
00:10:49,866 --> 00:10:51,466
刚才那个就是 Adjacency Matrix

299
00:10:51,466 --> 00:10:53,866
就是一个n乘n的这个

300
00:10:54,400 --> 00:10:55,166
矩阵对吧

301
00:10:55,166 --> 00:10:56,166
这个也挺好

302
00:10:56,266 --> 00:10:58,699
有时候挺好用的 这个取决呃

303
00:10:59,266 --> 00:11:01,366
有些题 它用这种方法会比较好

304
00:11:01,366 --> 00:11:01,966
遍例的时候

305
00:11:01,966 --> 00:11:04,899
有时候用那种方法比较好对吧

306
00:11:04,966 --> 00:11:06,999
你看这个G如果 Adjacency List的话

307
00:11:07,000 --> 00:11:07,766
它就很好遍例

308
00:11:07,766 --> 00:11:08,599
我知道这个顶点

309
00:11:08,600 --> 00:11:10,366
我下一步我就可以跳到

310
00:11:10,800 --> 00:11:11,800
其它顶点对不对

311
00:11:11,800 --> 00:11:13,400
就是我知道

312
00:11:13,733 --> 00:11:16,333
我从我这个顶点能到哪一个顶点

313
00:11:16,333 --> 00:11:17,133
对不对

314
00:11:18,700 --> 00:11:21,266
然后 那个Adjacency Matrix就

315
00:11:21,333 --> 00:11:22,333
不太适合这样的

316
00:11:22,333 --> 00:11:23,999
因为你一个顶点你就不知道啊

317
00:11:24,000 --> 00:11:25,733
你看你只能查表对吧

318
00:11:25,733 --> 00:11:28,766
这个就这这个就两种储存图的这个

319
00:11:29,000 --> 00:11:30,200
方法吧

320
00:11:30,200 --> 00:11:31,466
那图论很有用啊

321
00:11:31,466 --> 00:11:32,733
这个刚才我讲了几个例子

322
00:11:32,733 --> 00:11:34,533
那这个图论

323
00:11:34,533 --> 00:11:36,266
我们以前讲的算法深度优先

324
00:11:36,266 --> 00:11:38,766
广度优先都可以用到这个图论的这个

325
00:11:39,066 --> 00:11:40,166
这个算法里面来

326
00:11:40,166 --> 00:11:42,366
这就是图论的这个数据结构里面来

327
00:11:42,400 --> 00:11:44,333
那跟这个跟这个深度优先

328
00:11:44,333 --> 00:11:44,899
广度优先

329
00:11:44,900 --> 00:11:47,400
用于这个二叉树的这个是很类似的

330
00:11:47,400 --> 00:11:48,500
但是在图论里面

331
00:11:48,500 --> 00:11:50,900
如果你要用深度优先和广度优先的话

332
00:11:50,933 --> 00:11:54,199
一般是需要用一个这个哈希表 seen=set()

333
00:11:54,466 --> 00:11:57,466
来代表说来储存一下我们能不能呃

334
00:11:57,700 --> 00:12:00,000
我们已经有没有已经走过这个

335
00:12:00,133 --> 00:12:01,199
这这个顶点了

336
00:12:01,200 --> 00:12:02,466
要不然的话它会重复走

337
00:12:02,466 --> 00:12:04,599
但是在树里面它就没有这样的结构

338
00:12:04,600 --> 00:12:05,566
为什么因为它

339
00:12:06,266 --> 00:12:08,333
树一般从父母到子节点吗

340
00:12:08,333 --> 00:12:09,799
它不可能再返回去所以你不用

341
00:12:09,800 --> 00:12:11,866
判断它有没有重复走对吧

342
00:12:12,300 --> 00:12:13,866
行我们今天就讲

343
00:12:14,000 --> 00:12:15,133
讲到这里吧啊

344
00:12:15,133 --> 00:12:15,766
有什么问题吗

345
00:12:15,766 --> 00:12:17,166
没有嗯 好啊

346
00:12:17,166 --> 00:12:18,699
就这样啊 嗯 拜拜

347
00:12:18,700 --> 00:12:19,500
拜拜

348
00:12:20,100 --> 00:12:22,000
这就是这期的内容

349
00:12:22,000 --> 00:12:23,600
如果喜欢我们的视频

