1
00:00:00,000 --> 00:00:05,600
hello hello mr mr ryan i like yeah okay

2
00:00:03,600 --> 00:00:07,759
so finally search trees let's say we

3
00:00:05,600 --> 00:00:09,920
have two finalists here

4
00:00:07,759 --> 00:00:10,800
10

5
00:00:09,920 --> 00:00:13,519
9

6
00:00:10,800 --> 00:00:15,360
11 and then

7
00:00:13,519 --> 00:00:16,800
7

8
00:00:15,360 --> 00:00:17,680
five

9
00:00:16,800 --> 00:00:20,080
eight

10
00:00:17,680 --> 00:00:21,359
okay and then we have another here four

11
00:00:20,080 --> 00:00:23,359
six

12
00:00:21,359 --> 00:00:25,199
right okay let me put another one is

13
00:00:23,359 --> 00:00:28,480
this a by research tree

14
00:00:25,199 --> 00:00:31,199
um no why is that beach has where is

15
00:00:28,480 --> 00:00:32,719
that 16 is not smaller than seven where

16
00:00:31,199 --> 00:00:35,680
the let's have a good spot

17
00:00:32,719 --> 00:00:37,280
the on the left on that left tree the

18
00:00:35,680 --> 00:00:38,960
nose has two piece

19
00:00:37,280 --> 00:00:42,000
the nose have to be strictly smaller

20
00:00:38,960 --> 00:00:44,079
than the parents the the loop yeah

21
00:00:42,000 --> 00:00:46,480
so on the left side put in other words

22
00:00:44,079 --> 00:00:48,879
on the left side the null test

23
00:00:46,480 --> 00:00:50,719
this might be the same as that well

24
00:00:48,879 --> 00:00:52,559
that's another question no

25
00:00:50,719 --> 00:00:54,320
because there's no duplicate yeah

26
00:00:52,559 --> 00:00:56,320
there's no difference all the notes

27
00:00:54,320 --> 00:00:58,640
needs to be unique right if it's a

28
00:00:56,320 --> 00:01:00,399
duplicate it's not strictly so what we

29
00:00:58,640 --> 00:01:02,480
say in the final century is the notes

30
00:01:00,399 --> 00:01:04,799
have to be strictly what's strictly

31
00:01:02,480 --> 00:01:06,080
smaller right it means and then they're

32
00:01:04,799 --> 00:01:08,320
on the right hand side of this chicken

33
00:01:06,080 --> 00:01:10,960
figure okay so that's good so if we want

34
00:01:08,320 --> 00:01:13,280
to perform the what kind of tree travels

35
00:01:10,960 --> 00:01:15,040
that gives these a sorted log a list i

36
00:01:13,280 --> 00:01:17,840
mean if it's a what order then you'll be

37
00:01:15,040 --> 00:01:19,040
in order what order will be left anybody

38
00:01:17,840 --> 00:01:21,840
in order

39
00:01:19,040 --> 00:01:24,000
in order so what in order in order is

40
00:01:21,840 --> 00:01:26,240
what we visit the left tree

41
00:01:24,000 --> 00:01:28,159
and we visited camera now and then we

42
00:01:26,240 --> 00:01:29,600
visit the right tree right why is it

43
00:01:28,159 --> 00:01:31,759
called in order because the node we are

44
00:01:29,600 --> 00:01:33,200
visiting is in in the middle let's go in

45
00:01:31,759 --> 00:01:35,840
all right yeah

46
00:01:33,200 --> 00:01:38,000
so at least the left beat and ripen are

47
00:01:35,840 --> 00:01:39,920
recursion we can do this because yeah so

48
00:01:38,000 --> 00:01:41,680
we recursively visit the left tree and

49
00:01:39,920 --> 00:01:44,960
then we visit the node

50
00:01:41,680 --> 00:01:46,720
i know we do visit the right trigger so

51
00:01:44,960 --> 00:01:49,439
this would be easier how do you how do

52
00:01:46,720 --> 00:01:50,560
you implement another defined in order

53
00:01:49,439 --> 00:01:53,840
easy

54
00:01:50,560 --> 00:01:56,240
and then lose and line yeah so if it's

55
00:01:53,840 --> 00:01:58,960
not empty we just return

56
00:01:56,240 --> 00:02:01,520
we just return empty this

57
00:01:58,960 --> 00:02:03,880
otherwise we return

58
00:02:01,520 --> 00:02:06,840
in order

59
00:02:03,880 --> 00:02:10,959
bluetooth left

60
00:02:06,840 --> 00:02:12,400
plus do the value

61
00:02:10,959 --> 00:02:14,560
plus

62
00:02:12,400 --> 00:02:15,599
in order

63
00:02:14,560 --> 00:02:17,680
blue

64
00:02:15,599 --> 00:02:19,760
right right

65
00:02:17,680 --> 00:02:22,720
yeah this is very trivial right come on

66
00:02:19,760 --> 00:02:22,720
right yeah

67
00:02:23,840 --> 00:02:26,160
ugly

68
00:02:24,800 --> 00:02:27,599
it's not

69
00:02:26,160 --> 00:02:29,760
it's not difficult right it's not

70
00:02:27,599 --> 00:02:29,760
difficult

71
00:02:29,920 --> 00:02:33,519
okay yeah

72
00:02:31,040 --> 00:02:36,080
okay so we probably talk about this this

73
00:02:33,519 --> 00:02:38,239
is recursion because we call it in order

74
00:02:36,080 --> 00:02:40,239
twice now to visit the left tree and to

75
00:02:38,239 --> 00:02:41,760
the visit the right thing okay

76
00:02:40,239 --> 00:02:44,080
to the visit the left tree and the y

77
00:02:41,760 --> 00:02:45,760
chip but we can do this iteratively yeah

78
00:02:44,080 --> 00:02:48,080
iterative okay

79
00:02:45,760 --> 00:02:48,800
okay so we can do this iteratively as

80
00:02:48,080 --> 00:02:50,640
well

81
00:02:48,800 --> 00:02:52,879
so we can do this iteration the thing is

82
00:02:50,640 --> 00:02:54,560
that we keep visiting the left tree

83
00:02:52,879 --> 00:02:56,800
because that's the smallest that give us

84
00:02:54,560 --> 00:02:58,800
smallest and then we push it into a

85
00:02:56,800 --> 00:03:00,959
stack we push this left in a stack and

86
00:02:58,800 --> 00:03:02,000
then we travel every time we take one

87
00:03:00,959 --> 00:03:04,000
out

88
00:03:02,000 --> 00:03:06,560
and we visit the right tree right

89
00:03:04,000 --> 00:03:07,920
because of the right look so look seven

90
00:03:06,560 --> 00:03:10,319
we push this

91
00:03:07,920 --> 00:03:11,680
we push this in uh stack yeah

92
00:03:10,319 --> 00:03:12,640
so

93
00:03:11,680 --> 00:03:13,519
seven

94
00:03:12,640 --> 00:03:14,319
five

95
00:03:13,519 --> 00:03:16,720
four

96
00:03:14,319 --> 00:03:20,080
right and then we take the four out this

97
00:03:16,720 --> 00:03:22,000
is four yeah take the four off

98
00:03:20,080 --> 00:03:24,239
and then it doesn't have the right okay

99
00:03:22,000 --> 00:03:25,599
then we take the fire out

100
00:03:24,239 --> 00:03:28,319
take the fire out

101
00:03:25,599 --> 00:03:30,959
yeah and then we go to the right

102
00:03:28,319 --> 00:03:33,040
six right and i will take it seven out

103
00:03:30,959 --> 00:03:35,519
and we go to the right

104
00:03:33,040 --> 00:03:38,720
which is a right yeah

105
00:03:35,519 --> 00:03:40,159
define in order

106
00:03:38,720 --> 00:03:42,640
let's do that

107
00:03:40,159 --> 00:03:45,680
okay so i i'll write the question here

108
00:03:42,640 --> 00:03:46,959
just to do the comparison with the

109
00:03:45,680 --> 00:03:49,440
root

110
00:03:46,959 --> 00:03:51,680
that will be very easy if not root let

111
00:03:49,440 --> 00:03:53,680
me write it again not loot

112
00:03:51,680 --> 00:03:56,239
if it's empty we return

113
00:03:53,680 --> 00:03:58,720
to this yeah

114
00:03:56,239 --> 00:04:01,920
and then we turn

115
00:03:58,720 --> 00:04:04,000
in order you know what whatever you know

116
00:04:01,920 --> 00:04:04,959
the one

117
00:04:04,000 --> 00:04:07,200
plus

118
00:04:04,959 --> 00:04:07,200
one

119
00:04:08,640 --> 00:04:13,280
plus in order

120
00:04:11,360 --> 00:04:16,720
so what should i put here

121
00:04:13,280 --> 00:04:18,560
i roll this five minutes ago

122
00:04:16,720 --> 00:04:20,880
here is what

123
00:04:18,560 --> 00:04:23,040
left yeah left yeah

124
00:04:20,880 --> 00:04:24,240
and then what's here

125
00:04:23,040 --> 00:04:26,320
right

126
00:04:24,240 --> 00:04:29,639
here these two are because you're not

127
00:04:26,320 --> 00:04:29,639
doing this

128
00:04:33,040 --> 00:04:37,120
this is the iterative answer

129
00:04:35,520 --> 00:04:39,520
and d1 yeah

130
00:04:37,120 --> 00:04:40,639
so wire we have a stack

131
00:04:39,520 --> 00:04:43,120
empty

132
00:04:40,639 --> 00:04:45,759
wire root

133
00:04:43,120 --> 00:04:48,639
or stack now we want to go to the left

134
00:04:45,759 --> 00:04:50,479
as as much as we can wire

135
00:04:48,639 --> 00:04:53,840
root

136
00:04:50,479 --> 00:04:53,840
stack dot append

137
00:04:54,840 --> 00:05:01,680
blue step of the pendulum and then low

138
00:04:58,320 --> 00:05:04,080
equals to the left

139
00:05:01,680 --> 00:05:06,560
right and then we take one out root

140
00:05:04,080 --> 00:05:08,960
equals stack the pop

141
00:05:06,560 --> 00:05:12,560
the last one and then

142
00:05:08,960 --> 00:05:12,560
answer the append

143
00:05:12,880 --> 00:05:16,320
root

144
00:05:14,000 --> 00:05:19,280
the value okay

145
00:05:16,320 --> 00:05:21,600
and lu equals to the right okay

146
00:05:19,280 --> 00:05:23,400
this is it's iterative

147
00:05:21,600 --> 00:05:25,520
and we can answer

148
00:05:23,400 --> 00:05:27,199
[Music]

149
00:05:25,520 --> 00:05:29,919
the tank and let's see both are the same

150
00:05:27,199 --> 00:05:31,280
but practically speaking the iterative

151
00:05:29,919 --> 00:05:32,800
one is

152
00:05:31,280 --> 00:05:33,600
faster right because it doesn't have

153
00:05:32,800 --> 00:05:35,440
this

154
00:05:33,600 --> 00:05:37,120
calling stack overhead at least one

155
00:05:35,440 --> 00:05:39,280
recursion recursion can be sometimes

156
00:05:37,120 --> 00:05:41,199
very costly

157
00:05:39,280 --> 00:05:43,440
yeah okay so that's coming back to

158
00:05:41,199 --> 00:05:46,160
today's question so we have to find

159
00:05:43,440 --> 00:05:46,160
another tree

160
00:05:46,320 --> 00:05:49,759
let's just put another

161
00:05:48,240 --> 00:05:50,479
a easy one

162
00:05:49,759 --> 00:05:52,720
so

163
00:05:50,479 --> 00:05:55,039
if we want to

164
00:05:52,720 --> 00:05:56,400
if we want to return all the elements

165
00:05:55,039 --> 00:05:59,440
from both

166
00:05:56,400 --> 00:06:01,120
binary search tree but in order so what

167
00:05:59,440 --> 00:06:02,319
what do we have look this find the

168
00:06:01,120 --> 00:06:04,479
search tree

169
00:06:02,319 --> 00:06:07,800
cl one two this final third string three

170
00:06:04,479 --> 00:06:07,800
four five

171
00:06:08,160 --> 00:06:12,319
exactly easy so how do we do this any

172
00:06:10,960 --> 00:06:14,400
idea come on

173
00:06:12,319 --> 00:06:15,919
this is ignore the left and right and

174
00:06:14,400 --> 00:06:17,759
then merge them

175
00:06:15,919 --> 00:06:19,919
and then how to yeah

176
00:06:17,759 --> 00:06:22,800
where the wow that's excellent yeah so

177
00:06:19,919 --> 00:06:24,960
so this is five times more obviously so

178
00:06:22,800 --> 00:06:27,440
basically this question we have we have

179
00:06:24,960 --> 00:06:29,520
talked about separate two steps separate

180
00:06:27,440 --> 00:06:32,319
before right so first step is in order

181
00:06:29,520 --> 00:06:34,720
we are that's very obvious we know that

182
00:06:32,319 --> 00:06:37,039
and once we got this in order we have

183
00:06:34,720 --> 00:06:39,919
these two sorted this right

184
00:06:37,039 --> 00:06:43,440
and the next step is to merge them right

185
00:06:39,919 --> 00:06:46,720
yeah so if we don't use this if this is

186
00:06:43,440 --> 00:06:48,240
a two arbitrage financing not not a

187
00:06:46,720 --> 00:06:51,039
binary research tree then the only way

188
00:06:48,240 --> 00:06:53,039
we can do it is to uh to to to travel

189
00:06:51,039 --> 00:06:55,199
both um trees

190
00:06:53,039 --> 00:06:56,720
and then we just merge them and then

191
00:06:55,199 --> 00:06:59,120
starting we need to sort it afterwards

192
00:06:56,720 --> 00:07:02,240
right if we put them in order so we can

193
00:06:59,120 --> 00:07:04,800
do any arbitrary trans tree services

194
00:07:02,240 --> 00:07:06,080
definite search pre-ordering order uh

195
00:07:04,800 --> 00:07:08,720
post order

196
00:07:06,080 --> 00:07:11,360
or all the level by level

197
00:07:08,720 --> 00:07:13,039
order right the number by the

198
00:07:11,360 --> 00:07:15,599
preference search order

199
00:07:13,039 --> 00:07:18,160
and then we got a tool list which is not

200
00:07:15,599 --> 00:07:19,919
sorted and now we can merge them and

201
00:07:18,160 --> 00:07:22,000
then we will do sorting so what's the

202
00:07:19,919 --> 00:07:24,479
time time next if we want to sort it do

203
00:07:22,000 --> 00:07:24,479
the stocking

204
00:07:24,780 --> 00:07:29,520
[Music]

205
00:07:27,759 --> 00:07:31,919
so for example the first planetary if it

206
00:07:29,520 --> 00:07:33,599
is n nodes and the second one is m nodes

207
00:07:31,919 --> 00:07:36,000
if we use the

208
00:07:33,599 --> 00:07:38,639
naive one we if you're not making use of

209
00:07:36,000 --> 00:07:40,800
the fact that they are both uh

210
00:07:38,639 --> 00:07:43,360
binary search tree and we can do this in

211
00:07:40,800 --> 00:07:44,960
other things to make it a salty beast if

212
00:07:43,360 --> 00:07:47,759
we're just doing these you know blue

213
00:07:44,960 --> 00:07:49,680
falls just just run the medium

214
00:07:47,759 --> 00:07:51,759
just do some random travel so to make

215
00:07:49,680 --> 00:07:53,919
sure all the notes are visited and then

216
00:07:51,759 --> 00:07:56,479
then we combine two

217
00:07:53,919 --> 00:07:58,319
notes and then we just can do this

218
00:07:56,479 --> 00:08:01,120
sorting so the time conduction will be

219
00:07:58,319 --> 00:08:02,960
om plus m that's the total number of

220
00:08:01,120 --> 00:08:04,400
nodes and log

221
00:08:02,960 --> 00:08:07,039
n plus m yeah

222
00:08:04,400 --> 00:08:09,599
yeah this is uh but we but the thing is

223
00:08:07,039 --> 00:08:11,680
that it's a five uh binary system so we

224
00:08:09,599 --> 00:08:14,720
can do this in order i know we can merge

225
00:08:11,680 --> 00:08:16,080
it yeah so so okay we can have these two

226
00:08:14,720 --> 00:08:18,720
in other things so

227
00:08:16,080 --> 00:08:20,400
a equals in order

228
00:08:18,720 --> 00:08:24,560
to

229
00:08:20,400 --> 00:08:27,280
one right and b equals in order

230
00:08:24,560 --> 00:08:29,759
rule two right and now we can merge this

231
00:08:27,280 --> 00:08:31,039
because a and b this is already sorted

232
00:08:29,759 --> 00:08:33,760
right so

233
00:08:31,039 --> 00:08:35,279
so the time conductor okay let me

234
00:08:33,760 --> 00:08:37,200
uh

235
00:08:35,279 --> 00:08:39,599
let me write this merge first okay so

236
00:08:37,200 --> 00:08:41,680
this uh this one is easy i'm

237
00:08:39,599 --> 00:08:44,320
erase this bit

238
00:08:41,680 --> 00:08:46,160
and this is for the iteration iterated

239
00:08:44,320 --> 00:08:49,040
in order thing which we're going to use

240
00:08:46,160 --> 00:08:50,080
later okay so let's say a equals in

241
00:08:49,040 --> 00:08:54,000
order

242
00:08:50,080 --> 00:08:56,560
blue one blue one the first three yeah b

243
00:08:54,000 --> 00:08:58,560
was in order

244
00:08:56,560 --> 00:09:00,880
blue two

245
00:08:58,560 --> 00:09:04,320
blue two okay and then we have a length

246
00:09:00,880 --> 00:09:05,680
l a l b equals length a

247
00:09:04,320 --> 00:09:07,680
lens b

248
00:09:05,680 --> 00:09:10,959
and then we have this answer

249
00:09:07,680 --> 00:09:12,880
equal empty list and then i equals j

250
00:09:10,959 --> 00:09:15,040
equals zero we don't how do we merge two

251
00:09:12,880 --> 00:09:16,160
sort to this any idea if there are two

252
00:09:15,040 --> 00:09:18,959
sorting like

253
00:09:16,160 --> 00:09:22,320
zero one you see which one is bigger

254
00:09:18,959 --> 00:09:22,320
yeah yellow two four

255
00:09:23,920 --> 00:09:29,200
yeah look there's two salty days here

256
00:09:26,080 --> 00:09:31,200
look yes co two four six a and one three

257
00:09:29,200 --> 00:09:33,760
five seven nine so we have two pointer

258
00:09:31,200 --> 00:09:36,560
zero is smaller than one we put a zero

259
00:09:33,760 --> 00:09:38,959
we move the pointer the first one to two

260
00:09:36,560 --> 00:09:40,640
and two one is smaller than two

261
00:09:38,959 --> 00:09:43,519
yeah and then go this way but ten

262
00:09:40,640 --> 00:09:45,519
conductors om plus mb yeah

263
00:09:43,519 --> 00:09:47,120
look if there are not in the first three

264
00:09:45,519 --> 00:09:49,120
and the end node in the second tree so

265
00:09:47,120 --> 00:09:53,600
time conducts it to merge two sorted

266
00:09:49,120 --> 00:09:57,120
lists two two threes would be o n plus n

267
00:09:53,600 --> 00:10:00,240
right or em plus them and to the time to

268
00:09:57,120 --> 00:10:02,480
trevor today in order is o n for the

269
00:10:00,240 --> 00:10:04,160
first three o and four first three for

270
00:10:02,480 --> 00:10:08,079
the second tree so the time convexity

271
00:10:04,160 --> 00:10:10,720
will be o n plus m plus m plus m

272
00:10:08,079 --> 00:10:12,800
o 2 n plus 2 o 2 m

273
00:10:10,720 --> 00:10:14,480
which is o m plus m right because we

274
00:10:12,800 --> 00:10:16,720
drop the constant when we talk about the

275
00:10:14,480 --> 00:10:18,079
time complexity and specific complexity

276
00:10:16,720 --> 00:10:21,200
and then let's go back to this one i'm

277
00:10:18,079 --> 00:10:23,279
not going to cook it very much y is i

278
00:10:21,200 --> 00:10:26,160
smaller than a a

279
00:10:23,279 --> 00:10:29,279
and j smaller than lb

280
00:10:26,160 --> 00:10:30,880
now we check if a i is smaller or equal

281
00:10:29,279 --> 00:10:32,959
than bj

282
00:10:30,880 --> 00:10:36,240
then we merge the we take the smaller

283
00:10:32,959 --> 00:10:37,360
one answer the append

284
00:10:36,240 --> 00:10:39,440
a i

285
00:10:37,360 --> 00:10:40,959
and then move this pointer i plus equal

286
00:10:39,440 --> 00:10:42,240
one as

287
00:10:40,959 --> 00:10:44,079
we take the

288
00:10:42,240 --> 00:10:46,880
smaller one i'll take this pick a

289
00:10:44,079 --> 00:10:48,160
smaller one for which is bj right in

290
00:10:46,880 --> 00:10:49,680
this case

291
00:10:48,160 --> 00:10:51,920
bj

292
00:10:49,680 --> 00:10:53,200
and j plus equal one

293
00:10:51,920 --> 00:10:55,600
okay and

294
00:10:53,200 --> 00:10:58,000
when we are outside though

295
00:10:55,600 --> 00:11:00,079
one on the outside the while loop so

296
00:10:58,000 --> 00:11:02,880
there might be adding remaining elements

297
00:11:00,079 --> 00:11:05,040
because the the length of the two arrays

298
00:11:02,880 --> 00:11:07,519
two sorted array might not be the same

299
00:11:05,040 --> 00:11:08,399
so we need to append the rest right so

300
00:11:07,519 --> 00:11:11,519
if

301
00:11:08,399 --> 00:11:14,000
i is smaller than a a then we answer dot

302
00:11:11,519 --> 00:11:15,680
extend with using the extent functions

303
00:11:14,000 --> 00:11:20,079
to take whatever

304
00:11:15,680 --> 00:11:22,880
is remaining which is a i to the n

305
00:11:20,079 --> 00:11:24,480
and then the same if j smaller than l b

306
00:11:22,880 --> 00:11:26,000
answer the

307
00:11:24,480 --> 00:11:28,959
extent

308
00:11:26,000 --> 00:11:31,200
it's 10 right what's extreme in english

309
00:11:28,959 --> 00:11:33,839
b j to the end

310
00:11:31,200 --> 00:11:36,800
make it longer make it longer exactly

311
00:11:33,839 --> 00:11:39,120
okay so return answer

312
00:11:36,800 --> 00:11:41,120
okay yeah look we have this in order

313
00:11:39,120 --> 00:11:43,600
iterated in order right so another way

314
00:11:41,120 --> 00:11:45,760
is that we can do this iterate in order

315
00:11:43,600 --> 00:11:47,600
on both three

316
00:11:45,760 --> 00:11:50,000
in parallel there okay this is a little

317
00:11:47,600 --> 00:11:52,399
bit advanced topic it's a

318
00:11:50,000 --> 00:11:55,279
it's a it's more complex yeah but it's

319
00:11:52,399 --> 00:11:58,399
not easy to think of but this one yeah

320
00:11:55,279 --> 00:12:00,959
we have talked about doing in order

321
00:11:58,399 --> 00:12:02,560
recursion they are iterative

322
00:12:00,959 --> 00:12:04,800
and then once we have this in order we

323
00:12:02,560 --> 00:12:06,880
have to sort this then we can merge yeah

324
00:12:04,800 --> 00:12:09,680
we talked about these two topics before

325
00:12:06,880 --> 00:12:12,399
right yeah so today nothing new it's

326
00:12:09,680 --> 00:12:14,480
just to combine these two two steps

327
00:12:12,399 --> 00:12:18,079
okay so now the thing is that look we

328
00:12:14,480 --> 00:12:22,079
have this you know that we can do this

329
00:12:18,079 --> 00:12:24,320
iterated in order with two binary final

330
00:12:22,079 --> 00:12:26,880
search tree in parallel layer so how do

331
00:12:24,320 --> 00:12:30,639
we do this in pair so we can do this st1

332
00:12:26,880 --> 00:12:35,519
yeah then we have the st2 equals

333
00:12:30,639 --> 00:12:37,440
okay and then while root or st1 yeah

334
00:12:35,519 --> 00:12:39,200
root one yeah there are two trees yeah

335
00:12:37,440 --> 00:12:40,800
actually that's two three blue one rule

336
00:12:39,200 --> 00:12:45,040
two

337
00:12:40,800 --> 00:12:47,519
blue one or st1 or ru2

338
00:12:45,040 --> 00:12:49,440
or st2 yeah

339
00:12:47,519 --> 00:12:52,959
and then we we do this we need to copy

340
00:12:49,440 --> 00:12:54,639
these two yeah why l1 uh blue one blue

341
00:12:52,959 --> 00:12:56,800
one the left and now we need to copy

342
00:12:54,639 --> 00:12:58,880
these to rule two okay there's another

343
00:12:56,800 --> 00:12:59,680
one for row two

344
00:12:58,880 --> 00:13:02,399
okay

345
00:12:59,680 --> 00:13:04,480
and then now we we have to take we have

346
00:13:02,399 --> 00:13:07,680
to take the smaller one so we how do we

347
00:13:04,480 --> 00:13:09,600
take a small one if

348
00:13:07,680 --> 00:13:10,560
if not st

349
00:13:09,600 --> 00:13:11,680
1

350
00:13:10,560 --> 00:13:14,399
or

351
00:13:11,680 --> 00:13:17,920
st 1 dot value

352
00:13:14,399 --> 00:13:19,600
if not st 1 or st 1 dot value

353
00:13:17,920 --> 00:13:23,839
st 1 the

354
00:13:19,600 --> 00:13:27,519
one stack of value is smaller than st1

355
00:13:23,839 --> 00:13:31,200
st2 minus one dot value

356
00:13:27,519 --> 00:13:33,680
yeah okay so the thing is network

357
00:13:31,200 --> 00:13:38,480
if we if the stack

358
00:13:33,680 --> 00:13:40,320
if st1 yeah if st1 is smaller than st2

359
00:13:38,480 --> 00:13:46,160
value then we took we take the smaller

360
00:13:40,320 --> 00:13:49,040
one right if not st2 rst1 and c1 and

361
00:13:46,160 --> 00:13:51,199
st1 the value values and we take the sty

362
00:13:49,040 --> 00:13:54,880
we talk take the note from the first

363
00:13:51,199 --> 00:13:58,160
tree which is the loot one or st1 dot

364
00:13:54,880 --> 00:13:58,160
pop and apparently

365
00:13:58,800 --> 00:14:02,959
i s

366
00:14:00,399 --> 00:14:04,959
as we take the rule two okay i'm going

367
00:14:02,959 --> 00:14:06,560
to write this here it's too squishy here

368
00:14:04,959 --> 00:14:07,440
okay

369
00:14:06,560 --> 00:14:10,800
okay

370
00:14:07,440 --> 00:14:13,440
so we are combining two iterative in

371
00:14:10,800 --> 00:14:16,399
order in one single function

372
00:14:13,440 --> 00:14:17,360
so we're checking every time we

373
00:14:16,399 --> 00:14:18,399
push

374
00:14:17,360 --> 00:14:20,639
the

375
00:14:18,399 --> 00:14:24,880
left node to

376
00:14:20,639 --> 00:14:26,079
each stack st1 st1 st1 as d2 okay

377
00:14:24,880 --> 00:14:28,160
st1

378
00:14:26,079 --> 00:14:30,959
and then we have the another one for sd2

379
00:14:28,160 --> 00:14:33,760
which is the bluetooth and now we need

380
00:14:30,959 --> 00:14:35,519
to check if the st is the value in the

381
00:14:33,760 --> 00:14:37,519
first stack the first step is for the

382
00:14:35,519 --> 00:14:39,680
first three it's smaller than the second

383
00:14:37,519 --> 00:14:41,360
one we take the first the node from the

384
00:14:39,680 --> 00:14:42,720
first one otherwise we take a note from

385
00:14:41,360 --> 00:14:45,839
the second one right

386
00:14:42,720 --> 00:14:47,680
do i make myself clear

387
00:14:45,839 --> 00:14:50,240
okay so it's too squishy here but

388
00:14:47,680 --> 00:14:52,000
basically that's what it is so every

389
00:14:50,240 --> 00:14:54,320
time you see this you need to duplicate

390
00:14:52,000 --> 00:14:55,600
it for the another tree

391
00:14:54,320 --> 00:14:57,680
yeah and

392
00:14:55,600 --> 00:15:01,600
taking this is taking a note from a step

393
00:14:57,680 --> 00:15:04,399
but we we need to check which stack

394
00:15:01,600 --> 00:15:06,480
has the smaller number right so if the

395
00:15:04,399 --> 00:15:08,480
second step is empty

396
00:15:06,480 --> 00:15:11,519
if the second step is empty then we take

397
00:15:08,480 --> 00:15:13,279
the first node or if the second stack

398
00:15:11,519 --> 00:15:16,000
the note of the

399
00:15:13,279 --> 00:15:19,920
if the first if the second stack

400
00:15:16,000 --> 00:15:21,440
is empty if we take the first step

401
00:15:19,920 --> 00:15:24,959
or

402
00:15:21,440 --> 00:15:27,680
if the second stack is not empty but

403
00:15:24,959 --> 00:15:29,839
the first stack is the value the top of

404
00:15:27,680 --> 00:15:32,639
the stack is the smaller than the top of

405
00:15:29,839 --> 00:15:34,480
the second stack then we also take this

406
00:15:32,639 --> 00:15:35,920
first the node from the first step

407
00:15:34,480 --> 00:15:38,399
otherwise we take the node from the

408
00:15:35,920 --> 00:15:40,639
second step so this time condensing it's

409
00:15:38,399 --> 00:15:42,560
a it's a it's the same but it's one part

410
00:15:40,639 --> 00:15:44,160
the advantage of this is one part for

411
00:15:42,560 --> 00:15:45,759
the previous one is two parts why would

412
00:15:44,160 --> 00:15:47,360
you save two parts because they're in

413
00:15:45,759 --> 00:15:50,240
order

414
00:15:47,360 --> 00:15:51,600
in order one pass right that's one pass

415
00:15:50,240 --> 00:15:55,120
and then we merge it

416
00:15:51,600 --> 00:15:57,759
second pass yeah this one is one task

417
00:15:55,120 --> 00:16:00,320
okay what have you learned today

418
00:15:57,759 --> 00:16:00,320
about

419
00:16:01,600 --> 00:16:05,759
what's the problem what's the problem uh

420
00:16:03,680 --> 00:16:10,880
there are two binary trees finally

421
00:16:05,759 --> 00:16:11,759
search trees yeah and then we thought

422
00:16:10,880 --> 00:16:12,639
um

423
00:16:11,759 --> 00:16:15,279
we

424
00:16:12,639 --> 00:16:18,079
we want to return all elements from both

425
00:16:15,279 --> 00:16:20,720
trees combined right yeah so

426
00:16:18,079 --> 00:16:24,399
what's the way what's the egg room you

427
00:16:20,720 --> 00:16:27,120
do in order for both of them and then

428
00:16:24,399 --> 00:16:30,000
yeah and the time to next year will be o

429
00:16:27,120 --> 00:16:31,759
and plus n right yeah i know what's the

430
00:16:30,000 --> 00:16:34,320
second one do you understand this one or

431
00:16:31,759 --> 00:16:35,920
is it too difficult for you

432
00:16:34,320 --> 00:16:38,160
it's fine if it's too difficult because

433
00:16:35,920 --> 00:16:40,880
this one is out of scope

434
00:16:38,160 --> 00:16:42,639
it's medium it's medium so we do this

435
00:16:40,880 --> 00:16:45,360
one is iterative

436
00:16:42,639 --> 00:16:47,839
iterated in order so we are take we are

437
00:16:45,360 --> 00:16:50,720
doing so basically this one is what we

438
00:16:47,839 --> 00:16:53,920
are doing the inorder

439
00:16:50,720 --> 00:16:55,040
for both trees in parallel yeah but

440
00:16:53,920 --> 00:16:56,639
dealing

441
00:16:55,040 --> 00:16:57,680
in order we just take whatever is

442
00:16:56,639 --> 00:17:00,000
smaller

443
00:16:57,680 --> 00:17:02,320
right and this one is not uh

444
00:17:00,000 --> 00:17:05,360
it's not recursion it's the

445
00:17:02,320 --> 00:17:07,919
it's it's rated using the step right

446
00:17:05,360 --> 00:17:11,240
okay that's it for today bye-bye bye-bye

447
00:17:07,919 --> 00:17:11,240
bye bye

