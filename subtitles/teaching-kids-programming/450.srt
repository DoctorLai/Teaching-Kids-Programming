1
00:00:00,000 --> 00:00:05,279
go hello mister and mr ryan all right

2
00:00:03,600 --> 00:00:08,080
okay so we talked about the binary

3
00:00:05,279 --> 00:00:09,760
search tree okay so final research tree

4
00:00:08,080 --> 00:00:12,799
what's fine research tree in one

5
00:00:09,760 --> 00:00:14,920
sentence please anybody finally said

6
00:00:12,799 --> 00:00:18,320
tree

7
00:00:14,920 --> 00:00:21,359
is funny tree we and but it also a

8
00:00:18,320 --> 00:00:22,480
binary search tree is a binary

9
00:00:21,359 --> 00:00:25,039
tree

10
00:00:22,480 --> 00:00:27,119
finally search tree is a binary but it

11
00:00:25,039 --> 00:00:29,439
also has to satisfy that the notes on

12
00:00:27,119 --> 00:00:30,320
the left side should be strictly smaller

13
00:00:29,439 --> 00:00:32,880
than the

14
00:00:30,320 --> 00:00:35,360
flute okay and the node on the right

15
00:00:32,880 --> 00:00:37,120
side should be strictly bigger than that

16
00:00:35,360 --> 00:00:38,719
so this is the final search tree look

17
00:00:37,120 --> 00:00:40,879
the loop

18
00:00:38,719 --> 00:00:43,040
left smaller than the loop the line

19
00:00:40,879 --> 00:00:44,640
bigger than the root

20
00:00:43,040 --> 00:00:45,520
eric yeah

21
00:00:44,640 --> 00:00:47,840
so

22
00:00:45,520 --> 00:00:49,760
one thing about vanessa's trees it does

23
00:00:47,840 --> 00:00:52,399
not contain duplicates so we cannot have

24
00:00:49,760 --> 00:00:54,719
at least double two here you know

25
00:00:52,399 --> 00:00:56,160
that that is not a brand new trick and

26
00:00:54,719 --> 00:00:59,120
then also

27
00:00:56,160 --> 00:01:01,600
also if i have at least minus one and

28
00:00:59,120 --> 00:01:04,239
then this this note yeah

29
00:01:01,600 --> 00:01:07,760
eight is this minus thirteen why is that

30
00:01:04,239 --> 00:01:10,080
because eight is not smaller than two

31
00:01:07,760 --> 00:01:11,920
exactly that's a p four yeah so every

32
00:01:10,080 --> 00:01:14,159
note on the left should be smaller than

33
00:01:11,920 --> 00:01:17,040
that right so this is bigger than that

34
00:01:14,159 --> 00:01:19,520
but that has to be smaller than two okay

35
00:01:17,040 --> 00:01:22,320
so i can put zero so why do we have

36
00:01:19,520 --> 00:01:25,280
these because if we perform what kind of

37
00:01:22,320 --> 00:01:27,360
order then you become in order

38
00:01:25,280 --> 00:01:29,360
yeah don't you get it

39
00:01:27,360 --> 00:01:30,640
so we want to do this binaries uh we

40
00:01:29,360 --> 00:01:33,040
want to perform this in all the

41
00:01:30,640 --> 00:01:36,000
traversal yeah in order if we perform

42
00:01:33,040 --> 00:01:37,680
this in order to traverse huh

43
00:01:36,000 --> 00:01:39,600
in order to have answer and then the

44
00:01:37,680 --> 00:01:41,600
lead then we'll get the assorted list

45
00:01:39,600 --> 00:01:44,320
yeah for example in order to have a lot

46
00:01:41,600 --> 00:01:46,640
so it's visit the left tree first

47
00:01:44,320 --> 00:01:48,880
we visit the left that tree therefore

48
00:01:46,640 --> 00:01:50,320
search left i know which is the loot and

49
00:01:48,880 --> 00:01:52,720
then we visit the

50
00:01:50,320 --> 00:01:54,079
white tree right this is the student

51
00:01:52,720 --> 00:01:56,240
code from that

52
00:01:54,079 --> 00:01:57,520
in order traversal so look if we visit

53
00:01:56,240 --> 00:01:59,680
the left tree

54
00:01:57,520 --> 00:02:01,280
yeah first yeah and now we visit the

55
00:01:59,680 --> 00:02:04,640
node

56
00:02:01,280 --> 00:02:06,719
so we what do we get here is minus one

57
00:02:04,640 --> 00:02:09,599
zero to three okay so it's in order

58
00:02:06,719 --> 00:02:12,080
right ready okay so today's task we want

59
00:02:09,599 --> 00:02:13,520
to find we will given this by psc we

60
00:02:12,080 --> 00:02:15,840
want to find the k

61
00:02:13,520 --> 00:02:17,520
smallest k smallest

62
00:02:15,840 --> 00:02:19,200
number in the

63
00:02:17,520 --> 00:02:21,440
bst

64
00:02:19,200 --> 00:02:24,640
yeah we want to find out the case for

65
00:02:21,440 --> 00:02:27,040
example this this given this another k

66
00:02:24,640 --> 00:02:28,720
is in one index if

67
00:02:27,040 --> 00:02:32,400
if it's uh

68
00:02:28,720 --> 00:02:33,840
k equals one then the first one then is

69
00:02:32,400 --> 00:02:36,480
which uh the

70
00:02:33,840 --> 00:02:39,360
the smallest and the first smallest

71
00:02:36,480 --> 00:02:40,160
number is minus one and when k equals

72
00:02:39,360 --> 00:02:41,040
two

73
00:02:40,160 --> 00:02:43,360
then you

74
00:02:41,040 --> 00:02:46,560
we should get the zero right because

75
00:02:43,360 --> 00:02:48,959
zero is the second smallest right okay

76
00:02:46,560 --> 00:02:50,640
any idea any idea

77
00:02:48,959 --> 00:02:52,319
another what do we what did we learn

78
00:02:50,640 --> 00:02:56,319
yesterday we learned about turning this

79
00:02:52,319 --> 00:02:57,599
into a greater tree yeah yeah zero

80
00:02:56,319 --> 00:03:00,000
minus one

81
00:02:57,599 --> 00:03:01,200
two three yeah

82
00:03:00,000 --> 00:03:02,720
yeah

83
00:03:01,200 --> 00:03:05,280
that's what we talked about yesterday

84
00:03:02,720 --> 00:03:06,560
but today we want to find the katie's k

85
00:03:05,280 --> 00:03:10,959
smallest

86
00:03:06,560 --> 00:03:10,959
number in a binary search tree anybody

87
00:03:11,040 --> 00:03:14,159
what's your thoughts

88
00:03:12,200 --> 00:03:16,480
[Music]

89
00:03:14,159 --> 00:03:19,040
the same thing yeah same thing yeah

90
00:03:16,480 --> 00:03:20,800
exactly same thing perform this in order

91
00:03:19,040 --> 00:03:22,879
right and then we we talked about the

92
00:03:20,800 --> 00:03:24,159
year thing yeah what's the year i think

93
00:03:22,879 --> 00:03:26,720
right

94
00:03:24,159 --> 00:03:28,720
what's the year the iteration

95
00:03:26,720 --> 00:03:31,120
yeah promise yeah exactly it's like that

96
00:03:28,720 --> 00:03:33,760
i promise you i will return this but

97
00:03:31,120 --> 00:03:36,480
that's not the time yet yeah when we get

98
00:03:33,760 --> 00:03:38,640
it so why why do we need a iterator for

99
00:03:36,480 --> 00:03:40,400
the year for in this case because the

100
00:03:38,640 --> 00:03:42,400
three might be this big

101
00:03:40,400 --> 00:03:44,879
the the total number of notes might be

102
00:03:42,400 --> 00:03:46,799
armenian right but if you're asking me

103
00:03:44,879 --> 00:03:49,040
like what's the 10th

104
00:03:46,799 --> 00:03:50,959
smallest number do i have to traverse

105
00:03:49,040 --> 00:03:53,360
all the tree

106
00:03:50,959 --> 00:03:55,920
right do you get it

107
00:03:53,360 --> 00:03:59,360
so look if if there are lots of notes

108
00:03:55,920 --> 00:04:02,879
here if the total note is a minion

109
00:03:59,360 --> 00:04:05,519
and all we want to know is the

110
00:04:02,879 --> 00:04:08,480
the third smallest

111
00:04:05,519 --> 00:04:11,200
third smallest

112
00:04:08,480 --> 00:04:13,599
number in the final search tree so

113
00:04:11,200 --> 00:04:15,920
if this is the case i don't need to

114
00:04:13,599 --> 00:04:17,600
travel i i don't need to visit a minion

115
00:04:15,920 --> 00:04:20,160
right because this final research street

116
00:04:17,600 --> 00:04:22,240
give us the thought that we have

117
00:04:20,160 --> 00:04:25,199
all we have to do is visit the third one

118
00:04:22,240 --> 00:04:28,639
and that's it right so we we can use the

119
00:04:25,199 --> 00:04:31,199
uh the year so so it it you'll be better

120
00:04:28,639 --> 00:04:33,199
to use the iterator instead of

121
00:04:31,199 --> 00:04:34,560
converting obviously if

122
00:04:33,199 --> 00:04:35,520
if

123
00:04:34,560 --> 00:04:37,840
um

124
00:04:35,520 --> 00:04:41,360
if the note is more right the number of

125
00:04:37,840 --> 00:04:44,080
notes is more like maybe a 100 right but

126
00:04:41,360 --> 00:04:46,240
we can it's okay we probably can convert

127
00:04:44,080 --> 00:04:48,960
everything convert this binary into a

128
00:04:46,240 --> 00:04:51,120
list yeah into this into a list and now

129
00:04:48,960 --> 00:04:53,040
we do this k thing okay i'm going to

130
00:04:51,120 --> 00:04:55,680
write this okay

131
00:04:53,040 --> 00:04:57,520
so i need the eraser

132
00:04:55,680 --> 00:04:58,720
so i'm going to write uh

133
00:04:57,520 --> 00:05:01,280
um

134
00:04:58,720 --> 00:05:03,440
a few methods yeah so you and you tell

135
00:05:01,280 --> 00:05:06,720
me which one is the best okay the most

136
00:05:03,440 --> 00:05:07,600
naive way of doing this right so let's

137
00:05:06,720 --> 00:05:11,440
say

138
00:05:07,600 --> 00:05:12,240
define default search loot

139
00:05:11,440 --> 00:05:13,680
okay

140
00:05:12,240 --> 00:05:17,120
if not loot

141
00:05:13,680 --> 00:05:19,280
if the root will return empty list yeah

142
00:05:17,120 --> 00:05:21,039
empty this and then we can do this

143
00:05:19,280 --> 00:05:24,400
return

144
00:05:21,039 --> 00:05:27,280
dfs rule the left

145
00:05:24,400 --> 00:05:32,160
this is from yesterday plus this is the

146
00:05:27,280 --> 00:05:33,120
least concatenation rule the value

147
00:05:32,160 --> 00:05:34,479
plus

148
00:05:33,120 --> 00:05:37,479
dfs

149
00:05:34,479 --> 00:05:37,479
rule.right

150
00:05:37,840 --> 00:05:43,199
so this is the in order traversal

151
00:05:40,960 --> 00:05:45,840
that returns a list then we can do this

152
00:05:43,199 --> 00:05:48,000
ar equals that's what search

153
00:05:45,840 --> 00:05:50,560
root and now we want to return the case

154
00:05:48,000 --> 00:05:54,400
one so we just return

155
00:05:50,560 --> 00:05:56,080
a r k k one the first one will be there

156
00:05:54,400 --> 00:05:57,600
will be k minus one right k minus

157
00:05:56,080 --> 00:05:59,360
something let's say sound is one the

158
00:05:57,600 --> 00:06:00,800
first one is the index

159
00:05:59,360 --> 00:06:03,199
you see

160
00:06:00,800 --> 00:06:05,919
that's that's the most simple one right

161
00:06:03,199 --> 00:06:08,080
so the disadvantages the pulse is very

162
00:06:05,919 --> 00:06:08,880
simple to implement everything

163
00:06:08,080 --> 00:06:11,199
right

164
00:06:08,880 --> 00:06:13,600
the cons the disadvantage okay i'm going

165
00:06:11,199 --> 00:06:15,600
to talk about this well the disadvantage

166
00:06:13,600 --> 00:06:18,080
is what i was just saying that if the

167
00:06:15,600 --> 00:06:20,880
number of nodes is to be a million nodes

168
00:06:18,080 --> 00:06:22,720
and this method needs to visit all the

169
00:06:20,880 --> 00:06:25,120
armenian nodes and come put it in the

170
00:06:22,720 --> 00:06:27,440
list and then do this yeah return okay

171
00:06:25,120 --> 00:06:29,600
yeah so this is not very convenient but

172
00:06:27,440 --> 00:06:30,560
we can do we can improve it we can

173
00:06:29,600 --> 00:06:35,039
improve it

174
00:06:30,560 --> 00:06:37,440
with this one so how do we do this so

175
00:06:35,039 --> 00:06:40,240
so instead we we are not written in the

176
00:06:37,440 --> 00:06:42,080
list we are not returning this

177
00:06:40,240 --> 00:06:44,240
therefore such root and now we have this

178
00:06:42,080 --> 00:06:46,319
k here and we have this answer at the

179
00:06:44,240 --> 00:06:49,680
beginning we set it to 9

180
00:06:46,319 --> 00:06:51,440
right so if if the k is smaller than

181
00:06:49,680 --> 00:06:53,280
zero we just written here

182
00:06:51,440 --> 00:06:55,599
because we don't want to continue

183
00:06:53,280 --> 00:06:56,560
visiting it now we want to visit the

184
00:06:55,599 --> 00:06:59,280
left

185
00:06:56,560 --> 00:07:02,000
left path down left

186
00:06:59,280 --> 00:07:04,319
okay and then we here we k minus equals

187
00:07:02,000 --> 00:07:07,440
one right we have visited one more note

188
00:07:04,319 --> 00:07:09,680
if k equal equal to zero then answer we

189
00:07:07,440 --> 00:07:10,960
set it answer answer equals two dot

190
00:07:09,680 --> 00:07:11,759
value

191
00:07:10,960 --> 00:07:14,000
and

192
00:07:11,759 --> 00:07:16,160
return okay we written here

193
00:07:14,000 --> 00:07:18,960
and now we can do this definitely don't

194
00:07:16,160 --> 00:07:22,400
write uh loot alright okay

195
00:07:18,960 --> 00:07:24,800
and then we do the stafford search root

196
00:07:22,400 --> 00:07:25,759
and then we return the answer yeah you

197
00:07:24,800 --> 00:07:28,000
see

198
00:07:25,759 --> 00:07:30,160
this is a small improvement yeah all

199
00:07:28,000 --> 00:07:31,520
right come on

200
00:07:30,160 --> 00:07:33,599
i'm going to explain this one more time

201
00:07:31,520 --> 00:07:35,919
yeah we won't we decrement this k when

202
00:07:33,599 --> 00:07:38,240
we visit one note we decrement it and if

203
00:07:35,919 --> 00:07:39,599
it's zero then it means that's the node

204
00:07:38,240 --> 00:07:42,560
we are looking for

205
00:07:39,599 --> 00:07:44,639
and we set the answer answer here right

206
00:07:42,560 --> 00:07:46,879
okay so i'm going to write here a noun

207
00:07:44,639 --> 00:07:48,879
loader just to use the variable

208
00:07:46,879 --> 00:07:51,120
non-local answer

209
00:07:48,879 --> 00:07:53,599
okay okay

210
00:07:51,120 --> 00:07:54,800
and then look look we visited the left

211
00:07:53,599 --> 00:07:57,199
tree

212
00:07:54,800 --> 00:07:58,560
we visited the current node we visited

213
00:07:57,199 --> 00:08:00,879
the right tree

214
00:07:58,560 --> 00:08:02,639
do this type of such one sun yeah

215
00:08:00,879 --> 00:08:06,000
so this is simple improvement yeah

216
00:08:02,639 --> 00:08:09,599
because that allows us to skip

217
00:08:06,000 --> 00:08:11,440
the rest if we if okay so pst with a

218
00:08:09,599 --> 00:08:13,840
minion nodes and now

219
00:08:11,440 --> 00:08:17,520
i just want you to find out the

220
00:08:13,840 --> 00:08:20,000
first movie the smallest note yeah yeah

221
00:08:17,520 --> 00:08:21,840
so you just find it right

222
00:08:20,000 --> 00:08:23,919
and you don't need to find find the rest

223
00:08:21,840 --> 00:08:27,280
a mini minus one note right once you

224
00:08:23,919 --> 00:08:28,639
find the target do you need to continue

225
00:08:27,280 --> 00:08:30,639
because you already have the answer why

226
00:08:28,639 --> 00:08:32,320
would you visit all the rest yeah simple

227
00:08:30,639 --> 00:08:34,080
as that

228
00:08:32,320 --> 00:08:35,919
that's this part if k is smaller than

229
00:08:34,080 --> 00:08:37,680
zero then we just return

230
00:08:35,919 --> 00:08:41,839
yeah here

231
00:08:37,680 --> 00:08:41,839
k minus equals one okay okay

232
00:08:42,479 --> 00:08:46,399
okay so now i'm going to write this much

233
00:08:44,720 --> 00:08:49,120
better one which is called the yield

234
00:08:46,399 --> 00:08:51,519
yeah function yeah yeah iterator yeah if

235
00:08:49,120 --> 00:08:53,200
we're using the yield to iterator to

236
00:08:51,519 --> 00:08:56,640
write it then you'll be much simpler

237
00:08:53,200 --> 00:08:58,000
okay define therefore search

238
00:08:56,640 --> 00:08:59,440
root

239
00:08:58,000 --> 00:09:01,120
look here

240
00:08:59,440 --> 00:09:03,600
yet

241
00:09:01,120 --> 00:09:05,680
okay so i'm going to still if not look

242
00:09:03,600 --> 00:09:07,839
uh

243
00:09:05,680 --> 00:09:10,000
ah okay probably here one one thing

244
00:09:07,839 --> 00:09:12,800
missing is that uh if not loser we

245
00:09:10,000 --> 00:09:15,440
should return okay if k smaller and zero

246
00:09:12,800 --> 00:09:16,720
are not root not root we should return

247
00:09:15,440 --> 00:09:18,080
okay

248
00:09:16,720 --> 00:09:21,120
yeah here

249
00:09:18,080 --> 00:09:23,040
if if not root

250
00:09:21,120 --> 00:09:25,279
return

251
00:09:23,040 --> 00:09:26,160
and then yeah

252
00:09:25,279 --> 00:09:27,760
from

253
00:09:26,160 --> 00:09:30,560
year from

254
00:09:27,760 --> 00:09:32,880
dfs to the left okay

255
00:09:30,560 --> 00:09:34,399
and then yield

256
00:09:32,880 --> 00:09:37,839
load of value

257
00:09:34,399 --> 00:09:41,440
what's the money and here what's next

258
00:09:37,839 --> 00:09:43,600
can you can't tell me what okay

259
00:09:41,440 --> 00:09:45,600
here from the left here

260
00:09:43,600 --> 00:09:50,000
is value and here from

261
00:09:45,600 --> 00:09:50,000
what right right exactly yeah

262
00:09:51,760 --> 00:09:56,800
and now we can just do this if we have

263
00:09:53,920 --> 00:10:00,880
this dfs dfs rule that returns the

264
00:09:56,800 --> 00:10:03,360
iterator yeah it returns a iterator

265
00:10:00,880 --> 00:10:04,959
so what do we do now so we just do this

266
00:10:03,360 --> 00:10:06,079
we just do this here

267
00:10:04,959 --> 00:10:09,360
return

268
00:10:06,079 --> 00:10:10,240
we're using the next next function

269
00:10:09,360 --> 00:10:11,200
next

270
00:10:10,240 --> 00:10:12,240
i

271
00:10:11,200 --> 00:10:14,399
for

272
00:10:12,240 --> 00:10:19,519
i

273
00:10:14,399 --> 00:10:22,560
next c okay for c i c in ic in

274
00:10:19,519 --> 00:10:23,839
innumerable what's enumerate anybody uh

275
00:10:22,560 --> 00:10:24,800
like

276
00:10:23,839 --> 00:10:26,640
keys

277
00:10:24,800 --> 00:10:29,600
i was i

278
00:10:26,640 --> 00:10:32,240
is that index c is the value

279
00:10:29,600 --> 00:10:35,680
d fs loser we want to return this is the

280
00:10:32,240 --> 00:10:38,640
iterator i is the index if

281
00:10:35,680 --> 00:10:40,160
i is equal k minus 1 right so we want to

282
00:10:38,640 --> 00:10:42,640
find out k1

283
00:10:40,160 --> 00:10:45,440
so obviously you can rewrite this using

284
00:10:42,640 --> 00:10:48,480
the traditional if statement yeah for

285
00:10:45,440 --> 00:10:51,760
see in enumerate dfs root yeah if i

286
00:10:48,480 --> 00:10:53,760
equals k minus one then we tend c okay

287
00:10:51,760 --> 00:10:56,800
but we are using a fancy syntax called

288
00:10:53,760 --> 00:11:00,640
the next function right next function so

289
00:10:56,800 --> 00:11:03,680
what's next function anybody remember

290
00:11:00,640 --> 00:11:06,480
okay the next function is the

291
00:11:03,680 --> 00:11:09,440
you know the returns the next

292
00:11:06,480 --> 00:11:10,640
next value in the iterator yeah next

293
00:11:09,440 --> 00:11:13,200
okay so look

294
00:11:10,640 --> 00:11:16,079
range function is a generator okay so we

295
00:11:13,200 --> 00:11:18,240
look a equals branch yeah we know the

296
00:11:16,079 --> 00:11:19,279
range yeah when is 10

297
00:11:18,240 --> 00:11:21,440
yeah

298
00:11:19,279 --> 00:11:24,160
range 10 from 0 to

299
00:11:21,440 --> 00:11:26,160
9 if we put an iterator here we convert

300
00:11:24,160 --> 00:11:28,640
it to iterator yeah then that's the

301
00:11:26,160 --> 00:11:31,120
iterator okay so next

302
00:11:28,640 --> 00:11:32,720
next a what does it return

303
00:11:31,120 --> 00:11:34,880
next a

304
00:11:32,720 --> 00:11:36,880
uh

305
00:11:34,880 --> 00:11:38,720
what's the first first value in the

306
00:11:36,880 --> 00:11:41,600
range ten

307
00:11:38,720 --> 00:11:43,279
one zero it starts from zero right okay

308
00:11:41,600 --> 00:11:45,680
it's yellow okay and then like two is

309
00:11:43,279 --> 00:11:46,720
another one next a what does it mean

310
00:11:45,680 --> 00:11:47,760
one

311
00:11:46,720 --> 00:11:49,279
two next

312
00:11:47,760 --> 00:11:51,040
seven eight nine nine

313
00:11:49,279 --> 00:11:54,639
okay okay

314
00:11:51,040 --> 00:11:56,560
next a suppose next a now is nine okay

315
00:11:54,639 --> 00:11:57,360
so next a what happened

316
00:11:56,560 --> 00:11:59,519
10

317
00:11:57,360 --> 00:12:02,480
no no no come on

318
00:11:59,519 --> 00:12:05,279
you already it's only eight

319
00:12:02,480 --> 00:12:07,200
look i'm the best come on yeah look at

320
00:12:05,279 --> 00:12:09,200
this range function between zero to nine

321
00:12:07,200 --> 00:12:11,360
but now we're writing out the number so

322
00:12:09,200 --> 00:12:12,959
you would you throw the error you'll

323
00:12:11,360 --> 00:12:16,560
have a mistake yeah you have an

324
00:12:12,959 --> 00:12:18,720
exception however if i do this next

325
00:12:16,560 --> 00:12:20,639
next a the second parameter is the

326
00:12:18,720 --> 00:12:22,160
default value if two things go wrong if

327
00:12:20,639 --> 00:12:24,560
i say minus one and it will tell me

328
00:12:22,160 --> 00:12:26,240
minus one right do you get it do you get

329
00:12:24,560 --> 00:12:29,279
it next

330
00:12:26,240 --> 00:12:31,680
range 10 range is a generator i convert

331
00:12:29,279 --> 00:12:33,279
it to iterator yeah convert the iterator

332
00:12:31,680 --> 00:12:34,720
and then every time you ask for it

333
00:12:33,279 --> 00:12:37,959
you'll give me the next one next one

334
00:12:34,720 --> 00:12:37,959
next one

335
00:12:38,000 --> 00:12:42,399
in in the iterator it's like a year

336
00:12:40,000 --> 00:12:43,920
promise right the iterator range 10

337
00:12:42,399 --> 00:12:46,079
means that okay i promise you i will

338
00:12:43,920 --> 00:12:47,040
give you ten numbers from zero to nine

339
00:12:46,079 --> 00:12:49,600
correct

340
00:12:47,040 --> 00:12:52,480
okay last movie zero you asked me one

341
00:12:49,600 --> 00:12:54,320
ask mommy okay you ask me nine and then

342
00:12:52,480 --> 00:12:56,399
you ask me one more time but i'm running

343
00:12:54,320 --> 00:12:58,800
out of numbers i promise already 10

344
00:12:56,399 --> 00:13:00,240
numbers you asked me 10 times already

345
00:12:58,800 --> 00:13:01,920
and you asked me one more time what what

346
00:13:00,240 --> 00:13:04,399
do i do

347
00:13:01,920 --> 00:13:05,839
i was screwing yeah i don't have more

348
00:13:04,399 --> 00:13:06,720
numbers for you next there's promise

349
00:13:05,839 --> 00:13:08,240
yeah

350
00:13:06,720 --> 00:13:10,560
and then but if i give a second

351
00:13:08,240 --> 00:13:13,519
parameter minus one yeah i can give up

352
00:13:10,560 --> 00:13:14,720
everything i told eric to you

353
00:13:13,519 --> 00:13:15,920
do you get it

354
00:13:14,720 --> 00:13:16,720
do you understand

355
00:13:15,920 --> 00:13:18,720
yeah

356
00:13:16,720 --> 00:13:20,959
all right yeah the range from the start

357
00:13:18,720 --> 00:13:20,959
with

358
00:13:24,100 --> 00:13:27,210
[Music]

359
00:13:33,760 --> 00:13:37,839
sss star stop

360
00:13:36,639 --> 00:13:40,320
or

361
00:13:37,839 --> 00:13:42,160
range stop okay there are three kinds of

362
00:13:40,320 --> 00:13:44,639
you can call this range function in

363
00:13:42,160 --> 00:13:46,639
three format star stop step stop does

364
00:13:44,639 --> 00:13:49,120
not include a stop like 10 you give a 10

365
00:13:46,639 --> 00:13:52,720
it does not reach the 10 right get it

366
00:13:49,120 --> 00:13:55,360
sss yeah star stop if the star

367
00:13:52,720 --> 00:13:58,240
is missing then it's default to zero if

368
00:13:55,360 --> 00:14:01,120
the step missing is default to one right

369
00:13:58,240 --> 00:14:03,839
step is one right okay make sense start

370
00:14:01,120 --> 00:14:06,160
stop step f okay in one sentence what

371
00:14:03,839 --> 00:14:07,519
have you learned so far today

372
00:14:06,160 --> 00:14:09,279
one sentence what have you learned so

373
00:14:07,519 --> 00:14:11,279
far yes

374
00:14:09,279 --> 00:14:12,399
final sentence what are we doing i am

375
00:14:11,279 --> 00:14:14,240
the best

376
00:14:12,399 --> 00:14:16,800
what are you what are we doing with the

377
00:14:14,240 --> 00:14:18,720
finances too what do we do

378
00:14:16,800 --> 00:14:21,199
okay smallest

379
00:14:18,720 --> 00:14:23,680
yeah we're using that different search

380
00:14:21,199 --> 00:14:25,680
in order yeah why do we need to perform

381
00:14:23,680 --> 00:14:28,000
it in order of the final search what do

382
00:14:25,680 --> 00:14:31,120
we get if we perform in order uh

383
00:14:28,000 --> 00:14:33,199
smallest to largest assorted okay yeah

384
00:14:31,120 --> 00:14:34,639
that will be for today bye bye

385
00:14:33,199 --> 00:14:37,639
bye

386
00:14:34,639 --> 00:14:37,639
bye

